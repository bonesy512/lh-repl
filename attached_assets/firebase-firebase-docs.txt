Directory structure:
└── firebase-firebase-docs/
    ├── README.md
    ├── CONTRIBUTING.md
    ├── LICENSE
    ├── codelabs/
    │   ├── codelab-friendlychat-android/
    │   │   └── steps/
    │   │       ├── index.lab.md
    │   │       ├── .gitignore
    │   │       └── img/
    │   ├── codelab-friendlychat-web/
    │   │   └── steps/
    │   │       ├── README.md
    │   │       ├── angular.json
    │   │       ├── firebase.json
    │   │       ├── firestore.indexes.json
    │   │       ├── firestore.rules
    │   │       ├── package.json
    │   │       ├── storage.rules
    │   │       ├── tailwind.config.js
    │   │       ├── test.md
    │   │       ├── tsconfig.app.json
    │   │       ├── tsconfig.json
    │   │       ├── tsconfig.spec.json
    │   │       ├── .editorconfig
    │   │       ├── .gitignore
    │   │       ├── functions/
    │   │       │   ├── package.json
    │   │       │   └── .gitignore
    │   │       └── src/
    │   │           ├── index.html
    │   │           ├── main.ts
    │   │           ├── styles.css
    │   │           ├── app/
    │   │           │   ├── app-routing.module.ts
    │   │           │   ├── app.component.css
    │   │           │   ├── app.component.html
    │   │           │   ├── app.component.spec.ts
    │   │           │   ├── app.component.ts
    │   │           │   ├── app.config.ts
    │   │           │   ├── app.module.ts
    │   │           │   ├── app.routes.ts
    │   │           │   ├── components/
    │   │           │   │   └── header/
    │   │           │   │       ├── header.component.css
    │   │           │   │       ├── header.component.html
    │   │           │   │       ├── header.component.spec.ts
    │   │           │   │       └── header.component.ts
    │   │           │   ├── pages/
    │   │           │   │   ├── chat-page/
    │   │           │   │   │   ├── chat-page.component.css
    │   │           │   │   │   ├── chat-page.component.html
    │   │           │   │   │   ├── chat-page.component.spec.ts
    │   │           │   │   │   └── chat-page.component.ts
    │   │           │   │   └── login-page/
    │   │           │   │       ├── login-page.component.css
    │   │           │   │       ├── login-page.component.html
    │   │           │   │       ├── login-page.component.spec.ts
    │   │           │   │       └── login-page.component.ts
    │   │           │   └── services/
    │   │           │       ├── chat.service.spec.ts
    │   │           │       └── chat.service.ts
    │   │           ├── assets/
    │   │           │   └── .gitkeep
    │   │           └── environments/
    │   │               └── environment.ts
    │   ├── codelab-friendlyeats-android/
    │   │   └── steps/
    │   │       ├── index.lab.md
    │   │       └── img/
    │   └── codelab-friendlyeats-web/
    │       └── vanilla-js/
    │           └── steps/
    │               ├── index.lab.md
    │               ├── .gitignore
    │               └── img/
    ├── docs/
    │   └── flutter/
    │       ├── README.md
    │       ├── analytics/
    │       │   ├── _events.md
    │       │   ├── _get-started.md
    │       │   └── _user-properties.md
    │       ├── app-check/
    │       │   ├── custom-resource.md
    │       │   ├── debug-provider.md
    │       │   └── default-providers.md
    │       ├── auth/
    │       │   ├── account-linking.md
    │       │   ├── anonymous-auth.md
    │       │   ├── custom-auth.md
    │       │   ├── email-link-auth.md
    │       │   ├── errors.md
    │       │   ├── federated-auth.md
    │       │   ├── manage-users.md
    │       │   ├── multi-factor.md
    │       │   ├── passing-state-in-email-actions.md
    │       │   ├── password-auth.md
    │       │   ├── phone-auth.md
    │       │   └── start.md
    │       ├── cloud-messaging/
    │       │   ├── client.md
    │       │   ├── first-message.md
    │       │   ├── receive.md
    │       │   └── topic-messaging.md
    │       ├── crashlytics/
    │       │   ├── _customize-crash-reports.md
    │       │   ├── _deobfuscated.md
    │       │   ├── _force-test-crash.md
    │       │   ├── _get-started.md
    │       │   └── _start-using-analytics.md
    │       ├── database/
    │       │   ├── _usecase_security_preamble.md
    │       │   ├── lists-of-data.md
    │       │   ├── offline-capabilities.md
    │       │   ├── read-and-write.md
    │       │   ├── start.md
    │       │   └── structure-data.md
    │       ├── dynamic-links/
    │       │   ├── create.md
    │       │   └── receive.md
    │       ├── in-app-messaging/
    │       │   ├── _customize-messages.md
    │       │   ├── _get-started.md
    │       │   └── _modify-message-behavior.md
    │       ├── ml/
    │       │   └── use-custom-models.md
    │       ├── perf-mon/
    │       │   ├── _custom-code-traces.md
    │       │   ├── _custom-network-traces.md
    │       │   ├── _disable-sdk.md
    │       │   └── get-started.md
    │       ├── reference/
    │       │   └── _toc.yaml
    │       ├── remote-config/
    │       │   └── _get-started.md
    │       ├── setup/
    │       │   ├── _setup_main.md
    │       │   ├── _setup_prereq_android.md
    │       │   ├── _setup_prereq_ios.md
    │       │   └── _setup_prereq_web.md
    │       ├── storage/
    │       │   ├── create-reference.md
    │       │   ├── delete-files.md
    │       │   ├── download-files.md
    │       │   ├── file-metadata.md
    │       │   ├── handle-errors.md
    │       │   ├── list-files.md
    │       │   ├── start.md
    │       │   └── upload-files.md
    │       └── test-lab/
    │           └── integration-testing-with-flutter.md
    └── .github/
        └── workflows/
            ├── pull-and-push-all.yml
            └── pull-map-and-push-repo.yml

================================================
File: README.md
================================================
# Firebase Open Source Docs
Firebase Open Source Docs is a monorepo that contains
all Firebase written documentation that accepts community
contributions. This includes Firebase product documentation
or codelab steps.



================================================
File: CONTRIBUTING.md
================================================
# How to Contribute

We'd love to accept your patches and contributions to this project. There are
just a few small guidelines you need to follow.

## Contributor License Agreement

Contributions to this project must be accompanied by a Contributor License
Agreement (CLA). You (or your employer) retain the copyright to your
contribution; this simply gives us permission to use and redistribute your
contributions as part of the project. Head over to
<https://cla.developers.google.com/> to see your current agreements on file or
to sign a new one.

You generally only need to submit a CLA once, so if you've already submitted one
(even if it was for a different project), you probably don't need to do it
again.

## Code Reviews

All submissions, including submissions by project members, require review. We
use GitHub pull requests for this purpose. Consult
[GitHub Help](https://help.github.com/articles/about-pull-requests/) for more
information on using pull requests.

## Community Guidelines

This project follows
[Google's Open Source Community Guidelines](https://opensource.google/conduct/).



================================================
File: LICENSE
================================================

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.



================================================
File: codelabs/codelab-friendlychat-android/steps/index.lab.md
================================================
---
id: firebase-android
summary: In this codelab, you'll learn how to build an Android app with Firebase platform.
status: [published]
authors: arthurthompson
categories: Firebase,Android
tags: firebase-dev-summit-2016,firebase17,gdd17,io2016,io2017,io2018,io2019,kiosk,tag-firebase,web
feedback link: https://github.com/firebase/codelab-friendlychat-android/issues

---

# Firebase Android Codelab - Build Friendly Chat

[Codelab Feedback](https://github.com/firebase/codelab-friendlychat-android/issues)


## Overview
Duration: 05:00

<img src="img/screenshot.png" alt="screenshot"  width="300.00" />

Image: Working Friendly Chat app.

Welcome to the Friendly Chat codelab. In this codelab, you'll learn how to use the Firebase platform to create a chat app on Android.

#### What you'll learn

* How to use Firebase Authentication to allow users to sign in.
* How to sync data using the Firebase Realtime Database.
* How to store binary files in Cloud Storage for Firebase.
* How to use the Firebase Local Emulator Suite to develop an Android app with Firebase.

#### What you'll need

* [Android Studio](https://developer.android.com/studio) Flamingo (2022.2.1) or later.
* An [Android Emulator](https://developer.android.com/studio/run/emulator#install) with Android 5.0+.
* Node.js version 14 or higher (to use the Emulator Suite).
* Java 11 or higher. To install Java use these [instructions](https://java.com/en/download/help/download_options.xml); to check your version, run `java -version`.
* Familiarity with the Kotlin programming language.

## Get the sample code
Duration: 05:00

### Clone the repository

Clone the GitHub repository from the command line:

```console
$ git clone https://github.com/firebase/codelab-friendlychat-android
```

> aside positive
>
> The "friendlychat-android" repository contains two directories:
>
> *  <img src="img/android_studio_folder.png" alt="android_studio_folder"  width="20.00" />**build-android-start**—Starting code that you build upon in this codelab.
> *  <img src="img/android_studio_folder.png" alt="android_studio_folder"  width="20.00" />**build-android**—Completed code for the finished sample app.
>
> **Note**: If you want to run the finished app, you have to create a Firebase project in the Firebase console, along with a Firebase Android App that has your app's package name and SHA1. For more information, see [Step #10](https://codelabs.developers.google.com/codelabs/firebase-android/#9) of this codelab.


### Import into Android Studio

In Android Studio, select **File** > **Open**, then select the `build-android-start` directory ( <img src="img/android_studio_folder.png" alt="android_studio_folder"  width="20.00" />) from the directory where you downloaded the sample code.

You should now have the `build-android-start` project open in Android Studio. If you see a warning about a `google-services.json` file missing, don't worry. It will be added in a later step.


### Check dependencies

In this codelab all of the dependencies you will need have already been added for you, but it's important to understand how to add the Firebase SDK to your app:

**build.gradle**

```groovy
buildscript {
    // ...

    dependencies {
        classpath 'com.android.tools.build:gradle:7.2.2'

        // The google-services plugin is required to parse the google-services.json file
        classpath 'com.google.gms:google-services:4.3.13'
    }
}
```

**app/build.gradle**

```groovy
plugins {
    id 'com.android.application'
    id 'kotlin-android'
    id 'com.google.gms.google-services'
}

android {
    // ...
}

dependencies {
    // ...

    // Google Sign In SDK
    implementation 'com.google.android.gms:play-services-auth:20.2.0'

    // Firebase SDK
    implementation platform('com.google.firebase:firebase-bom:30.3.2')
    implementation 'com.google.firebase:firebase-database-ktx'
    implementation 'com.google.firebase:firebase-storage-ktx'
    implementation 'com.google.firebase:firebase-auth-ktx'

    // Firebase UI Library
    implementation 'com.firebaseui:firebase-ui-auth:8.0.1'
    implementation 'com.firebaseui:firebase-ui-database:8.0.1'
}
```

## Install the Firebase CLI
Duration: 05:00

In this codelab you'll use the [Firebase Emulator Suite](https://firebase.google.com/docs/emulator-suite) to locally emulate Firebase Auth, the Realtime Database and Cloud Storage. This provides a safe, fast, and no-cost local development environment to build your app.

### Install the Firebase CLI

First you will need to install the [Firebase CLI](https://firebase.google.com/docs/cli). If you are using macOS or Linux, you can run the following cURL command:

```console
curl -sL https://firebase.tools | bash
```

If you are using Windows, read the [installation instructions](https://firebase.google.com/docs/cli#install-cli-windows) to get a standalone binary or to install via `npm`.

Once you've installed the CLI, running `firebase --version` should report a version of `9.0.0` or higher:

```console
$ firebase --version
9.0.0
```

### Log In

Run `firebase login` to connect the CLI to your Google account. This will open a new browser window to complete the login process. Make sure to choose the same account you used when creating your Firebase project earlier.

## Connect to the Firebase Emulator Suite
Duration: 02:00

### Start the emulators

In your terminal, run the following command from the root of your local `codelab-friendlychat-android` directory:

```shell
firebase emulators:start --project=demo-friendlychat-android
```

You should see some logs like this. The port values were defined in the `firebase.json` file, which was included in the cloned sample code.

```shell
$ firebase emulators:start --project=demo-friendlychat-android
i  emulators: Starting emulators: auth, database, storage
i  emulators: Detected demo project ID "demo-friendlychat-android", emulated services will use a demo configuration and attempts to access non-emulated services for this project will fail.
i  database: Database Emulator logging to database-debug.log
i  ui: Emulator UI logging to ui-debug.log

┌─────────────────────────────────────────────────────────────┐
│ ✔  All emulators ready! It is now safe to connect your app. │
│ i  View Emulator UI at http://localhost:4000                │
└─────────────────────────────────────────────────────────────┘

┌────────────────┬────────────────┬────────────────────────────────┐
│ Emulator       │ Host:Port      │ View in Emulator UI            │
├────────────────┼────────────────┼────────────────────────────────┤
│ Authentication │ localhost:9099 │ http://localhost:4000/auth     │
├────────────────┼────────────────┼────────────────────────────────┤
│ Database       │ localhost:9000 │ http://localhost:4000/database │
├────────────────┼────────────────┼────────────────────────────────┤
│ Storage        │ localhost:9199 │ http://localhost:4000/storage  │
└────────────────┴────────────────┴────────────────────────────────┘
  Emulator Hub running at localhost:4400
  Other reserved ports: 4500

Issues? Report them at https://github.com/firebase/firebase-tools/issues and attach the *-debug.log files.
```

Navigate to [http://localhost:4000](http://localhost:4000) in your web
browser to view the Firebase Emulator Suite UI:

<img src="img/emulators-home.png" alt="Emulator Suite UI home" />

Leave the `emulators:start` command running for the rest of the codelab.

### Connect your app

In Android Studio, open `MainActivity.kt`, then add the following code inside the `onCreate` method:

```kotlin
// When running in debug mode, connect to the Firebase Emulator Suite.
// "10.0.2.2" is a special IP address which allows the Android Emulator
// to connect to "localhost" on the host computer. The port values (9xxx)
// must match the values defined in the firebase.json file.
if (BuildConfig.DEBUG) {
    Firebase.database.useEmulator("10.0.2.2", 9000)
    Firebase.auth.useEmulator("10.0.2.2", 9099)
    Firebase.storage.useEmulator("10.0.2.2", 9199)
}
```

## Run the starter app
Duration: 03:00

### Add google-services.json

In order for your Android app to connect to Firebase, you must add a `google-services.json` file inside the `app` folder of your Android project. For the purposes of this codelab, we've provided a mock JSON file which will allow you to connect to the Firebase Emulator Suite.

Copy the `mock-google-services.json` file into the `build-android-start/app` folder as `google-services.json`:

```shell
cp mock-google-services.json build-android-start/app/google-services.json
```

In the final step of this codelab, you'll learn how to create a real Firebase project and Firebase Android App so that you can replace this mock JSON file with your own configuration.

### Run the app

Now that you've imported the project into Android Studio and added a Firebase configuration JSON file, you're ready to run the app for the first time.

> aside negative
>
> Note: In order for your app to communicate with the Firebase Emulator Suite, it must be running on an Android Emulator, not a real Android device. This will allow the app to communicate with the Firebase Emulator Suite on `localhost`. Make sure that the Virtual Device definition selected is running Play Store services.

1. Start your Android Emulator.
2. In Android Studio, click **Run** ( <img src="img/execute.png" alt="execute"  width="20.00" />) in the toolbar.

The app should launch on your Android Emulator. At this point, you should see an empty message list, and sending and receiving messages will not work. In the next step of this codelab, you'll authenticate users so that they can use Friendly Chat.

## Enable Authentication
Duration: 05:00

This app will use Firebase Realtime Database to store all chat messages. Before we add data, though, we should make sure that the app is secure and that only authenticated users can post messages. In this step, we will enable Firebase Authentication and configure Realtime Database Security Rules.

### Add basic sign-in functionality

Next we'll add some basic Firebase Authentication code to the app to detect users and implement a sign-in screen.


#### Check for current user

First add the following instance variable to the `MainActivity.kt` class:

**MainActivity.kt**

```
// Firebase instance variables
private lateinit var auth: FirebaseAuth
```

Now let's modify `MainActivity` to send the user to the sign-in screen whenever they open the app and are unauthenticated.  Add the following to the `onCreate()` method **after** the `binding` is attached to the view:

**MainActivity.kt**

```
// Initialize Firebase Auth and check if the user is signed in
auth = Firebase.auth
if (auth.currentUser == null) {
    // Not signed in, launch the Sign In activity
    startActivity(Intent(this, SignInActivity::class.java))
    finish()
    return
}
```

We also want to check if the user is signed in during `onStart()`:

**MainActivity.kt**

```
public override fun onStart() {
    super.onStart()
    // Check if user is signed in.
    if (auth.currentUser == null) {
        // Not signed in, launch the Sign In activity
        startActivity(Intent(this, SignInActivity::class.java))
        finish()
        return
    }
}
```

Then implement the `getUserPhotoUrl()` and `getUserName()` methods to return the appropriate information about the currently authenticated Firebase user:

**MainActivity.kt**

```
private fun getPhotoUrl(): String? {
    val user = auth.currentUser
    return user?.photoUrl?.toString()
}

private fun getUserName(): String? {
    val user = auth.currentUser
    return if (user != null) {
        user.displayName
    } else ANONYMOUS
}
```

Then implement the `signOut()` method to handle the sign out button:

**MainActivity.kt**

```
private fun signOut() {
    AuthUI.getInstance().signOut()
    startActivity(Intent(this, SignInActivity::class.java))
    finish()
}
```

Now we have all of the logic in place to send the user to the sign-in screen when necessary. Next we need to implement the sign-in screen to properly authenticate users.

#### Implement the Sign-In screen

Open the file `SignInActivity.kt`.  Here a simple Sign-In button is used to initiate authentication. In this section, you will use FirebaseUI to implement the logic for sign in.

Add an Auth instance variable in the `SignInActivity` class under the `// Firebase instance variables` comment:

**SignInActivity.kt**

```
// Firebase instance variables
private lateinit var auth: FirebaseAuth
```

Then, edit the `onCreate()` method to initialize Firebase in the same way you did in `MainActivity`:

**SignInActivity.kt**

```
// Initialize FirebaseAuth
auth = Firebase.auth
```

Add an `ActivityResultLauncher` field to `SignInActivity`:

**SignInActivity.kt**

```kotlin
// ADD THIS
private val signIn: ActivityResultLauncher<Intent> =
        registerForActivityResult(FirebaseAuthUIActivityResultContract(), this::onSignInResult)

override fun onCreate(savedInstanceState: Bundle?) {
    // ...
}
```

Next, edit the `onStart()` method to kick off the FirebaseUI sign in flow:

**SignInActivity.kt**

```kotlin
public override fun onStart() {
    super.onStart()

    // If there is no signed in user, launch FirebaseUI
    // Otherwise head to MainActivity
    if (Firebase.auth.currentUser == null) {
        // Sign in with FirebaseUI, see docs for more details:
        // https://firebase.google.com/docs/auth/android/firebaseui
        val signInIntent = AuthUI.getInstance()
                .createSignInIntentBuilder()
                .setLogo(R.mipmap.ic_launcher)
                .setAvailableProviders(listOf(
                        AuthUI.IdpConfig.EmailBuilder().build(),
                        AuthUI.IdpConfig.GoogleBuilder().build(),
                ))
                .build()

        signIn.launch(signInIntent)
    } else {
        goToMainActivity()
    }
}
```

Next, implement the `onSignInResult` method to handle the sign in result. If the result of the signin was successful, continue to `MainActivity`:

**SignInActivity.kt**

```kotlin
private fun onSignInResult(result: FirebaseAuthUIAuthenticationResult) {
    if (result.resultCode == RESULT_OK) {
        Log.d(TAG, "Sign in successful!")
        goToMainActivity()
    } else {
        Toast.makeText(
                this,
                "There was an error signing in",
                Toast.LENGTH_LONG).show()

        val response = result.idpResponse
        if (response == null) {
            Log.w(TAG, "Sign in canceled")
        } else {
            Log.w(TAG, "Sign in error", response.error)
        }
    }
}
```

That's it! You've implemented authentication with FirebaseUI in just a few method calls and without needing to manage any server-side configuration.

#### Test your work

Run the app on your Android Emulator. You should be immediately sent to the sign-in screen. Tap the **Sign in with email** button, then create an account. If everything is implemented correctly, you should be sent to the messaging screen.

> aside negative
>
> Note: Google Sign-In will not work yet because you haven't registered your app with Firebase. You'll have a chance to do this at the end of the codelab.

After signing in, open the Firebase Emulator Suite UI in your browser, then click the **Authentication** tab to see this first signed-in user account.

<img src="img/emulators-auth-user.png" />

## Read messages
Duration: 05:00

In this step, we will add functionality to read and display messages stored in Realtime Database.

### Import sample messages

1. In the Firebase Emulator Suite UI, select the **Realtime Database** tab.
2. Drag and drop the `initial_messages.json` file from your local copy of the codelab repository into the data viewer.

<img src="img/import-data.gif" />

You should now have a few messages under the `messages` node of the database.

### Read data

#### Synchronize messages

In this section we add code that synchronizes newly added messages to the app UI by:

* Initializing the Firebase Realtime Database and adding a listener to handle changes made to the data.
* Updating the `RecyclerView` adapter so new messages will be shown.
* Adding the Database instance variables with your other Firebase instance variables in the `MainActivity` class:

#### MainActivity.kt

```
// Firebase instance variables
// ...
private lateinit var db: FirebaseDatabase
private lateinit var adapter: FriendlyMessageAdapter
```

Modify your MainActivity's `onCreate()` method under the comment `// Initialize Realtime Database and FirebaseRecyclerAdapter` with the code defined below. This code adds all existing messages from Realtime Database and then listens for new child entries under the `messages` path in your Firebase Realtime Database. It adds a new element to the UI for each message:

**MainActivity.kt**

```kt
// Initialize Realtime Database
db = Firebase.database
val messagesRef = db.reference.child(MESSAGES_CHILD)

// The FirebaseRecyclerAdapter class and options come from the FirebaseUI library
// See: https://github.com/firebase/FirebaseUI-Android
val options = FirebaseRecyclerOptions.Builder<FriendlyMessage>()
    .setQuery(messagesRef, FriendlyMessage::class.java)
    .build()
adapter = FriendlyMessageAdapter(options, getUserName())
binding.progressBar.visibility = ProgressBar.INVISIBLE
manager = LinearLayoutManager(this)
manager.stackFromEnd = true
binding.messageRecyclerView.layoutManager = manager
binding.messageRecyclerView.adapter = adapter

// Scroll down when a new message arrives
// See MyScrollToBottomObserver for details
adapter.registerAdapterDataObserver(
    MyScrollToBottomObserver(binding.messageRecyclerView, adapter, manager)
)
```

Next in the `FriendlyMessageAdapter.kt` class implement the `bind()` method within the inner class `MessageViewHolder()`:

**FriendlyMessageAdapter.kt**

```kt
inner class MessageViewHolder(private val binding: MessageBinding) : ViewHolder(binding.root) {
    fun bind(item: FriendlyMessage) {
        binding.messageTextView.text = item.text
        setTextColor(item.name, binding.messageTextView)

        binding.messengerTextView.text = if (item.name == null) ANONYMOUS else item.name
        if (item.photoUrl != null) {
            loadImageIntoView(binding.messengerImageView, item.photoUrl!!)
        } else {
            binding.messengerImageView.setImageResource(R.drawable.ic_account_circle_black_36dp)
        }
    }
    ...
}
```

We also need to display messages that are images, so also implement the `bind()` method within the inner class `ImageMessageViewHolder()`:

**FriendlyMessageAdapter.kt**

```
inner class ImageMessageViewHolder(private val binding: ImageMessageBinding) :
    ViewHolder(binding.root) {
    fun bind(item: FriendlyMessage) {
        loadImageIntoView(binding.messageImageView, item.imageUrl!!)

        binding.messengerTextView.text = if (item.name == null) ANONYMOUS else item.name
        if (item.photoUrl != null) {
            loadImageIntoView(binding.messengerImageView, item.photoUrl!!)
        } else {
            binding.messengerImageView.setImageResource(R.drawable.ic_account_circle_black_36dp)
        }
    }
}
```

Finally, back in `MainActivity`, start and stop listening for updates from Firebase Realtime Database.
Update the *`onPause()`* and *`onResume()`* methods in `MainActivity` as shown below:

**MainActivity.kt**

```kt
public override fun onPause() {
    adapter.stopListening()
    super.onPause()
}

public override fun onResume() {
    super.onResume()
    adapter.startListening()
}
```

### Test syncing messages

1. Click **Run** ( <img src="img/execute.png" alt="execute"  width="20.00" />).
2. In the Emulator Suite UI, return to the **Realtime Database** tab, then manually add a new message.
   Confirm that the message shows up in your Android app:

<img src="img/add-message.gif" />

Congratulations, you just added a realtime database to your app!


## Send Messages
Duration: 05:00

### Implement text message sending

In this section, you will add the ability for app users to send text messages. The code snippet below listens for click events on the send button, creates a new `FriendlyMessage` object with the contents of the message field, and pushes the message to the database.  The `push()` method adds an automatically generated ID to the pushed object's path.  These IDs are sequential which ensures that the new messages will be added to the end of the list.

Update the click listener of the send button in the `onCreate()` method in the `MainActivity` class.
This code is at the bottom of the `onCreate()` method already. Update the `onClick()` body to match the code below:

**MainActivity.kt**

```kt
// Disable the send button when there's no text in the input field
// See MyButtonObserver for details
binding.messageEditText.addTextChangedListener(MyButtonObserver(binding.sendButton))

// When the send button is clicked, send a text message
binding.sendButton.setOnClickListener {
    val friendlyMessage = FriendlyMessage(
        binding.messageEditText.text.toString(),
        getUserName(),
        getPhotoUrl(),
        null /* no image */
    )
    db.reference.child(MESSAGES_CHILD).push().setValue(friendlyMessage)
    binding.messageEditText.setText("")
}
```

### Implement image message sending

In this section, you will add the ability for app users to send image messages. Creating an image message is done with these steps:

* Select image
* Handle image selection
* Write temporary image message to the Realtime Database
* Begin to upload selected image
* Update image message URL to that of the uploaded image, once upload is complete

#### Select Image

To add images this codelab uses Cloud Storage for Firebase. Cloud Storage is a good place to store the binary data of your app.

##### Handle image selection and write temp message

Once the user has selected an image, the image selection `Intent` is launched. This is already implemented in the code at the end of the `onCreate()` method. When finished it calls the `MainActivity`'s `onImageSelected()` method. Using the code snippet below, you will write a message with a temporary image url to the database indicating the image is being uploaded.

**MainActivity.kt**

```kt
private fun onImageSelected(uri: Uri) {
    Log.d(TAG, "Uri: $uri")
    val user = auth.currentUser
    val tempMessage = FriendlyMessage(null, getUserName(), getPhotoUrl(), LOADING_IMAGE_URL)
    db.reference
            .child(MESSAGES_CHILD)
            .push()
            .setValue(
                    tempMessage,
                    DatabaseReference.CompletionListener { databaseError, databaseReference ->
                        if (databaseError != null) {
                            Log.w(
                                    TAG, "Unable to write message to database.",
                                    databaseError.toException()
                            )
                            return@CompletionListener
                        }

                        // Build a StorageReference and then upload the file
                        val key = databaseReference.key
                        val storageReference = Firebase.storage
                                .getReference(user!!.uid)
                                .child(key!!)
                                .child(uri.lastPathSegment!!)
                        putImageInStorage(storageReference, uri, key)
                    })
}
```

#### Upload image and update message

Add the method `putImageInStorage()` to `MainActivity`. It is called in `onImageSelected()` to initiate the upload of the selected image. Once the upload is complete you will update the message to use the appropriate image.

#### MainActivity.kt

```kt
private fun putImageInStorage(storageReference: StorageReference, uri: Uri, key: String?) {
    // First upload the image to Cloud Storage
    storageReference.putFile(uri)
        .addOnSuccessListener(
            this
        ) { taskSnapshot -> // After the image loads, get a public downloadUrl for the image
            // and add it to the message.
            taskSnapshot.metadata!!.reference!!.downloadUrl
                .addOnSuccessListener { uri ->
                    val friendlyMessage =
                        FriendlyMessage(null, getUserName(), getPhotoUrl(), uri.toString())
                    db.reference
                        .child(MESSAGES_CHILD)
                        .child(key!!)
                        .setValue(friendlyMessage)
                }
        }
        .addOnFailureListener(this) { e ->
            Log.w(
                TAG,
                "Image upload task was unsuccessful.",
                e
            )
        }
}
```

#### Test sending messages

1. In Android Studio, click the <img src="img/execute.png" alt="execute"  width="20.00" />**Run** button.
2. In your Android Emulator, enter a message, then tap the send button. The new message should be visible in the app UI and in the Firebase Emulator Suite UI.
3. In the Android Emulator, tap the "+" image to select an image from your device. The new message should be visible first with a placeholder image, and then with the selected image once the image upload is complete. The new message should also be visible in the Emulator Suite UI, specifically as an object in the Realtime Database tab and as a blob in the Storage tab.


## Congratulations!
Duration: 01:00

You just built a real-time chat application using Firebase!

#### What you learned

* Firebase Authentication
* Firebase Realtime Database
* Cloud Storage for Firebase

Next, try using what you learned in this codelab to add Firebase to your own Android app! To learn more about Firebase, visit [firebase.google.com](https://firebase.google.com).

If you want to learn how to set up a _real_ Firebase project and use _real_ Firebase resources (instead of a demo project and _only_ emulated resources), continue to the next step.

> Note: Even after you set up a real Firebase project and _especially_ when you get started building a real app, we recommend using the Firebase Local Emulator Suite for development and testing.

## Optional: Create and set up a Firebase project
Duration: 06:00

In this step, you'll create a real Firebase project and a Firebase Android App to use with this codelab. You'll also add your app-specific Firebase configuration to your app. And finally, you'll set up real Firebase resources to use with your app.

### Create a Firebase project

1. In your browser, go to the  [Firebase console](https://console.firebase.google.com).
2. Select **Add project**.
3. Select or enter a project name. You can use any name you want.
4. You do not need Google Analytics for this codelab, so you can skip enabling it for your project.
5. Click **Create Project**. When your project is ready, click **Continue**.

### Add Firebase to your Android project

Before you begin this step, get the SHA1 hash of your app. Run the following command from your local `build-android-start` directory to determine the SHA1 of your debug key:

```console
./gradlew signingReport

Store: /Users/<username>/.android/debug.keystore
Alias: AndroidDebugKey
MD5: A5:88:41:04:8F:06:59:6A:AE:33:76:87:AA:AD:19:23
SHA1: A7:89:F5:06:A8:07:A1:22:EC:90:6A:A6:EA:C3:D4:8B:3A:30:AB:18
SHA-256: 05:A2:2A:35:EE:F2:51:23:72:4D:72:67:A5:6A:8A:58:22:2C:00:A6:AB:F6:45:D5:A1:82:D8:90:A4:69:C8:FE
Valid until: Wednesday, August 10, 2044
```

You should see some output like the above. The important line is the `SHA1` hash. If you're unable to find your SHA1 hash, see [this page](https://developers.google.com/android/guides/client-auth) for more information.

Go back to the Firebase console, and follow these steps to register your Android project with your Firebase project:

1. From the overview screen of your new project, click the Android icon to launch the setup workflow:
   <img src="img/add-android-app.png" alt="add android app" />
1. On the next screen, enter `com.google.firebase.codelab.friendlychat` as the package name for your app.
1. Click **Register App**, then click **Download google-services.json** to download your Firebase configuration file.
1. Copy the `google-services.json` file into the *`app`* directory of your Android project.
1. **Skip** the next steps shown in the console's setup workflow (they've already been done for you in the `build-android-start` project).
1. Make sure that all dependencies are available to your app by syncing your project with Gradle files. From the Android Studio toolbar, select **File** > **Sync Project with Gradle Files**. You may also need to run **Build/Clean Project** and **Build/Rebuild Project** for the config changes to take place.

### Configure Firebase Authentication

Before your app can access the Firebase Authentication APIs on behalf of your users, you need to enable Firebase Authentication and the sign-in providers you want to use in your app.

1. In the [Firebase console](http://console.firebase.google.com), select **Authentication** from the left-side navigation panel.
1. Select the **Sign-in method** tab.
1. Click **Email/Password**, then toggle the switch to enabled (blue).
1. Click **Google**, then toggle the switch to enabled (blue) and set a project support email.

If you get errors later in this codelab with the message "CONFIGURATION_NOT_FOUND", come back to this step and double check your work.

### Configure Realtime Database

The app in this codelab stores chat messages in Firebase Realtime Database. In this section, we'll create a database and configure its security via a JSON configuration language called Firebase Security Rules.

1. In the [Firebase console](http://console.firebase.google.com), select **Realtime Database** from the left-side navigation panel.
1. Click **Create Database** to create a new Realtime Database instance. When prompted, select the `us-central1` region, then click **Next**.
1. When prompted about security rules, choose **locked mode**, then click **Enable**.
1. Once the database instance has been created, select the **Rules** tab, then update the rules configuration with the following:

        {
          "rules": {
            "messages": {
              ".read": "auth.uid != null",
              ".write": "auth.uid != null"
            }
          }
        }

For more information on how Security Rules work (including documentation on the "auth" variable), see the [Realtime Database security documentation](https://firebase.google.com/docs/database/security/quickstart).

### Configure Cloud Storage for Firebase

1. In the [Firebase console](http://console.firebase.google.com), select **Storage** from the left-side navigation panel.
1. Click **Get Started** to enable Cloud Storage for your project.
1. Follow the steps in the dialog to set up your bucket, using the suggested defaults.

### Connect to Firebase resources

In an earlier step of this codelab, you added the following to `MainActivity.kt`. This conditional block connected your Android project to the Firebase Emulator Suite.

```kt
// REMOVE OR DISABLE THIS
if (BuildConfig.DEBUG) {
    Firebase.database.useEmulator("10.0.2.2", 9000)
    Firebase.auth.useEmulator("10.0.2.2", 9099)
    Firebase.storage.useEmulator("10.0.2.2", 9199)
}
```

If you want to connect your app to your new **_real_** Firebase project and its **_real_** Firebase resources, you can either remove this block or run your app in release mode so that `BuildConfig.DEBUG` is `false`.


================================================
File: codelabs/codelab-friendlychat-android/steps/.gitignore
================================================
firebase-android
!firebase-android/.firebaserc
!firebase-android/firebase.json




================================================
File: codelabs/codelab-friendlychat-web/steps/README.md
================================================
# Friendlychat

This project was generated with [Angular CLI](https://github.com/angular/angular-cli) version 16.0.4.

## Development server

Run `ng serve` for a dev server. Navigate to `http://localhost:4200/`. The application will automatically reload if you change any of the source files.

## Code scaffolding

Run `ng generate component component-name` to generate a new component. You can also use `ng generate directive|pipe|service|class|guard|interface|enum|module`.

## Build

Run `ng build` to build the project. The build artifacts will be stored in the `dist/` directory.

## Running unit tests

Run `ng test` to execute the unit tests via [Karma](https://karma-runner.github.io).

## Running end-to-end tests

Run `ng e2e` to execute the end-to-end tests via a platform of your choice. To use this command, you need to first add a package that implements end-to-end testing capabilities.

## Further help

To get more help on the Angular CLI use `ng help` or go check out the [Angular CLI Overview and Command Reference](https://angular.io/cli) page.



================================================
File: codelabs/codelab-friendlychat-web/steps/angular.json
================================================
{
  "$schema": "./node_modules/@angular/cli/lib/config/schema.json",
  "version": 1,
  "cli": {
    "packageManager": "npm",
    "analytics": false
  },
  "newProjectRoot": "projects",
  "projects": {
    "friendlychat": {
      "projectType": "application",
      "schematics": {},
      "root": "",
      "sourceRoot": "src",
      "prefix": "app",
      "architect": {
        "build": {
          "builder": "@angular-devkit/build-angular:application",
          "options": {
            "outputPath": "dist/friendlychat",
            "index": "src/index.html",
            "browser": "src/main.ts",
            "polyfills": ["zone.js"],
            "tsConfig": "tsconfig.app.json",
            "assets": ["src/favicon.ico", "src/assets"],
            "styles": ["src/styles.css"],
            "scripts": []
          },
          "configurations": {
            "production": {
              "budgets": [
                {
                  "type": "initial",
                  "maximumWarning": "500kb",
                  "maximumError": "1mb"
                },
                {
                  "type": "anyComponentStyle",
                  "maximumWarning": "2kb",
                  "maximumError": "4kb"
                }
              ],
              "outputHashing": "all"
            },
            "development": {
              "optimization": false,
              "extractLicenses": false,
              "sourceMap": true,
              "namedChunks": true
            }
          },
          "defaultConfiguration": "production"
        },
        "serve": {
          "builder": "@angular-devkit/build-angular:dev-server",
          "configurations": {
            "production": {
              "buildTarget": "friendlychat:build:production"
            },
            "development": {
              "buildTarget": "friendlychat:build:development"
            }
          },
          "defaultConfiguration": "development"
        },
        "extract-i18n": {
          "builder": "@angular-devkit/build-angular:extract-i18n",
          "options": {
            "buildTarget": "friendlychat:build"
          }
        },
        "test": {
          "builder": "@angular-devkit/build-angular:karma",
          "options": {
            "polyfills": ["zone.js", "zone.js/testing"],
            "tsConfig": "tsconfig.spec.json",
            "assets": ["src/favicon.ico", "src/assets"],
            "styles": ["src/styles.css"],
            "scripts": []
          }
        },
        "deploy": {
          "builder": "@angular/fire:deploy",
          "options": {
            "version": 2,
            "browserTarget": "friendlychat:build:production"
          }
        }
      }
    }
  }
}



================================================
File: codelabs/codelab-friendlychat-web/steps/firebase.json
================================================
{
  "firestore": {
    "rules": "firestore.rules",
    "indexes": "firestore.indexes.json"
  },
  "hosting": [
    {
      "source": ".",
      "ignore": [
        "firebase.json",
        "**/.*",
        "**/node_modules/**"
      ],
      "frameworksBackend": {
        "region": "us-central1"
      }
    },
    {
      "target": "friendlychat",
      "source": ".",
      "frameworksBackend": {}
    }
  ],
  "storage": {
    "rules": "storage.rules"
  },
  "emulators": {
    "auth": {
      "port": 9099
    },
    "functions": {
      "port": 5001
    },
    "firestore": {
      "port": 8080
    },
    "hosting": {
      "port": 5000
    },
    "storage": {
      "port": 9199
    },
    "ui": {
      "enabled": true
    },
    "singleProjectMode": true
  },
  "functions": [
    {
      "source": "functions",
      "codebase": "default",
      "ignore": [
        "node_modules",
        ".git",
        "firebase-debug.log",
        "firebase-debug.*.log"
      ],
      "predeploy": [
        "npm --prefix \"$RESOURCE_DIR\" run lint"
      ]
    }
  ]
}



================================================
File: codelabs/codelab-friendlychat-web/steps/firestore.indexes.json
================================================
{
  "indexes": [],
  "fieldOverrides": []
}



================================================
File: codelabs/codelab-friendlychat-web/steps/firestore.rules
================================================
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    match /{document=**} {
      allow read, write;
    }
  }
}



================================================
File: codelabs/codelab-friendlychat-web/steps/package.json
================================================
{
  "name": "friendlychat",
  "version": "0.0.0",
  "scripts": {
    "ng": "ng",
    "start": "ng serve",
    "build": "ng build",
    "watch": "ng build --watch --configuration development",
    "test": "ng test"
  },
  "private": true,
  "dependencies": {
    "@angular/animations": "^17.2.4",
    "@angular/common": "^17.2.4",
    "@angular/compiler": "^17.2.4",
    "@angular/core": "^17.2.4",
    "@angular/fire": "^17.0.1",
    "@angular/forms": "^17.2.4",
    "@angular/platform-browser": "^17.2.4",
    "@angular/platform-browser-dynamic": "^17.2.4",
    "@angular/router": "^17.2.4",
    "rxjs": "~7.8.0",
    "tslib": "^2.3.0",
    "zone.js": "~0.14.4"
  },
  "devDependencies": {
    "@angular-devkit/build-angular": "^17.2.3",
    "@angular/cli": "~17.2.3",
    "@angular/compiler-cli": "^17.2.4",
    "@types/jasmine": "~4.3.0",
    "autoprefixer": "^10.4.14",
    "jasmine-core": "~4.6.0",
    "karma": "~6.4.0",
    "karma-chrome-launcher": "~3.2.0",
    "karma-coverage": "~2.2.0",
    "karma-jasmine": "~5.1.0",
    "karma-jasmine-html-reporter": "~2.0.0",
    "postcss": "^8.4.24",
    "tailwindcss": "^3.3.2",
    "typescript": "~5.3.3"
  }
}



================================================
File: codelabs/codelab-friendlychat-web/steps/storage.rules
================================================
rules_version = '2';

// Craft rules based on data in your Firestore database
// allow write: if firestore.get(
//    /databases/(default)/documents/users/$(request.auth.uid)).data.isAdmin;
service firebase.storage {
  match /b/{bucket}/o {
    match /{allPaths=**} {
      allow read, write: if false;
    }
  }
}



================================================
File: codelabs/codelab-friendlychat-web/steps/tailwind.config.js
================================================
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ["./src/app/*.{html,ts}", "./src/app/***/**/*.{html,ts}", "./src/app/**/*.{html,ts}", "./src/*.{html,ts}"],
  theme: {
    extend: {
      colors: {
        'navy': {
          10: '#F6F7F9',
          20: '#E5EAF0',
          30: '#D4DCE7',
          40: '#C3CFDD',
          50: '#B2C1D4',
          100: '#8EA1B9',
          200: '#6B829D',
          300: '#476282',
          400: '#385574',
          500: '#2A4865',
          600: '#1B3A57',
          700: '#0C2D48',
          800: '#051E34',
          900: '#031525',
        },
        'amber': {
          50: '#FFF8E1',
          100: '#FFECB3',
          200: '#FFE082',
          300: '#FFD54F',
          400: '#FFCA28',
          500: '#FFC107',
          600: '#FFB300',
          700: '#FFA000',
          800: '#FF8F00',
          900: '#FF6F00',
          A100: '#FFE57F',
          A200: '#FFD740',
          A400: '#FFC400',
          A700: '#FFAB00',
        }
      },
    },
  },
  plugins: [],
}




================================================
File: codelabs/codelab-friendlychat-web/steps/test.md
================================================
---
id: firebase-web
summary: In this codelab, you'll learn how to use the Firebase platform on the web by building a chat app.
status: [reviewed]
authors: Nicolas Garnier, Jeff Huleatt, Cynthia Wang
categories: Cloud,Web,Firebase
keywords: product: Cloud,Web,Firebase
tags: chromeos,firebase-dev-summit-2016,firebase17,gdd17,io2016,io2017,io2018,io2019,jsconfeu,kiosk,qwiklabs,sxsw,tag-firebase,tag-web,typtwd17,web

---

# AngularFire web codelab




## Overview
Duration: 01:00


In this codelab, you'll learn how to use [AngularFire](https://firebaseopensource.com/projects/firebase/angularfire/) to create web applications by implementing and deploying a chat client using Firebase products and services.

<img src="img/angularfire-2.png" alt="angularfire-2.png" title="Final App"  width="537.95" />

#### What you'll learn

* Build a web app using Angular and Firebase.
* Sync data using Cloud Firestore and Cloud Storage for Firebase.
* Authenticate your users using Firebase Authentication.
* Deploy your web app on Firebase Hosting.
* Send notifications with Firebase Cloud Messaging.
* Collect your web app's performance data.

#### What you'll need

* The IDE/text editor of your choice, such as  [WebStorm](https://www.jetbrains.com/webstorm),  [Atom](https://atom.io/),  [Sublime](https://www.sublimetext.com/), or  [VS Code](https://code.visualstudio.com/)
* The package manager  [npm](https://www.npmjs.com/), which typically comes with  [Node.js](https://nodejs.org/en/)
* A terminal/console
* A browser of your choice, such as Chrome
* The codelab's sample code (See the next step of the codelab for how to get the code.)


## Get the sample code
Duration: 02:00


Clone the codelab's [GitHub repository](https://github.com/firebase/codelab-friendlychat-web) from the command line:

```
git clone https://github.com/firebase/codelab-friendlychat-web
```

Alternatively, if you do not have git installed, you can  [download the repository as a ZIP file](https://github.com/firebase/codelab-friendlychat-web/archive/refs/heads/main.zip).

> aside positive
>
> The `friendlychat-web` repository contains sample projects for multiple platforms.
>
> This codelab only uses these two repositories:
>
> * 📁 **angularfire-start**: The starting code that you'll build upon during this codelab.
> * 📁 **angularfire**: The complete code for the finished sample app.
>
> **Note**: You can run the finished app locally using Emulator suite, however, if you would like to deploy and serve it, you'll still have to create a Firebase project in the Firebase console (see the section **Create and set up a Firebase project** in this codelab for instructions).

#### Import the starter app

Using your IDE, open or import the 📁 `angularfire-start` directory from the cloned repository. This 📁 `angularfire-start` directory contains the starting code for the codelab, which will be a fully functional chat web app.

> aside positive
>
> **Important**: After you have cloned or downloaded the code from the respository, access the 📁 `angularfire-start` directory in your console, and run `npm install` to install dependencies.

## Create and set up a Firebase project
Duration: 05:00


#### **Create a Firebase project**

1. Sign in to [Firebase](https://console.firebase.google.com/).
2. In the Firebase console, click **Add Project**, and then name your Firebase project **FriendlyChat**. Remember the project ID for your Firebase project.
3. Uncheck **Enable Google Analytics for this project**
4. Click **Create Project**.

> aside positive
>
> **Important**: Your Firebase project will be named **FriendlyChat**, but Firebase will automatically assign it a unique Project ID in the form **friendlychat-1234**. This unique identifier is how your project is actually identified (including in the CLI), whereas *FriendlyChat* is simply a display name.

The application that we're going to build uses Firebase products that are available for web apps:

* **Firebase Authentication** to easily allow your users to sign into your app.
* **Cloud Firestore** to save structured data on the cloud and get instant notification when data changes.
* **Cloud Storage for Firebase** to save files in the cloud.
* **Firebase Hosting** to host and serve your assets.
* **Firebase Cloud Messaging** to send push notifications and display browser popup notifications.
* **Firebase Performance Monitoring** to collect user performance data for your app.

Some of these products need special configuration or need to be enabled using the Firebase console.

#### Add a Firebase web app to the project

1. Click the web icon  <img src="img/58d6543a156e56f9.png" alt="58d6543a156e56f9.png"  width="41.00" />to create a new Firebase web app.
2. Register the app with the nickname **Friendly Chat**, then check the box next to **Also set up Firebase Hosting for this app**. Click **Register app**.
3. On the next step, you'll see a configuration object. Copy just the JS object (not the surrounding HTML) into [firebase-config.js](https://github.com/firebase/friendlychat/blob/master/web/src/firebase-config.js)

<img src="img/register-web-app.png" alt="Register web app screenshot"  width="624.00" />

#### Enable Google **sign-in for Firebase Authentication**

To allow users to sign in to the web app with their Google accounts, we'll use the **Google** sign-in method.

You'll need to enable **Google** sign-in:

1. In the Firebase console, locate the **Build** section in the left panel.
2. Click **Authentication**, then click the **Sign-in method** tab (or  [click here](https://console.firebase.google.com/project/_/authentication/providers) to go directly there).
3. Enable the **Google** sign-in provider, then click **Save**.
4. Set the public-facing name of your app to **Friendly Chat** and choose a **Project support email** from the dropdown menu.
5. Configure your OAuth consent screen in the  [Google Cloud Console](https://console.developers.google.com/apis/credentials/consent) and add a logo:

<img src="img/d89fb3873b5d36ae.png" alt="d89fb3873b5d36ae.png"  width="624.00" />

#### **Enable Cloud Firestore**

The web app uses  [Cloud Firestore](https://firebase.google.com/docs/firestore/) to save chat messages and receive new chat messages.

You'll need to enable Cloud Firestore:

1. In the Firebase console's **Build** section, click **Firestore Database**.
2. Click **Create database** in the Cloud Firestore pane.

<img src="img/729991a081e7cd5.png" alt="729991a081e7cd5.png"  width="533.00" />

> aside negative
>
> **Please be careful** to enable Cloud Firestore and **NOT** the Realtime Database for this codelab. Both options are on the same page, but you need to enable Cloud Firestore, which is in the top section of the page.

3. Select the **Start in test mode** option, then click **Next** after reading the disclaimer about the security rules.

Test mode ensures that we can freely write to the database during development. We'll make our database more secure later on in this codelab.

<img src="img/77e4986cbeaf9dee.png" alt="77e4986cbeaf9dee.png"  width="621.00" />

4. Set the location where your Cloud Firestore data is stored. You can leave this as the default or choose a region close to you. Click **Done** to provision Firestore.

<img src="img/9f2bb0d4e7ca49c7.png" alt="9f2bb0d4e7ca49c7.png"  width="624.00" />

#### **Enable Cloud Storage**

The web app uses Cloud Storage for Firebase to store, upload, and share pictures.

You'll need to enable Cloud Storage:

1. In the Firebase console's **Build** section, click **Storage**.
2. If there's no **Get Started** button, it means that Cloud storage is already
enabled, and you don't need to follow the steps below.
2. Click **Get Started**.
3. Read the disclaimer about security rules for your Firebase project, then click **Next**.

With the default security rules, any authenticated user can write anything to Cloud Storage. We'll make our storage more secure later in this codelab.

<img src="img/62f1afdcd1260127.png" alt="62f1afdcd1260127.png"  width="605.00" />

4. The Cloud Storage location is preselected with the same region you chose for your Cloud Firestore database. Click **Done** to complete the setup.

<img src="img/1d7f49ebaddb32fc.png" alt="1d7f49ebaddb32fc.png"  width="606.00" />


## Install the Firebase command-line interface
Duration: 02:00


The Firebase command-line interface (CLI) allows you to use Firebase Hosting to serve your web app locally, as well as to deploy your web app to your Firebase project.

> aside positive
>
> **Note**: To install the CLI, you need to install  [npm](https://www.npmjs.com/) which typically comes with  [Node.js](https://nodejs.org/en/).

1. Install the CLI by running the following npm command:

```
npm -g install firebase-tools
```

> aside negative
>
> Doesn't work? You may need to  [change npm permissions.](https://docs.npmjs.com/getting-started/fixing-npm-permissions)

2. Verify that the CLI has been installed correctly by running the following command:

```
firebase --version
```

Make sure that the version of the Firebase CLI is v4.1.0 or later.

3. Authorize the Firebase CLI by running the following command:

```
firebase login
```

We've set up the web app template to pull your app's configuration for Firebase Hosting from your app's local directory (the repository that you cloned earlier in the codelab). But to pull the configuration, we need to associate your app with your Firebase project.

4. Make sure that your command line is accessing your app's local `angularfire-start` directory.

5. Associate your app with your Firebase project by running the following command:

```
firebase use --add
```

6. When prompted, select your **Project ID**, then give your Firebase project an alias.

An alias is useful if you have multiple environments (production, staging, etc). However, for this codelab, let's just use the alias of `default`.

7. Follow the remaining instructions on your command line.

## Install AngularFire
Duration: 05:00

Before running the project, make sure you have the Angular CLI and AngularFire set up.

1. In a console, run the following command:
```console
npm install -g @angular/cli
```
2. Then, in a console from the `angularfire-start` directory, run the following Angular CLI command:

```console
ng add @angular/fire
```

This will install all the necessary dependencies for your project.

3. When prompted, select the features that were set up in the Firebase Console (`ng deploy -- hosting`, `Authentication`, `Firestore`, `Cloud Functions (callable)`, `Cloud Messaging`, `Cloud Storage`), and follow the prompts on the console.

## Run the starter app locally
Duration: 01:00


Now that you have imported and configured your project, you are ready to run the web app for the first time.

1. In a console from the `angularfire-start` directory, run the following Firebase CLI command:

```
firebase emulators:start
```

2. Your command line should display the following response:

```
✔  hosting: Local server: http://localhost:5000
```

We're using the  [Firebase Hosting](https://firebase.google.com/docs/hosting/) emulator to serve our app locally. The web app should now be available from  [http://localhost:5000](http://localhost:5000). All the files that are located under the `src` subdirectory are served.

3. Using your browser, open your app at  [http://localhost:5000](http://localhost:5000).

You should see your FriendlyChat app's UI, which is not (yet!) functioning:

<img src="img/4c23f9475228cef4.png" alt="4c23f9475228cef4.png"  width="438.40" />

The app cannot do anything right now, but with your help it will soon! We've only laid out the UI for you so far.

Let's now build a realtime chat!


## Import and configure Firebase
Duration: 05:00

#### **Configure Firebase**

You'll need to configure the Firebase SDK to tell it which Firebase project that we're using. 

1. Go to your [Project settings in the Firebase console](https://console.firebase.google.com/project/_/settings/general/)
2. In the "Your apps" card, select the nickname of the app for which you need a config object.
3. Select "Config" from the Firebase SDK snippet pane.

You will find that a environment file `/angularfire-start/src/environments/environment.ts` was generated for you.

4. Copy the config object snippet, then add it to `angularfire-start/src/firebase-config.js`.

####  [environment.ts](https://github.com/firebase/friendlychat/blob/master/angularfire-start/src/environments/environment.ts)

```
export const environment = {
  firebase: {
    apiKey: "API_KEY",
    authDomain: "PROJECT_ID.firebaseapp.com",
    databaseURL: "https://PROJECT_ID.firebaseio.com",
    projectId: "PROJECT_ID",
    storageBucket: "PROJECT_ID.appspot.com",
    messagingSenderId: "SENDER_ID",
    appId: "APP_ID",
    measurementId: "G-MEASUREMENT_ID",
  },
};
```

> aside positive
>
> The above code should contain your app-specific Firebase config object, not our placeholder values!


#### **Import AngularFire**

You will find that featues you've selected in the console were automatically routed in the `/angularfire-start/src/app/app.module.ts` file. This allows your app to use Firebase features and functionalities. However, to develop in a local environment, you need to connect them to use the Emulator suite.

1. In `/angularfire-start/src/app/app.module.ts`, find the `imports` section, and modify the provide functions to connect to Emulator suite in non-production environments.

```
...

import { provideAuth,getAuth, connectAuthEmulator } from '@angular/fire/auth';
import { provideFirestore,getFirestore, connectFirestoreEmulator } from '@angular/fire/firestore';
import { provideFunctions,getFunctions, connectFunctionsEmulator } from '@angular/fire/functions';
import { provideMessaging,getMessaging } from '@angular/fire/messaging';
import { provideStorage,getStorage, connectStorageEmulator } from '@angular/fire/storage';

...

provideFirebaseApp(() => initializeApp(environment.firebase)),
provideAuth(() => {
    const auth = getAuth();
    if (location.hostname === 'localhost') {
        connectAuthEmulator(auth, 'http://127.0.0.1:9099', { disableWarnings: true });
    }
    return auth;
}),
provideFirestore(() => {
    const firestore = getFirestore();
    if (location.hostname === 'localhost') {
        connectFirestoreEmulator(firestore, '127.0.0.1', 8080);
    }
    return firestore;
}),
provideFunctions(() => {
    const functions = getFunctions();
    if (location.hostname === 'localhost') {
        connectFunctionsEmulator(functions, '127.0.0.1', 5001);
    }
    return functions;
}),
provideStorage(() => {
    const storage = getStorage();
    if (location.hostname === 'localhost') {
        connectStorageEmulator(storage, '127.0.0.1', 5001);
    }
    return storage;
}),
provideMessaging(() => {
    return getMessaging();
}),
```
####  [app.module.ts](https://github.com/firebase/friendlychat/blob/master/angularfire-start/src/app/app.module.ts)


During this codelab, we're going to use Firebase Authentication, Cloud Firestore, Cloud Storage, Cloud Messaging, and Performance Monitoring, so we're importing all of their libraries. In your future apps, make sure that you're only importing the parts of Firebase that you need, to shorten the load time of your app.


## Set up user sign-in
Duration: 10:00


AngularFire should now be ready to use since it's imported and initialized in `app.module.ts`. We're now going to implement user sign-in using  [Firebase Authentication](https://firebase.google.com/docs/auth/web/start).

#### **Authenticate your users with Google Sign-In**

In the app, when a user clicks the **Sign in with Google** button, the `login` function is triggered. (We already set that up for you!) For this codelab, we want to authorize Firebase to use Google as the identity provider. We'll use a popup, but  [several other methods](https://firebase.google.com/docs/auth/web/google-signin) are available from Firebase.

1. In the `angularfire-start` directory, in the subdirectory `/src/app/services/`, open `chat.service.ts`.
2. Find the function `login`.
3. Replace the entire function with the following code.

####  [chat.service.ts](https://github.com/firebase/friendlychat/blob/master/angularfire/src/app/services/chat.service.ts)

```
// Signs-in Friendly Chat.
login() {
    signInWithPopup(this.auth, this.provider).then((result) => {
        const credential = GoogleAuthProvider.credentialFromResult(result);
        this.router.navigate(['/', 'chat']);
        return credential;
    })
}
```

The `logout` function is triggered when the user clicks the **Log out** button.

1. Go back to the file `src/app/services/chat.service.ts`.
2. Find the function `logout`.
3. Replace the entire function with the following code.

####  [chat.service.ts](https://github.com/firebase/friendlychat/blob/master/angularfire/src/app/services/chat.service.ts)

```
// Logout of Friendly Chat.
logout() {
    signOut(this.auth).then(() => {
        this.router.navigate(['/', 'login'])
        console.log('signed out');
    }).catch((error) => {
        console.log('sign out error: ' + error);
    })
}
```

#### **Track the authentication state**

To update our UI accordingly, we need a way to check if the user is logged in or logged out. With Firebase Authentication, you can register retrieve observable on the user state that will be triggered each time the authentication state changes.

1. Go back to the file `src/app/services/chat.service.ts`.
2. Find the variable assignment `user$`.
3. Replace the entire assignment with the following code.

####  [chat.service.ts](https://github.com/firebase/friendlychat/blob/master/angularfire/src/app/services/chat.service.ts)

```
// Observable user
user$ = user(this.auth);
```

The code above calls the AngularFire function `user` which returns an observable user. It will trigger each time the authentication state changes (when the user signs in or signs out). It's at this point that we'll update the UI to redirect, display the user in the header nav, and so on. All of these UI parts have already been implemented.


#### Test logging into the app

1. If your app is still being served, refresh your app in the browser. Otherwise, run `firebase emulators:start` on the command line to start serving the app from  [http://localhost:5000](http://localhost:5000), and then open it in your browser.
2. Log in to the app using the sign-in button and your Google account. If you see an error message stating `auth/operation-not-allowed`, check to make sure that you enabled Google Sign-in as an authentication provider in the Firebase console.
3. After logging in, your profile picture and user name should be displayed:
<img src="img/angularfire-3.png" alt="angularfire-3.png"  width="312.00" />


## Write messages to Cloud Firestore
Duration: 05:00


In this section, we'll write some data to Cloud Firestore so that we can populate the app's UI. This can be done manually with the  [Firebase console](https://console.firebase.google.com), but we'll do it in the app itself to demonstrate a basic Cloud Firestore write.

#### **Data model**

Cloud Firestore data is split into collections, documents, fields, and subcollections. We will store each message of the chat as a document in a top-level collection called `messages`.

<img src="img/688d7bc5fb662b57.png" alt="688d7bc5fb662b57.png"  width="193.10" />

> aside positive
> 
> **Tip**: To learn more about the Cloud Firestore data model, read about documents and collections in  [the documentation](https://firebase.google.com/docs/firestore/data-model).

#### **Add messages to Cloud Firestore**

To store the chat messages that are written by users, we'll use  [Cloud Firestore](https://firebase.google.com/docs/firestore/).

In this section, you'll add the functionality for users to write new messages to your database. A user clicking the **SEND** button will trigger the code snippet below. It adds a message object with the contents of the message fields to your Cloud Firestore instance in the `messages` collection. The `add()` method adds a new document with an automatically generated ID to the collection.

1. Go back to the file `src/app/services/chat.service.ts`.
2. Find the function `addMessage`.
3. Replace the entire function with the following code.

####  [chat.service.ts](https://github.com/firebase/friendlychat/blob/master/angularfire/src/app/services/chat.service.ts)

```
// Adds a text or image message to Cloud Firestore.
addMessage = async(textMessage: string | null, imageUrl: string | null): Promise<void | DocumentReference<DocumentData>> => {
    let data: any;
    try {
      this.user$.subscribe(async (user) => 
      { 
        if(textMessage && textMessage.length > 0) {
          data =  await addDoc(collection(this.firestore, 'messages'), {
            name: user?.displayName,
            text: textMessage,
            profilePicUrl: user?.photoURL,
            timestamp: serverTimestamp(),
            uid: user?.uid
          })}
          else if (imageUrl && imageUrl.length > 0) {
            data =  await addDoc(collection(this.firestore, 'messages'), {
              name: user?.displayName,
              imageUrl: imageUrl,
              profilePicUrl: user?.photoURL,
              timestamp: serverTimestamp(),
              uid: user?.uid
            });
          }
          return data;
        }
      );
    }
    catch(error) {
      console.error('Error writing new message to Firebase Database', error);
      return;
    }
}
```

#### **Test sending messages**

1. If your app is still being served, refresh your app in the browser. Otherwise, run `firebase emulators:start` on the command line to start serving the app from  [http://localhost:5000](http://localhost:5000), and then open it in your browser.
2. After logging in, enter a message such as "Hey there!", and then click **SEND**. This will write the message into Cloud Firestore. However, *you won't yet see the data in your actual web app* because we still need to implement *retrieving* the data (the next section of the codelab).
3. You can see the newly added message in your Firebase Console. Open your Emulator suite UI. Under the **Build** section click **Firestore Database** (or click  [here](http://localhost:4000/firestore/data) and you should see the **messages** collection with your newly added message:

<img src="img/6812efe7da395692.png" alt="6812efe7da395692.png"  width="624.00" />


## Read messages
Duration: 10:00


#### Synchronize **messages**

To read messages in the app, you'll need to add an observable that will trigger when data changes and then create a UI element that shows new messages.

We'll add code that listens for newly added messages from the app. In this code, you'll retrieve the snapshot of the `messages` collection. You'll only display the last 12 messages of the chat to avoid displaying a very long history upon loading.

1. Go back to the file `src/app/services/chat.service.ts`.
2. Find the function `loadMessages`.
3. Replace the entire function with the following code.

####  [chat.service.ts](https://github.com/firebase/friendlychat/blob/master/angularfire/src/app/services/chat.service.ts)

```
// Loads chat messages history and listens for upcoming ones.
loadMessages = () => {
  // Create the query to load the last 12 messages and listen for new ones.
  const recentMessagesQuery = query(collection(this.firestore, 'messages'), orderBy('timestamp', 'desc'), limit(12));
  // Start listening to the query.
  return collectionData(recentMessagesQuery);
}
```

To listen to messages in the database, we create a query on a collection by using the `collection` function to specify which collection the data that we want to listen to is in. In the code above, we're listening to the changes within the `messages` collection, which is where the chat messages are stored. We're also applying a limit by only listening to the last 12 messages using `limit(12)` and ordering the messages by date using `orderBy('timestamp', 'desc')` to get the 12 newest messages.

The `collectionData` function uses snapshots under the hood. The callback function will be triggered when there are any changes to documents that match the query. This could be if a message gets deleted, modified, or added. You can read more about this in the  [Cloud Firestore documentation](https://firebase.google.com/docs/firestore/query-data/listen).

#### Test synchronizing messages

1. If your app is still being served, refresh your app in the browser. Otherwise, run `firebase emulators:start` on the command line to start serving the app from  [http://localhost:5000](http://localhost:5000), and then open it in your browser.
2. The messages that you created earlier into the database should be displayed in the FriendlyChat UI (see below). Feel free to write new messages; they should appear instantly.
3. *(Optional)* You can try manually deleting, modifying, or adding new messages directly in the **Firestore** section of the Emulator suite; any changes should be reflected in the UI.

Congratulations! You are reading Cloud Firestore documents in your app!

<img src="img/angularfire-2.png" alt="angularfire-2.png"  width="464.18" />


## Send images
Duration: 10:00


We'll now add a feature that shares images.

While Cloud Firestore is good for storing structured data, Cloud Storage is better suited for storing files.  [Cloud Storage for Firebase](https://firebase.google.com/docs/storage/) is a file/blob storage service, and we'll use it to store any images that a user shares using our app.

#### Save images to Cloud Storage

For this codelab, we've already added for you a button that triggers a file picker dialog. After selecting a file, the `saveImageMessage` function is called, and you can get a reference to the selected file. The `saveImageMessage` function accomplishes the following:

1. Creates a "placeholder" chat message in the chat feed, so that users see a "Loading" animation while we upload the image.
2. Uploads the image file to Cloud Storage to this path: `/&lt;uid&gt;/&lt;file_name&gt;`
3. Generates a publicly readable URL for the image file.
4. Updates the chat message with the newly uploaded image file's URL in lieu of the temporary loading image.

Now you'll add the functionality to send an image:

1. Go back to the file `src/index.js`.
2. Find the function `saveImageMessage`.
3. Replace the entire function with the following code.

####  [index.js](https://github.com/firebase/friendlychat/blob/master/web/src/index.js#L84-109)

```
// Saves a new message containing an image in Firebase.
// This first saves the image in Firebase storage.
saveImageMessage = async(file: any) => {
  try {
    // 1 - We add a message with a loading icon that will get updated with the shared image.
    const messageRef = await this.addMessage(null, this.LOADING_IMAGE_URL);

    // 2 - Upload the image to Cloud Storage.
    const filePath = `${this.auth.currentUser?.uid}/${file.name}`;
    const newImageRef = ref(this.storage, filePath);
    const fileSnapshot = await uploadBytesResumable(newImageRef, file);
    
    // 3 - Generate a public URL for the file.
    const publicImageUrl = await getDownloadURL(newImageRef);

    // 4 - Update the chat message placeholder with the image’s URL.
    messageRef ?
    await updateDoc(messageRef,{
      imageUrl: publicImageUrl,
      storageUri: fileSnapshot.metadata.fullPath
    }): null;
  } catch (error) {
    console.error('There was an error uploading a file to Cloud Storage:', error);
  }
}
```

#### **Test sending images**

1. If your app is still being served, refresh your app in the browser. Otherwise, run `firebase emulators:start` on the command line to start serving the app from  [http://localhost:5000](http://localhost:5000), and then open it in your browser.
2. After logging in, click the image upload button on the bottom left <img src="img/angularfire-4.png" alt="angularfire-4.png"  width="26.61" /> and select an image file using the file picker. If you're looking for an image, feel free to use this  [nice picture of a coffee cup](https://www.pexels.com/photo/aroma-aromatic-art-artistic-434213/).
3. A new message should appear in the app's UI with your selected image:
<img src="img/3b1284f5144b54f6.png" alt="3b1284f5144b54f6.png"  width="555.06" />

If you try adding an image while not signed in, you should see an error telling you that you must sign in to add images.


## Show notifications
Duration: 10:00


We'll now add support for browser notifications. The app will notify users when new messages are posted in the chat.  [Firebase Cloud Messaging](https://firebase.google.com/docs/cloud-messaging/) (FCM) is a cross-platform messaging solution that lets you reliably deliver messages and notifications at no cost.

#### **Add the FCM service worker**

The web app needs a [service worker](https://developer.mozilla.org/en/docs/Web/API/Service_Worker_API) that will receive and display web notifications.

The messaging provider should already be set up when AngularFire was added, make sure that the following code exists in the imports section of `/angularfire-start/src/app/app.module.ts`


```
provideMessaging(() => {
    return getMessaging();
}),
```
####  [app/app.module.ts](https://github.com/firebase/friendlychat/blob/master/web/angularfire-start/src/app/app.module.ts)

The service worker simply needs to load and initialize the Firebase Cloud Messaging SDK, which will take care of displaying notifications.

#### **Get FCM device tokens**

When notifications have been enabled on a device or browser, you'll be given a **device token**. This device token is what we use to send a notification to a particular device or particular browser.

When the user signs-in, we call the `saveMessagingDeviceToken` function. That's where we'll get the **FCM device token** from the browser and save it to Cloud Firestore.

####  [chat.service.ts](https://github.com/firebase/friendlychat/blob/master/angularfire/src/app/services/chat.service.ts)
2. Find the function `saveMessagingDeviceToken`.
3. Replace the entire function with the following code.

####  [chat.service.ts](https://github.com/firebase/friendlychat/blob/master/angularfire/src/app/services/chat.service.ts)

```
// Saves the messaging device token to Cloud Firestore.
saveMessagingDeviceToken= async () => {
    try {
      const currentToken = await getToken(this.messaging);
      if (currentToken) {
        console.log('Got FCM device token:', currentToken);
        // Saving the Device Token to Cloud Firestore.
        const tokenRef = doc(this.firestore, 'fcmTokens', currentToken);
        await setDoc(tokenRef, { uid: this.auth.currentUser?.uid });
 
        // This will fire when a message is received while the app is in the foreground.
        // When the app is in the background, firebase-messaging-sw.js will receive the message instead.
        onMessage(this.messaging, (message) => {
          console.log(
            'New foreground notification from Firebase Messaging!',
            message.notification
          );
        });
      } else {
        // Need to request permissions to show notifications.
        this.requestNotificationsPermissions();
      }
    } catch(error) {
      console.error('Unable to get messaging token.', error);
    };
}
```

However, this code won't work initially. For your app to be able to retrieve the device token, the user needs to grant your app permission to show notifications (next step of the codelab).

#### **Request permissions to show notifications**

When the user has not yet granted your app permission to show notifications, you won't be given a device token. In this case, we call the `requestPermission()` method, which will display a browser dialog asking for this permission ( [in supported browsers](https://caniuse.com/#feat=push-api)).

<img src="img/8b9d0c66dc36153d.png" alt="8b9d0c66dc36153d.png"  width="567.50" />

1. Go back to the file `src/app/services/chat.service.ts`.
2. Find the function `requestNotificationsPermissions`.
3. Replace the entire function with the following code.

####  [chat.service.ts](https://github.com/firebase/friendlychat/blob/master/angularfire/src/app/services/chat.service.ts)

```
// Requests permissions to show notifications.
requestNotificationsPermissions = async () => {
    console.log('Requesting notifications permission...');
    const permission = await Notification.requestPermission();
    
    if (permission === 'granted') {
      console.log('Notification permission granted.');
      // Notification permission granted.
      await this.saveMessagingDeviceToken();
    } else {
      console.log('Unable to get permission to notify.');
    }
}
```

#### **Get your device token**

1. If your app is still being served, refresh your app in the browser. Otherwise, run `firebase emulators:start` on the command line to start serving the app from  [http://localhost:5000](http://localhost:5000), and then open it in your browser.
2. After logging in, the notifications permission dialog should appear:
<img src="img/bd3454e6dbfb6723.png" alt="bd3454e6dbfb6723.png"  width="480.00" />
3. Click **Allow**.
4. Open the JavaScript console of your browser. You should see the following message:
`Got FCM device token: cWL6w:APA91bHP...4jDPL_A-wPP06GJp1OuekTaTZI5K2Tu`
5. Copy your device token. You'll need it for the next stage of the codelab.

#### **Send a notification to your device**

Now that you have your device token, you can send a notification.

1. Open the [Cloud Messaging tab of the Firebase console](https://console.firebase.google.com/project/_/notification).
2. Click "New Notification"
3. Enter a notification title and notification text.
4. On the right side of the screen, click "send a test message"
5. Enter the device token you copied from the JavaScript console of your browser, then click the plus ("+") sign
6. Click "test"

If your app is in the foreground, you'll see the notification in the JavaScript console.

If your app is in the background, a notification should appear in your browser, as in this example:

<img src="img/de79e8638a45864c.png" alt="de79e8638a45864c.png"  width="377.78" />

> aside positive
> 
> In a followup codelab,  [**Firebase SDK for Cloud Functions**](https://codelabs.developers.google.com/codelabs/firebase-cloud-functions), we'll see how to automate sending notifications from the backend for each new message posted in the chat app.

## Cloud Firestore security rules
Duration: 05:00


#### View **database security rules**

Cloud Firestore uses a specific  [rules language](https://firebase.google.com/docs/firestore/security/overview) to define access rights, security, and data validations.

When setting up the Firebase project at the beginning of this codelab, we chose to use "Test mode" default security rules so that we didn't restrict access to the datastore. In the  [Firebase console](https://console.firebase.google.com), in the **Database** section's **Rules** tab, you can view and modify these rules.

Right now, you should see the default rules, which do not restrict access to the datastore. This means that any user can read and write to any collections in your datastore.

```
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    match /{document=**} {
      allow read, write;
    }
  }
}
```

We'll update the rules to restrict things by using the following rules:

####  [firestore.rules](https://github.com/firebase/friendlychat/blob/master/angularfire-start/firestore.rules)

```
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Messages:
    //   - Anyone can read.
    //   - Authenticated users can add and edit messages.
    //   - Validation: Check name is same as auth token and text length below 300 char or that imageUrl is a URL.
    //   - Deletes are not allowed.
    match /messages/{messageId} {
      allow read;
      allow create, update: if request.auth != null
                    && request.resource.data.name == request.auth.token.name
                    && (request.resource.data.text is string
                      && request.resource.data.text.size() <= 300
                      || request.resource.data.imageUrl is string
                      && request.resource.data.imageUrl.matches('https?://.*'));
      allow delete: if false;
    }
    // FCM Tokens:
    //   - Anyone can write their token.
    //   - Reading list of tokens is not allowed.
    match /fcmTokens/{token} {
      allow read: if false;
      allow write;
    }
  }
}
```

> aside positive
> 
> The `request.auth` rule variable is a special variable containing information about an authenticated user. The `request.resource` rule variable points to the new data being written. More information can be found in  [the documentation](https://firebase.google.com/docs/firestore/security/overview).

The security rules should update automatically to your Emulator suite. 

#### **View Cloud Storage security rules**

Cloud Storage for Firebase uses a specific  [rules language](https://firebase.google.com/docs/storage/security/start) to define access rights, security, and data validations.

When setting up the Firebase project at the beginning of this codelab, we chose to use the default Cloud Storage security rule that only allows authenticated users to use Cloud Storage. In the  [Firebase console](https://console.firebase.google.com), in the **Storage** section's **Rules** tab, you can view and modify rules. You should see the default rule which allows any signed-in user to read and write any files in your storage bucket.

```
rules_version = '2';

service firebase.storage {
  match /b/{bucket}/o {
    match /{allPaths=**} {
      allow read, write: if request.auth != null;
    }
  }
}
```

We'll update the rules to do the following:

* Allow each user to write only to their own specific folders
* Allow anyone to read from Cloud Storage
* Make sure that the files uploaded are images
* Restrict the size of the images that can be uploaded to maximum 5 MB

This can be implemented using the following rules:

####  [storage.rules](https://github.com/firebase/friendlychat/blob/master/angularfire-start/storage.rules)

```
rules_version = '2';

// Returns true if the uploaded file is an image and its size is below the given number of MB.
function isImageBelowMaxSize(maxSizeMB) {
  return request.resource.size < maxSizeMB * 1024 * 1024
      && request.resource.contentType.matches('image/.*');
}

service firebase.storage {
  match /b/{bucket}/o {
    match /{userId}/{messageId}/{fileName} {
      allow write: if request.auth != null && request.auth.uid == userId && isImageBelowMaxSize(5);
      allow read;
    }
  }
}
```

> aside positive
>
> The `request.auth` rule variable is a special variable containing information about an authenticated user. The `request.resource` rule variable contains information about the uploaded file. More information can be found in  [the documentation](https://firebase.google.com/docs/storage/security/start).


## Deploy your app using Firebase Hosting
Duration: 03:00


Firebase offers a [hosting service](https://firebase.google.com/docs/hosting/) to serve your assets and web apps. You can deploy your files to Firebase Hosting using the Firebase CLI. Before deploying, you need to specify in your `firebase.json` file which local files should be deployed. For this codelab, we've already done this for you because this step was required to serve our files during this codelab. The hosting settings are specified under the `hosting` attribute:

####  [firebase.json](https://github.com/firebase/friendlychat/blob/master/web/firebase.json#L8-L17)

```
{
  // If you went through the "Cloud Firestore Security Rules" step.
  "firestore": {
    "rules": "firestore.rules"
  },
  // If you went through the "Storage Security Rules" step.
  "storage": {
    "rules": "storage.rules"
  },
  "hosting": {
    "public": "./public"
  }
}
```

These settings tell the CLI that we want to deploy all files in the `./public` directory ( `"public": "./public"` ).

1. Make sure that your command line is accessing your app's local `angularfire-start` directory.
2. Deploy your files to your Firebase project by running the following command:

```
ng deploy
```

Then select the Firebase option, and follow the prompts in the command line.

3. The console should display the following:

```
=== Deploying to 'friendlychat-1234'...

i  deploying firestore, storage, hosting
i  storage: checking storage.rules for compilation errors...
✔  storage: rules file storage.rules compiled successfully
i  firestore: checking firestore.rules for compilation errors...
✔  firestore: rules file firestore.rules compiled successfully
i  storage: uploading rules storage.rules...
i  firestore: uploading rules firestore.rules...
i  hosting[friendlychat-1234]: beginning deploy...
i  hosting[friendlychat-1234]: found 8 files in ./public
✔  hosting[friendlychat-1234]: file upload complete
✔  storage: released rules storage.rules to firebase.storage/friendlychat-1234.appspot.com
✔  firestore: released rules firestore.rules to cloud.firestore
i  hosting[friendlychat-1234]: finalizing version...
✔  hosting[friendlychat-1234]: version finalized
i  hosting[friendlychat-1234]: releasing new version...
✔  hosting[friendlychat-1234]: release complete

✔  Deploy complete!

Project Console: https://console.firebase.google.com/project/friendlychat-1234/overview
Hosting URL: https://friendlychat-1234.firebaseapp.com
```

4. Visit your web app that's now fully hosted on a global CDN using Firebase Hosting at two of your very own Firebase subdomains: 

* `https://&lt;firebase-projectId&gt;.firebaseapp.com`
* `https://&lt;firebase-projectId&gt;.web.app`

Alternatively, you can run `firebase open hosting:site` in the command line.

Visit the documentation to learn more about  [how Firebase Hosting works](https://firebase.google.com/docs/hosting/#how_does_it_work).

Go to your project's Firebase console **Hosting** section to view useful hosting information and tools, including the history of your deploys, the functionality to roll back to previous versions of your app, and the workflow to set up a custom domain.


## Congratulations!



You've used Firebase to build a real-time chat web application!

#### **What we've covered**

* Firebase Authentication
* Cloud Firestore
* Firebase SDK for Cloud Storage
* Firebase Cloud Messaging
* Firebase Performance Monitoring
* Firebase Hosting

#### Next steps

> aside positive
> 
> Continue on to the  [**Cloud Functions for Firebase**](https://codelabs.developers.google.com/codelabs/firebase-cloud-functions/#4) codelab to learn how to use the Firebase SDK for Cloud Functions and add some backend tasks to your chat app. You can start directly on Step 5 of that codelab since you've already set up your Firebase project.

> aside positive
> 
> Want to learn more about Cloud Firestore? Maybe you want to learn about subcollections and transactions? Head over to the  [**Cloud Firestore web codelab**](https://codelabs.developers.google.com/codelabs/firestore-web/#0) for a codelab that goes into greater depth on Cloud Firestore.

> aside positive
> 
> Want to learn more about Firebase Performance Monitoring for Web? Head over to the  [**Firebase performance monitoring for web codelab**](https://codelabs.developers.google.com/codelabs/firebase-perf-mon-web/) for a codelab that goes into greater depth on Firebase Performance Monitoring.

#### **Learn more**

*  [firebase.google.com](https://firebase.google.com)





================================================
File: codelabs/codelab-friendlychat-web/steps/tsconfig.app.json
================================================
/* To learn more about this file see: https://angular.io/config/tsconfig. */
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./out-tsc/app",
    "types": []
  },
  "files": [
    "src/main.ts"
  ],
  "include": [
    "src/**/*.d.ts"
  ]
}



================================================
File: codelabs/codelab-friendlychat-web/steps/tsconfig.json
================================================
/* To learn more about this file see: https://angular.io/config/tsconfig. */
{
  "compileOnSave": false,
  "compilerOptions": {
    "baseUrl": "./",
    "outDir": "./dist/out-tsc",
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "noImplicitOverride": true,
    "noPropertyAccessFromIndexSignature": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "sourceMap": true,
    "declaration": false,
    "downlevelIteration": true,
    "experimentalDecorators": true,
    "moduleResolution": "node",
    "importHelpers": true,
    "target": "ES2022",
    "module": "ES2022",
    "useDefineForClassFields": false,
    "lib": [
      "ES2022",
      "dom"
    ]
  },
  "angularCompilerOptions": {
    "enableI18nLegacyMessageIdFormat": false,
    "strictInjectionParameters": true,
    "strictInputAccessModifiers": true,
    "strictTemplates": true
  }
}



================================================
File: codelabs/codelab-friendlychat-web/steps/tsconfig.spec.json
================================================
/* To learn more about this file see: https://angular.io/config/tsconfig. */
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./out-tsc/spec",
    "types": [
      "jasmine"
    ]
  },
  "include": [
    "src/**/*.spec.ts",
    "src/**/*.d.ts"
  ]
}



================================================
File: codelabs/codelab-friendlychat-web/steps/.editorconfig
================================================
# Editor configuration, see https://editorconfig.org
root = true

[*]
charset = utf-8
indent_style = space
indent_size = 2
insert_final_newline = true
trim_trailing_whitespace = true

[*.ts]
quote_type = single

[*.md]
max_line_length = off
trim_trailing_whitespace = false



================================================
File: codelabs/codelab-friendlychat-web/steps/.gitignore
================================================
/node_modules
/dist
.angular



================================================
File: codelabs/codelab-friendlychat-web/steps/functions/package.json
================================================
{
  "name": "functions",
  "description": "Cloud Functions for Firebase",
  "scripts": {
    "serve": "firebase emulators:start --only functions",
    "shell": "firebase functions:shell",
    "start": "npm run shell",
    "deploy": "firebase deploy --only functions",
    "logs": "firebase functions:log"
  },
  "engines": {
    "node": "18"
  },
  "main": "index.js",
  "dependencies": {
    "firebase-admin": "^11.8.0",
    "firebase-functions": "^4.3.1"
  },
  "devDependencies": {
    "firebase-functions-test": "^3.1.0"
  },
  "private": true
}



================================================
File: codelabs/codelab-friendlychat-web/steps/functions/.gitignore
================================================
node_modules/



================================================
File: codelabs/codelab-friendlychat-web/steps/src/index.html
================================================
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Friendlychat</title>
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
</head>
<body class="bg-slate-100">
  <app-root></app-root>
</body>
</html>



================================================
File: codelabs/codelab-friendlychat-web/steps/src/main.ts
================================================
import { bootstrapApplication } from '@angular/platform-browser';
import { AppComponent } from './app/app.component';
import { appConfig } from './app/app.config';

bootstrapApplication(AppComponent, appConfig).catch((err) =>
  console.error(err)
);



================================================
File: codelabs/codelab-friendlychat-web/steps/src/styles.css
================================================
@tailwind base;
@tailwind components;
@tailwind utilities;



================================================
File: codelabs/codelab-friendlychat-web/steps/src/app/app-routing.module.ts
================================================
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import {
  AuthGuard,
  redirectLoggedInTo,
  redirectUnauthorizedTo,
} from '@angular/fire/auth-guard';
import { LoginPageComponent } from './pages/login-page/login-page.component';
import { ChatPageComponent } from './pages/chat-page/chat-page.component';

const redirectUnauthorizedToLogin = () => redirectUnauthorizedTo(['login']);
const redirectLoggedInToHome = () => redirectLoggedInTo(['chat']);

const routes: Routes = [
  {
    path: '',
    component: LoginPageComponent,
    canActivate: [AuthGuard],
    data: { authGuardPipe: redirectLoggedInToHome },
  },
  {
    path: 'login',
    component: LoginPageComponent,
    canActivate: [AuthGuard],
    data: { authGuardPipe: redirectLoggedInToHome },
  },
  {
    path: 'chat',
    component: ChatPageComponent,
    canActivate: [AuthGuard],
    data: { authGuardPipe: redirectUnauthorizedToLogin },
  },
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule],
})
export class AppRoutingModule {}



================================================
File: codelabs/codelab-friendlychat-web/steps/src/app/app.component.css
================================================



================================================
File: codelabs/codelab-friendlychat-web/steps/src/app/app.component.html
================================================
<div class="site-layout">
  <app-header></app-header>
  <div class="container">
</div>
  <router-outlet></router-outlet>
</div>



================================================
File: codelabs/codelab-friendlychat-web/steps/src/app/app.component.spec.ts
================================================
import { TestBed } from '@angular/core/testing';
import { RouterTestingModule } from '@angular/router/testing';
import { AppComponent } from './app.component';

describe('AppComponent', () => {
  beforeEach(() => TestBed.configureTestingModule({
    imports: [RouterTestingModule],
    declarations: [AppComponent]
  }));

  it('should create the app', () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app).toBeTruthy();
  });

  it(`should have as title 'friendlychat'`, () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app.title).toEqual('friendlychat');
  });

  it('should render title', () => {
    const fixture = TestBed.createComponent(AppComponent);
    fixture.detectChanges();
    const compiled = fixture.nativeElement as HTMLElement;
    expect(compiled.querySelector('.content span')?.textContent).toContain('friendlychat app is running!');
  });
});



================================================
File: codelabs/codelab-friendlychat-web/steps/src/app/app.component.ts
================================================
import { Component } from '@angular/core';
import { HeaderComponent } from './components/header/header.component';
import { RouterModule } from '@angular/router';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css'],
  standalone: true,
  imports: [HeaderComponent, RouterModule],
})
export class AppComponent {
  title = 'friendlychat';
}



================================================
File: codelabs/codelab-friendlychat-web/steps/src/app/app.config.ts
================================================
import { ApplicationConfig, importProvidersFrom } from '@angular/core';
import { initializeApp, provideFirebaseApp } from '@angular/fire/app';
import { environment } from '../environments/environment';
import { provideAuth, getAuth, connectAuthEmulator } from '@angular/fire/auth';
import { provideFirestore, getFirestore, connectFirestoreEmulator } from '@angular/fire/firestore';
import { provideFunctions, getFunctions, connectFunctionsEmulator} from '@angular/fire/functions';
import { provideMessaging, getMessaging } from '@angular/fire/messaging';
import { provideStorage, getStorage, connectStorageEmulator } from '@angular/fire/storage';
import { routes } from './app.routes';
import { provideRouter } from '@angular/router';

export const appConfig: ApplicationConfig = {
  providers: [
    importProvidersFrom(
      provideFirebaseApp(() => initializeApp(environment.firebase)),
      provideFirestore(() => getFirestore()),
      provideAuth(() => getAuth()),
      provideFunctions(() => getFunctions()),
      provideStorage(() => getStorage()),
      provideMessaging(() => getMessaging())
    ),
    provideRouter(routes)
  ],
};



================================================
File: codelabs/codelab-friendlychat-web/steps/src/app/app.module.ts
================================================
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';

import { AppRoutingModule } from './app-routing.module';
import { AppComponent } from './app.component';
import { initializeApp, provideFirebaseApp } from '@angular/fire/app';
import { environment } from '../environments/environment';
import { provideAuth, getAuth, connectAuthEmulator } from '@angular/fire/auth';
import {
  provideFirestore,
  getFirestore,
  connectFirestoreEmulator,
} from '@angular/fire/firestore';
import {
  provideFunctions,
  getFunctions,
  connectFunctionsEmulator,
} from '@angular/fire/functions';
import { provideMessaging, getMessaging } from '@angular/fire/messaging';
import {
  provideStorage,
  getStorage,
  connectStorageEmulator,
} from '@angular/fire/storage';

import { LoginPageComponent } from './pages/login-page/login-page.component';
import { ChatPageComponent } from './pages/chat-page/chat-page.component';
import { HeaderComponent } from './components/header/header.component';

@NgModule({
  declarations: [
    AppComponent,
    LoginPageComponent,
    ChatPageComponent,
    HeaderComponent,
  ],
  imports: [BrowserModule, AppRoutingModule, CommonModule, FormsModule],
  providers: [],
  bootstrap: [AppComponent],
})
export class AppModule {}



================================================
File: codelabs/codelab-friendlychat-web/steps/src/app/app.routes.ts
================================================
import { RouterModule, Routes } from '@angular/router';
import {
  AuthGuard,
  redirectLoggedInTo,
  redirectUnauthorizedTo,
} from '@angular/fire/auth-guard';
import { LoginPageComponent } from './pages/login-page/login-page.component';
import { ChatPageComponent } from './pages/chat-page/chat-page.component';

const redirectUnauthorizedToLogin = () => redirectUnauthorizedTo(['login']);
const redirectLoggedInToHome = () => redirectLoggedInTo(['chat']);

export const routes: Routes = [
  {
    path: '',
    component: LoginPageComponent,
    canActivate: [AuthGuard],
    data: { authGuardPipe: redirectLoggedInToHome },
  },
  {
    path: 'login',
    component: LoginPageComponent,
    canActivate: [AuthGuard],
    data: { authGuardPipe: redirectLoggedInToHome },
  },
  {
    path: 'chat',
    component: ChatPageComponent,
    canActivate: [AuthGuard],
    data: { authGuardPipe: redirectUnauthorizedToLogin },
  },
];



================================================
File: codelabs/codelab-friendlychat-web/steps/src/app/components/header/header.component.css
================================================
.dropdown:hover .dropdown-menu {
    display: block;
}



================================================
File: codelabs/codelab-friendlychat-web/steps/src/app/components/header/header.component.html
================================================
<header>
    <nav class="bg-navy-400 px-2 lg:px-4 py-2.5 h-18">
        <div class="flex flex-wrap justify-between items-center max-w-screen">
            <a href="/" class="flex items-center">
                <img src="../../../assets/FriendlyChatLogo.png" alt="FriendlyChat" class="mr-3 h-16 sm:h-10 stop-image" />
                <span class="mr-3 self-center text-2xl whitespace-nowrap font-light text-white">
                    Friendly Chat
                </span>
            </a>
            @if(user$ | async; as user) {
                <div class="flex flex-wrap items-center content-center auth">
                    <div class="hidden sm:flex flex-wrap items-center content-center text-white">
                        <img class="w-10 h-10 rounded-full" [src]="user?.photoURL"
                            [alt]="user?.displayName" />
                        <span class="text-white text-xl whitespace-nowrap font-light px-4 lg:px-5 py-2 lg:py-2.5">
                            {{user?.displayName}}
                        </span>
                    </div>
                        <div class="dropdown rounded-lg px-4 py-2 hover:bg-navy-700 transition-colors">
                            <div class="flex items-center">
                            <button class="text-gray-700 inline-flex items-center font-semibold">
                                <img class="w-8 h-8" src="../../../assets/menu.svg" />
                            </button></div>
                            <ul class="dropdown-menu absolute hidden bg-white w-48 p-1 right-2 shadow-xl rounded-lg">
                                <li class="bg-white flex flex-row gap-2 items-center px-4 py-4 rounded-lg">
                                    <img class="w-10 h-10 rounded-full" [src]="user?.photoURL"
                                        [alt]="user?.displayName" />
                                    <span
                                        class="text-navy-200 text-md whitespace-nowrap">
                                        {{user?.displayName}}
                                    </span>
                                </li>
                                <li>
                                    <a class="bg-white hover:bg-navy-20 rounded-md mt-4 py-3 px-4 block whitespace-no-wrap text-navy-500 font-semibold"
                                        href="/" (click)="this.chatService.logout()">
                                        Sign out
                                    </a>
                                </li>
                            </ul>
                        </div>
                </div>
            }
        </div>
    </nav>
</header>



================================================
File: codelabs/codelab-friendlychat-web/steps/src/app/components/header/header.component.spec.ts
================================================
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { HeaderComponent } from './header.component';

describe('HeaderComponent', () => {
  let component: HeaderComponent;
  let fixture: ComponentFixture<HeaderComponent>;

  beforeEach(() => {
    TestBed.configureTestingModule({
      declarations: [HeaderComponent]
    });
    fixture = TestBed.createComponent(HeaderComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});



================================================
File: codelabs/codelab-friendlychat-web/steps/src/app/components/header/header.component.ts
================================================
import { AsyncPipe } from '@angular/common';
import { Component, inject } from '@angular/core';
import { ChatService } from 'src/app/services/chat.service';

@Component({
  selector: 'app-header',
  templateUrl: './header.component.html',
  styleUrls: ['./header.component.css'],
  standalone: true,
  imports: [AsyncPipe],
})
export class HeaderComponent {
  chatService = inject(ChatService);
  user$ = this.chatService.user$;
}



================================================
File: codelabs/codelab-friendlychat-web/steps/src/app/pages/chat-page/chat-page.component.css
================================================



================================================
File: codelabs/codelab-friendlychat-web/steps/src/app/pages/chat-page/chat-page.component.html
================================================
<div class="min-h-screen h-full w-full bg-navy-30">
    <div class="w-3/4 bg-navy-10 min-h-screen h-full mx-auto flex flex-col flex-grow pb-56 overflow-auto">
        @for (message of (messages$ | async); track message) {
            <div> <!-- TODO: I think this div can be removed-->
            <div class="flex flex-col flex-grow p-4 gap-3">
                @if (user$ | async; as user) {
                    <div class="flex flex-nowrap gap-4" [class.flex-row-reverse]="user.uid === message['uid']">
                            <img class="w-10 h-10 rounded-full" [src]="message['profilePicUrl']"
                                [alt]="message['name']" />
                        <div class="flex flex-wrap gap-1 text-neutral-800" [class.flex-row-reverse]="user.uid === message['uid']">
                                <div class="p-4 rounded-lg max-w-xl flex flex-col justify-between gap-1" [class.bg-amber-200]="user.uid === message['uid']" [class.bg-white]="user.uid !== message['uid']">
                            @if (message['text'] && message['text'].length > 0){
                                <div>
                                    {{message['text']}} 
                                </div>
                            }
                            @if (message['imageUrl'] && message['imageUrl'].length > 0) {
                                <div class="flex justify-center">
                                    <img class="max-w-[50vw] max-h-[30vh] rounded-md" [src]="message['imageUrl']" alt="image" />
                                </div>
                            }
                            <div class="flex flex-nowrap justify-end">
                                <span class="text-neutral-500 text-sm">
                                    {{message['timestamp'].toDate().toLocaleTimeString()}}
                                </span>
                            </div>
                        </div>
                        
                            @if (message['response'] && message['response'].length > 0){
                                <div class="transition-all opacity-30 hover:opacity-100 hover:border-2 hover:border-navy-200 hover:py-6 gap-1 p-4 rounded-lg max-w-xl flex flex-col justify-between">
                                <div>
                                    {{message['response']}}
                                </div>
                                <div class="flex flex-nowrap justify-end">
                                    <span class="text-neutral-500 text-sm">
                                        ✨ ai generated
                                    </span>
                                </div>
                            </div>
                            }
                        </div>
                        
                    </div>
                }
            </div>
        </div>
    }
    </div>
    <div class="bg-navy-10 w-full shadow-[0_35px_60px_-15px_rgba(0,0,0,1)] bottom-0 fixed">
        <div class="flex-wrap flex w-5/6 mx-auto">
            <input type="file" class="file-input hidden" (change)="this.uploadImage($event)" #fileUpload>
            <div class="file-upload w-16 h-16 rounded-full bg-amber-800 my-3">
                <button color="primary" class="upload-btn" (click)="fileUpload.click()">
                    <img class="w-16 h-16" src="../../../assets/add.svg" alt="Upload image" />
                </button>
            </div>
            <textarea
                class="w-4/5 mx-auto h-16 rounded-3xl my-auto overflow-auto text-gray-900 dark:placeholder-gray-400 p-4"
                placeholder="Write your thoughts here..." [(ngModel)]="this.text"></textarea>
            <button class="w-16 h-16 rounded-full bg-amber-800 my-3" (click)="this.sendTextMessage()">
                <img class="w-16 h-16" src="../../../assets/send.svg" alt="Send message" />
            </button>
        </div>
    </div>
</div>



================================================
File: codelabs/codelab-friendlychat-web/steps/src/app/pages/chat-page/chat-page.component.spec.ts
================================================
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { ChatPageComponent } from './chat-page.component';

describe('ChatPageComponent', () => {
  let component: ChatPageComponent;
  let fixture: ComponentFixture<ChatPageComponent>;

  beforeEach(() => {
    TestBed.configureTestingModule({
      declarations: [ChatPageComponent]
    });
    fixture = TestBed.createComponent(ChatPageComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});



================================================
File: codelabs/codelab-friendlychat-web/steps/src/app/pages/chat-page/chat-page.component.ts
================================================
import { AsyncPipe } from '@angular/common';
import { Component, inject } from '@angular/core';
import { DocumentData } from '@angular/fire/firestore';
import { FormsModule } from '@angular/forms';
import { Observable } from 'rxjs';
import { ChatService } from 'src/app/services/chat.service';

@Component({
  selector: 'app-chat-page',
  templateUrl: './chat-page.component.html',
  styleUrls: ['./chat-page.component.css'],
  standalone: true,
  imports: [AsyncPipe, FormsModule]
})
export class ChatPageComponent {
  chatService = inject(ChatService);
  messages$ = this.chatService.loadMessages() as Observable<DocumentData[]>;
  user$ = this.chatService.user$;
  text = '';

  sendTextMessage() {
    this.chatService.saveTextMessage(this.text);
    this.text = '';
  }

  uploadImage(event: any) {
    const imgFile: File = event.target.files[0];
    if (!imgFile) {
      return;
    }
    this.chatService.saveImageMessage(imgFile);
  }
}



================================================
File: codelabs/codelab-friendlychat-web/steps/src/app/pages/login-page/login-page.component.css
================================================



================================================
File: codelabs/codelab-friendlychat-web/steps/src/app/pages/login-page/login-page.component.html
================================================
<div class="min-h-[80vh] h-full w-full py-10 flex flex-wrap flex-col-reverse sm:flex-row items-center min-w-screen">
    <div class="min-w-screen sm:w-[50%] h-full items-center m-auto">
        <img src="../../../assets/WithFirebase.png" class="w-[350px] m-auto" />
    </div>
    <div class="min-w-screen sm:w-[50%] flex flex-col gap-5 items-center h-full gap-5">
        <div>
            <img src="../../../assets/FriendlyChatLogo.png" class="w-[200px]" />
            <span class="text-navy-600 text-5xl font-light mt-5">Friendly Chat</span>
        </div>
        <button class="transition-all w-[400px] bg-white shadow-md flex flex-wrap items-center rounded-lg p-2 hover:shadow-xl justify-between" (click)="this.chatService.login()">
            <img src="../../../assets/Google.png" class="w-8 m-2" />
            <span class="text-slate-700 text-xl flex-grow">Sign in with Google</span>
        </button>
    </div>
</div>


================================================
File: codelabs/codelab-friendlychat-web/steps/src/app/pages/login-page/login-page.component.spec.ts
================================================
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { LoginPageComponent } from './login-page.component';

describe('LoginPageComponent', () => {
  let component: LoginPageComponent;
  let fixture: ComponentFixture<LoginPageComponent>;

  beforeEach(() => {
    TestBed.configureTestingModule({
      declarations: [LoginPageComponent]
    });
    fixture = TestBed.createComponent(LoginPageComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});



================================================
File: codelabs/codelab-friendlychat-web/steps/src/app/pages/login-page/login-page.component.ts
================================================
import { Component, inject } from '@angular/core';
import { ChatService } from 'src/app/services/chat.service';

@Component({
  selector: 'app-login-page',
  templateUrl: './login-page.component.html',
  styleUrls: ['./login-page.component.css'],
  standalone: true,
})
export class LoginPageComponent {
  chatService = inject(ChatService);
  user$ = this.chatService.user$;
}



================================================
File: codelabs/codelab-friendlychat-web/steps/src/app/services/chat.service.spec.ts
================================================
import { TestBed } from '@angular/core/testing';

import { ChatService } from './chat.service';

describe('ChatService', () => {
  let service: ChatService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(ChatService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});



================================================
File: codelabs/codelab-friendlychat-web/steps/src/app/services/chat.service.ts
================================================
import { inject, Injectable } from '@angular/core';
import {
  Auth,
  authState,
  signInWithPopup,
  GoogleAuthProvider,
  signOut,
  user,
  getAuth,
  User,
} from '@angular/fire/auth';
import { map, switchMap, firstValueFrom, filter, Observable, Subscription } from 'rxjs';
import {
  doc,
  docData,
  DocumentReference,
  Firestore,
  getDoc,
  setDoc,
  updateDoc,
  collection,
  addDoc,
  deleteDoc,
  collectionData,
  Timestamp,
  serverTimestamp,
  query,
  orderBy,
  limit,
  onSnapshot,
  DocumentData,
  FieldValue,
} from '@angular/fire/firestore';
import {
  Storage,
  getDownloadURL,
  ref,
  uploadBytesResumable,
} from '@angular/fire/storage';
import { getToken, Messaging, onMessage } from '@angular/fire/messaging';
import { Router } from '@angular/router';

type ChatMessage = {
  name: string | null,
  profilePicUrl: string | null,
  timestamp: FieldValue,
  uid: string | null,
  text?: string,
  imageUrl?: string
};


@Injectable({
  providedIn: 'root',
})
export class ChatService {
  firestore: Firestore = inject(Firestore);
  auth: Auth = inject(Auth);
  storage: Storage = inject(Storage);
  messaging: Messaging = inject(Messaging);
  router: Router = inject(Router);
  private provider = new GoogleAuthProvider();
  LOADING_IMAGE_URL = 'https://www.google.com/images/spin-32.gif?a';

  // observable that is updated when the auth state changes
  user$ = user(this.auth);
  currentUser: User | null = this.auth.currentUser;
  userSubscription: Subscription;
  
  constructor() {
    this.userSubscription = this.user$.subscribe((aUser: User | null) => {
        this.currentUser = aUser;
    });
  }

  // Login Friendly Chat.
  login() {}

  // Logout of Friendly Chat.
  logout() {}

  // Adds a text or image message to Cloud Firestore.
  addMessage = async (
    textMessage: string | null,
    imageUrl: string | null
  ): Promise<void | DocumentReference<DocumentData>> => {};

  // Saves a new message to Cloud Firestore.
  saveTextMessage = async (messageText: string) => {
    return this.addMessage(messageText, null);
  };

  // Loads chat messages history and listens for upcoming ones.
  loadMessages = () => {
    return null as unknown;
  };

  // Saves a new message containing an image in Firebase.
  // This first saves the image in Firebase storage.
  saveImageMessage = async (file: any) => {};

  async updateData(path: string, data: any) {}

  async deleteData(path: string) {}

  getDocData(path: string) {}

  getCollectionData(path: string) {}

  async uploadToStorage(
    path: string,
    input: HTMLInputElement,
    contentType: any
  ) {
    return null;
  }
  // Requests permissions to show notifications.
  requestNotificationsPermissions = async () => {};

  saveMessagingDeviceToken = async () => {};
}



================================================
File: codelabs/codelab-friendlychat-web/steps/src/assets/.gitkeep
================================================



================================================
File: codelabs/codelab-friendlychat-web/steps/src/environments/environment.ts
================================================
export const environment = {
  firebase: {
    apiKey: 'API_KEY',
    authDomain: 'PROJECT_ID.firebaseapp.com',
    databaseURL: 'https://PROJECT_ID.firebaseio.com',
    projectId: 'PROJECT_ID',
    storageBucket: 'PROJECT_ID.appspot.com',
    messagingSenderId: 'SENDER_ID',
    appId: 'APP_ID',
    measurementId: 'G-MEASUREMENT_ID',
  },
};



================================================
File: codelabs/codelab-friendlyeats-android/steps/index.lab.md
================================================
---
id: firestore-android
summary: In this codelab you'll learn how to build an Android app that uses Cloud Firestore.
status: [published]
categories: Firebase
tags: devfest-lon,firebase17,io2018,kiosk,tag-cloud,tag-firebase,web
feedback link: https://github.com/firebase/friendlyeats-android/issues

---

# Cloud Firestore Android Codelab

[Codelab Feedback](https://github.com/firebase/friendlyeats-android/issues)


## Overview
Duration: 01:00


### Goals

In this codelab you will build a restaurant recommendation app on Android backed by Cloud Firestore. You will learn how to:

* Read and write data to Firestore from an Android app
* Listen to changes in Firestore data in realtime
* Use Firebase Authentication and security rules to secure Firestore data
* Write complex Firestore queries

### Prerequisites

Before starting this codelab make sure you have:

* Android Studio **4.0** or higher
* An Android emulator with API **19** or higher
* Node.js version **10** or higher
* Java version **8** or higher


## Create a Firebase project

1. Sign into the  [Firebase console](https://firebase.google.com/) with your Google account.
2. In the  [Firebase console](https://console.firebase.google.com), click **Add project**.
3. As shown in the screen capture below, enter a name for your Firebase project (for example, "Friendly Eats"), and click **Continue**.

<img src="img/9d2f625aebcab6af.png" alt="9d2f625aebcab6af.png"  width="399.19" />

4. You may be asked to enable Google Analytics, for the purposes of this codelab your selection does not matter.
5. After a minute or so, your Firebase project will be ready. Click **Continue**.

## Set up the sample project
Duration: 05:00

### Download the code

Run the following command to clone the sample code for this codelab.  This will create a folder called `friendlyeats-android` on your machine:

```console
$ git clone https://github.com/firebase/friendlyeats-android
```

If you don't have git on your machine, you can also download the code directly from GitHub.

### Add Firebase configuration

1. In the  [Firebase console](https://console.firebase.google.com), select **Project Overview** in the left nav. Click the **Android** button to select the platform.  When prompted for a package name use `com.google.firebase.example.fireeats`

<img src="img/73d151ed16016421.png" alt="73d151ed16016421.png"  width="460.50" />

2. Click **Register App** and follow the instructions to download the `google-services.json` file, and move it into the `app/` folder of the code you just downloaded. Then click **Next**.

### Import the project

Open Android Studio. Click **File** > **New** > **Import Project** and select the **friendlyeats-android** folder.

## Set up the Firebase Emulators
Duration: 05:00

In this codelab you'll use the [Firebase Emulator Suite](https://firebase.google.com/docs/emulator-suite) to locally emulate Cloud Firestore and other Firebase services. This provides a safe, fast, and no-cost local development environment to build your app.

### Install the Firebase CLI

First you will need to install the [Firebase CLI](https://firebase.google.com/docs/cli). If you are using macOS or Linux, you can run the following cURL command:

```console
curl -sL https://firebase.tools | bash
```

If you are using Windows, read the [installation instructions](https://firebase.google.com/docs/cli#install-cli-windows) to get a standalone binary or to install via `npm`.

Once you've installed the CLI, running `firebase --version` should report a version of `9.0.0` or higher:

```console
$ firebase --version
9.0.0
```

### Log In

Run `firebase login` to connect the CLI to your Google account. This will open a new browser window to complete the login process. Make sure to choose the same account you used when creating your Firebase project earlier.

### Link your project

From within the `friendlyeats-android` folder run `firebase use --add` to connect your local project to your Firebase project. Follow the prompts to select the project you created earlier and if asked to choose an alias enter `default`.

## Run the app
Duration: 02:00

Now it's time to run the Firebase Emulator Suite and the FriendlyEats Android app for the first time.

### Run the emulators

In your terminal from within the `friendlyeats-android` directory run `firebase emulators:start` to start up the Firebase Emulators. You should see logs like this:

```console
$ firebase emulators:start
i  emulators: Starting emulators: auth, firestore
i  firestore: Firestore Emulator logging to firestore-debug.log
i  ui: Emulator UI logging to ui-debug.log

┌─────────────────────────────────────────────────────────────┐
│ ✔  All emulators ready! It is now safe to connect your app. │
│ i  View Emulator UI at http://localhost:4000                │
└─────────────────────────────────────────────────────────────┘

┌────────────────┬────────────────┬─────────────────────────────────┐
│ Emulator       │ Host:Port      │ View in Emulator UI             │
├────────────────┼────────────────┼─────────────────────────────────┤
│ Authentication │ localhost:9099 │ http://localhost:4000/auth      │
├────────────────┼────────────────┼─────────────────────────────────┤
│ Firestore      │ localhost:8080 │ http://localhost:4000/firestore │
└────────────────┴────────────────┴─────────────────────────────────┘
  Emulator Hub running at localhost:4400
  Other reserved ports: 4500

Issues? Report them at https://github.com/firebase/firebase-tools/issues and attach the *-debug.log files.
```

You now have a complete local development environment running on your machine! Make sure to leave this command running for the rest of the codelab, your Android app will need to connect to the emulators.

### Connect app to the Emulators

Open the files `util/FirestoreInitializer.kt` and `util/AuthInitializer.kt` in Android Studio.
These files contain the logic to connect the Firebase SDKs to the local emulators running on your machine, upon application startup.

On the `create()` method of the `FirestoreInitializer` class, examine this piece of code:

```kotlin
    // Use emulators only in debug builds
    if (BuildConfig.DEBUG) {
        firestore.useEmulator(FIRESTORE_EMULATOR_HOST, FIRESTORE_EMULATOR_PORT)
    }
```

We are using `BuildConfig` to make sure we only connect to the emulators when our app is running in `debug` mode. When we compile the app in `release` mode this condition will be false.

We can see that it is using the `useEmulator(host, port)` method to connect the Firebase SDK to the local Firestore emulator. Throughout the app we will use `FirebaseUtil.getFirestore()` to access this instance of `FirebaseFirestore` so we are sure that we're always connecting to the Firestore emulator when running in `debug` mode.

### Run the app

If you have added the `google-services.json` file properly, the project should now compile. In Android Studio click **Build** &gt; **Rebuild Project** and ensure that there are no remaining errors.

In Android Studio **Run** the app on your Android emulator.  At first you will be presented with a "Sign in" screen.  You can use any email and password to sign into the app. This sign in process is connecting to the Firebase Authentication emulator, so no real credentials are being transmitted.

> aside negative
>
> Note: In order for your app to communicate with the Firebase Emulator Suite, it must be running on an Android Emulator, not a real Android device. This will allow the app to communicate with the Firebase Emulator Suite on `localhost`.

Now open the Emulators UI by navigating to [http://localhost:4000](http://localhost:4000) in your web browser. Then click on the **Authentication** tab and you should see the account you just created:

<img src="img/emulators-auth.png" alt="Firebase Auth Emulator"  width="600" />

Once you have completed the sign in process you should see the app home screen:

<img src="img/de06424023ffb4b9.png" alt="de06424023ffb4b9.png"  width="238.28" />

Soon we will add some data to populate the home screen.


## Write data to Firestore
Duration: 05:00


In this section we will write some data to Firestore so that we can populate the currently empty home screen.

The main model object in our app is a restaurant (see `model/Restaurant.kt`).  Firestore data is split into documents, collections, and subcollections.  We will store each restaurant as a document in a top-level collection called `"restaurants"`.  To learn more about the Firestore data model, read about documents and collections in [the documentation](https://firebase.google.com/docs/firestore/data-model).

For demonstration purposes, we will add functionality in the app to create ten random restaurants when we click the "Add Random Items" button in the overflow menu.  Open the file `MainFragment.kt` and replace the content in the `onAddItemsClicked()` method with:

```kotlin
    private fun onAddItemsClicked() {
        val restaurantsRef = firestore.collection("restaurants")
        for (i in 0..9) {
            // Create random restaurant / ratings
            val randomRestaurant = RestaurantUtil.getRandom(requireContext())

            // Add restaurant
            restaurantsRef.add(randomRestaurant)
        }
    }
```

There are a few important things to note about the code above:

* We started by getting a reference to the `"restaurants"` collection. Collections are created implicitly when documents are added, so there was no need to create the collection before writing data.
* Documents can be created using Kotlin data classes, which we use to create each Restaurant doc.
* The `add()` method adds a document to a collection with an auto-generated ID, so we did not need to specify a unique ID for each Restaurant.

Now run the app again and click the "Add Random Items" button in the overflow menu (at the top right corner) to invoke the code you just wrote:

<img src="img/95691e9b71ba55e3.png" alt="95691e9b71ba55e3.png"  width="285.08" />

Now open the Emulators UI by navigating to [http://localhost:4000](http://localhost:4000) in your web browser. Then click on the **Firestore** tab and you should see the data you just added:

<img src="img/emulators-firebase.png" alt="Firebase Auth Emulator"  width="600" />

This data is 100% local to your machine. In fact, your real project doesn't even contain a Firestore database yet! This means it's safe to experiment with modifying and deleting this data without consequence.

Congratulations, you just wrote data to Firestore! In the next step we'll learn how to display this data in the app.


## Display data from Firestore
Duration: 10:00


In this step we will learn how to retrieve data from Firestore and display it in our app. The first step to reading data from Firestore is to create a `Query`. Open the file `MainFragment.kt` and add the following code to the beginning of the `onViewCreated()` method:

```kotlin
        // Firestore
        firestore = Firebase.firestore

        // Get the 50 highest rated restaurants
        query = firestore.collection("restaurants")
            .orderBy("avgRating", Query.Direction.DESCENDING)
            .limit(LIMIT.toLong())
```

Now we want to listen to the query, so that we get all matching documents and are notified of future updates in real time.  Because our eventual goal is to bind this data to a `RecyclerView`, we need to create a `RecyclerView.Adapter` class to listen to the data.

Open the `FirestoreAdapter` class, which has been partially implemented already.  First, let's make the adapter implement `EventListener` and define the `onEvent` function so that it can receive updates to a Firestore query:

```kotlin
abstract class FirestoreAdapter<VH : RecyclerView.ViewHolder>(private var query: Query?) :
        RecyclerView.Adapter<VH>(),
        EventListener<QuerySnapshot> { // Add this implements
    
    // ...

    // Add this method
    override fun onEvent(documentSnapshots: QuerySnapshot?, e: FirebaseFirestoreException?) {
        
        // Handle errors
        if (e != null) {
            Log.w(TAG, "onEvent:error", e)
            return
        }

        // Dispatch the event
        if (documentSnapshots != null) {
            for (change in documentSnapshots.documentChanges) {
                // snapshot of the changed document
                when (change.type) {
                    DocumentChange.Type.ADDED -> {
                        // TODO: handle document added
                    }
                    DocumentChange.Type.MODIFIED -> {
                        // TODO: handle document changed
                    }
                    DocumentChange.Type.REMOVED -> {
                        // TODO: handle document removed
                    }
                }
            }
        }

        onDataChanged()
    }
    
    // ...
}
```

On initial load the listener will receive one `ADDED` event for each new document.  As the result set of the query changes over time the listener will receive more events containing the changes.  Now let's finish implementing the listener.  First add three new methods: `onDocumentAdded`, `onDocumentModified`, and `onDocumentRemoved`:

```kotlin
    private fun onDocumentAdded(change: DocumentChange) {
        snapshots.add(change.newIndex, change.document)
        notifyItemInserted(change.newIndex)
    }

    private fun onDocumentModified(change: DocumentChange) {
        if (change.oldIndex == change.newIndex) {
            // Item changed but remained in same position
            snapshots[change.oldIndex] = change.document
            notifyItemChanged(change.oldIndex)
        } else {
            // Item changed and changed position
            snapshots.removeAt(change.oldIndex)
            snapshots.add(change.newIndex, change.document)
            notifyItemMoved(change.oldIndex, change.newIndex)
        }
    }

    private fun onDocumentRemoved(change: DocumentChange) {
        snapshots.removeAt(change.oldIndex)
        notifyItemRemoved(change.oldIndex)
    }
```

Then call these new methods from `onEvent`:

```kotlin
    override fun onEvent(documentSnapshots: QuerySnapshot?, e: FirebaseFirestoreException?) {

        // Handle errors
        if (e != null) {
            Log.w(TAG, "onEvent:error", e)
            return
        }

        // Dispatch the event
        if (documentSnapshots != null) {
            for (change in documentSnapshots.documentChanges) {
                // snapshot of the changed document
                when (change.type) {
                    DocumentChange.Type.ADDED -> {
                        onDocumentAdded(change) // Add this line
                    }
                    DocumentChange.Type.MODIFIED -> {
                        onDocumentModified(change) // Add this line
                    }
                    DocumentChange.Type.REMOVED -> {
                        onDocumentRemoved(change) // Add this line
                    }
                }
            }
        }

        onDataChanged()
    }
```

Finally implement the `startListening()` method to attach the listener:

```kotlin
    fun startListening() {
        if (registration == null) {
            registration = query.addSnapshotListener(this)
        }
    }
```

> aside positive
>
> **Note**: this codelab demonstrates the real-time capabilities of Firestore, but it's also simple to fetch data without a listener.  You can call `get()` on any query or reference to fetch a data snapshot.

Now the app is fully configured to read data from Firestore.  **Run** the app again and you should see the restaurants you added in the previous step:

<img src="img/9e45f40faefce5d0.png" alt="9e45f40faefce5d0.png"  width="238.58" />

Now go back to the Emulator UI in your browser and edit one of the restaurant names.  You should see it change in the app almost instantly!


## Sort and filter data
Duration: 05:00


The app currently displays the top-rated restaurants across the entire collection, but in a real restaurant app the user would want to sort and filter the data.  For example the app should be able to show "Top seafood restaurants in Philadelphia" or "Least expensive pizza".

Clicking white bar at the top of the app brings up a filters dialog.  In this section we'll use Firestore queries to make this dialog work:

<img src="img/67898572a35672a5.png" alt="67898572a35672a5.png"  width="359.50" />

Let's edit the `onFilter()` method of `MainFragment.kt`.  This method accepts a `Filters` object which is a helper object we created to capture the output of the filters dialog.  We will change this method to construct a query from the filters:

```kotlin
    override fun onFilter(filters: Filters) {
        // Construct query basic query
        var query: Query = firestore.collection("restaurants")

        // Category (equality filter)
        if (filters.hasCategory()) {
            query = query.whereEqualTo(Restaurant.FIELD_CATEGORY, filters.category)
        }

        // City (equality filter)
        if (filters.hasCity()) {
            query = query.whereEqualTo(Restaurant.FIELD_CITY, filters.city)
        }

        // Price (equality filter)
        if (filters.hasPrice()) {
            query = query.whereEqualTo(Restaurant.FIELD_PRICE, filters.price)
        }

        // Sort by (orderBy with direction)
        if (filters.hasSortBy()) {
            query = query.orderBy(filters.sortBy.toString(), filters.sortDirection)
        }

        // Limit items
        query = query.limit(LIMIT.toLong())

        // Update the query
        adapter.setQuery(query)

        // Set header
        binding.textCurrentSearch.text = HtmlCompat.fromHtml(
            filters.getSearchDescription(requireContext()),
            HtmlCompat.FROM_HTML_MODE_LEGACY
        )
        binding.textCurrentSortBy.text = filters.getOrderDescription(requireContext())

        // Save filters
        viewModel.filters = filters
    }
```

In the snippet above we build a `Query` object by attaching `where` and `orderBy` clauses to match the given filters.

**Run** the app again and select the following filter to show the most popular low-price restaurants:

<img src="img/7a67a8a400c80c50.png" alt="7a67a8a400c80c50.png"  width="358.50" />

> aside negative
>
> A complex query like this one requires a **compound index**. When using the Firestore emulator all queries are allowed but if you tried to run this app with a real database you'd get the following warnings in the logs:
>
> ```console
> W/Firestore Adapter: onEvent:error
> com.google.firebase.firestore.FirebaseFirestoreException: FAILED_PRECONDITION: The query requires an index. You can create it here: https://console.firebase.google.com/project/firestore-codelab-android/database/firestore/indexes?create_index=EgtyZXN0YXVyYW50cxoJCgVwcmljZRACGg4KCm51bVJhdGluZ3MQAxoMCghfX25hbWVfXxAD
>     at com.google.android.gms.internal.ajs.zze(Unknown Source)
>    // ...
> ```
>
> There are two ways to add an index to your app:
>
>  1. Click the link in the error message to create it interactively.
>  1. Add the index to `firebase.indexes.json` and deploy it with the Firebase CLI.
>
> At the end of this codelab we will walk through this process.

You should now see a filtered list of restaurants containing only low-price options:

<img src="img/a670188398c3c59.png" alt="a670188398c3c59.png"  width="263.21" />


If you've made it this far, you have now built a fully functioning restaurant recommendation viewing app on Firestore!  You can now sort and filter restaurants in real time.  In the next few sections we'll add reviews to the restaurants and add security rules to the app.


## Organize data in subcollections
Duration: 05:00


In this section we'll add ratings to the app so users can review their favorite (or least favorite) restaurants.

### Collections and subcollections

So far we have stored all restaurant data in a top-level collection called "restaurants".  When a user rates a restaurant we want to add a new `Rating` object to the restaurants.  For this task we will use a subcollection.  You can think of a subcollection as a collection that is attached to a document.  So each restaurant document will have a ratings subcollection full of rating documents.  Subcollections help organize data without bloating our documents or requiring complex queries.

To access a subcollection, call `.collection()` on the parent document:

```kotlin
val subRef = firestore.collection("restaurants")
        .document("abc123")
        .collection("ratings")
```

You can access and query a subcollection just like with a top-level collection, there are no size limitations or performance changes.  You can read more about the Firestore data model  [here](https://firebase.google.com/docs/firestore/data-model).

### Writing data in a transaction

Adding a `Rating` to the proper subcollection only requires calling `.add()`, but we also need to update the `Restaurant` object's average rating and number of ratings to reflect the new data.  If we use separate operations to make these two changes there are a number of race conditions that could result in stale or incorrect data.

To ensure that ratings are added properly, we will use a transaction to add ratings to a restaurant.  This transaction will perform a few actions:

* Read the restaurant's current rating and calculate the new one
* Add the rating to the subcollection
* Update the restaurant's average rating and number of ratings

Open `RestaurantDetailFragment.kt` and implement the `addRating` function:

```kotlin
    private fun addRating(restaurantRef: DocumentReference, rating: Rating): Task<Void> {
        // Create reference for new rating, for use inside the transaction
        val ratingRef = restaurantRef.collection("ratings").document()

        // In a transaction, add the new rating and update the aggregate totals
        return firestore.runTransaction { transaction ->
            val restaurant = transaction.get(restaurantRef).toObject<Restaurant>()
                ?: throw Exception("Restaurant not found at ${restaurantRef.path}")

            // Compute new number of ratings
            val newNumRatings = restaurant.numRatings + 1

            // Compute new average rating
            val oldRatingTotal = restaurant.avgRating * restaurant.numRatings
            val newAvgRating = (oldRatingTotal + rating.rating) / newNumRatings

            // Set new restaurant info
            restaurant.numRatings = newNumRatings
            restaurant.avgRating = newAvgRating

            // Commit to Firestore
            transaction.set(restaurantRef, restaurant)
            transaction.set(ratingRef, rating)

            null
        }
    }
```

The `addRating()` function returns a `Task` representing the entire transaction.  In the `onRating()` function listeners are added to the task to respond to the result of the transaction.

Now **Run** the app again and click on one of the restaurants, which should bring up the restaurant detail screen.  Click the **+** button to start adding a review. Add a review by picking a number of stars and entering some text.

<img src="img/78fa16cdf8ef435a.png" alt="78fa16cdf8ef435a.png"  width="204.83" />

Hitting **Submit** will kick off the transaction. When the transaction completes, you will see your review displayed below and an update to the restaurant's review count:

<img src="img/f9e670f40bd615b0.png" alt="f9e670f40bd615b0.png"  width="203.42" />

Congrats! You now have a social, local, mobile restaurant review app built on Cloud Firestore.  I hear those are very popular these days.


## Secure your data
Duration: 05:00

So far we have not considered the security of this application. How do we know that users can only read and write the correct own data? Firestore databases are secured by a configuration file called [Security Rules](https://firebase.google.com/docs/firestore/security/get-started).

Open the `firestore.rules` file, you should see the following:

```
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /{document=**} {
      //
      // WARNING: These rules are insecure! We will replace them with
      // more secure rules later in the codelab
      //
      allow read, write: if request.auth != null;
    }
  }
}
```

> aside negative
>
> **Warning**: the rules above are extremely insecure! Never deploy a real Firebase app without writing custom security rules.

Let's change these rules to prevent unwanted data acesss or changes, open the `firestore.rules` file and replace the content with the following:

```
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Determine if the value of the field "key" is the same
    // before and after the request.
    function isUnchanged(key) {
      return (key in resource.data)
        && (key in request.resource.data)
        && (resource.data[key] == request.resource.data[key]);
    }

    // Restaurants
    match /restaurants/{restaurantId} {
      // Any signed-in user can read
      allow read: if request.auth != null;

      // Any signed-in user can create
      // WARNING: this rule is for demo purposes only!
      allow create: if request.auth != null;

      // Updates are allowed if no fields are added and name is unchanged
      allow update: if request.auth != null
                    && (request.resource.data.keys() == resource.data.keys())
                    && isUnchanged("name");

      // Deletes are not allowed.
      // Note: this is the default, there is no need to explicitly state this.
      allow delete: if false;

      // Ratings
      match /ratings/{ratingId} {
        // Any signed-in user can read
        allow read: if request.auth != null;

        // Any signed-in user can create if their uid matches the document
        allow create: if request.auth != null
                      && request.resource.data.userId == request.auth.uid;

        // Deletes and updates are not allowed (default)
        allow update, delete: if false;
      }
    }
  }
}
```

These rules restrict access to ensure that clients only make safe changes.  For example updates to a restaurant document can only change the ratings, not the name or any other immutable data.  Ratings can only be created if the user ID matches the signed-in user, which prevents spoofing.

> aside positive
>
> When you save the `firestore.rules` file the Firestore emulator will automatically hot reload the new rules and apply them to future requests, there is no need to restart the emulators.

To read more about Security Rules, visit  [the documentation](https://firebase.google.com/docs/firestore/security/get-started).


## Conclusion
Duration: 01:00


You have now created a fully-featured app on top of Firestore.  You learned about the most important Firestore features including:

* Documents and collections
* Reading and writing data
* Sorting and filtering with queries
* Subcollections
* Transactions

### Learn More

To keep learning about Firestore, here are some good places to get started:

*  [Choose a data structure](https://firebase.google.com/docs/firestore/manage-data/structure-data)
*  [Simple and compound queries](https://firebase.google.com/docs/firestore/query-data/queries)

The restaurant app in this codelab was based on the "Friendly Eats" example application.  You can browse the source code for that app  [here](https://github.com/firebase/quickstart-android).

### Optional: Deploy to production

So far this app has only used the Firebase Emulator Suite. If you want to learn how to deploy this app to a real Firebase project, continue on to the next step.


## (Optional) Deploy your app
Duration: 05:00

So far this app has been entirely local, all of the data is contained in the Firebase Emulator Suite. In this section you will learn how to configure your Firebase project so that this app will work in production.

> aside positive
>
> All of the products used in this codelab are available on the [Spark plan](https://firebase.google.com/pricing/).

### Firebase Authentication

In the Firebase console go to the **Authentication** section and click **Get started**. Navigate to the **Sign-in method** tab and select the **Email/Password** option from **Native providers**.

Enable the **Email/Password** sign-in method and click **Save**.

<img src="img/sign-in-providers.png" alt="sign-in-providers.png"  width="624.00" />


### Firestore

#### Create database

Navigate to the **Firestore Database** section of the console and click **Create Database**:

1. When prompted about Security Rules choose to start in **Production Mode**, we'll update those rules soon.
1. Choose the database location that you'd like to use for your app. Note that selecting a database location is a _permanent_ decision and to change it you will have to create a new project. For more information on choosing a project location, see the [documentation](https://firebase.google.com/docs/projects/locations).

#### Deploy Rules

To deploy the Security Rules you wrote earlier, run the following command in the codelab directory:

```console
$ firebase deploy --only firestore:rules
```

This will deploy the contents of `firestore.rules` to your project, which you can confirm by navigating to the **Rules** tab in the console.

#### Deploy Indexes

The FriendlyEats app has complex sorting and filtering which requires a number of custom compound indexes. These can be created by hand in the Firebase console but it is simpler to write their definitions in the `firestore.indexes.json` file and deploy them using the Firebase CLI.

If you open the `firestore.indexes.json` file you will see that the required indexes have already been provided:

```json
{
  "indexes": [
    {
      "collectionId": "restaurants",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "city", "mode": "ASCENDING" },
        { "fieldPath": "avgRating", "mode": "DESCENDING" }
      ]
    },
    {
      "collectionId": "restaurants",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "category", "mode": "ASCENDING" },
        { "fieldPath": "avgRating", "mode": "DESCENDING" }
      ]
    },
    {
      "collectionId": "restaurants",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "price", "mode": "ASCENDING" },
        { "fieldPath": "avgRating", "mode": "DESCENDING" }
      ]
    },
    {
      "collectionId": "restaurants",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "city", "mode": "ASCENDING" },
        { "fieldPath": "numRatings", "mode": "DESCENDING" }
      ]
    },
    {
      "collectionId": "restaurants",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "category", "mode": "ASCENDING" },
        { "fieldPath": "numRatings", "mode": "DESCENDING" }
      ]
    },
    {
      "collectionId": "restaurants",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "price", "mode": "ASCENDING" },
        { "fieldPath": "numRatings", "mode": "DESCENDING" }
      ]
    },
    {
      "collectionId": "restaurants",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "city", "mode": "ASCENDING" },
        { "fieldPath": "price", "mode": "ASCENDING" }
      ]
    },
    {
      "collectionId": "restaurants",
      "fields": [
        { "fieldPath": "category", "mode": "ASCENDING" },
        { "fieldPath": "price", "mode": "ASCENDING" }
      ]
    }
  ],
  "fieldOverrides": []
}
```

To deploy these indexes run the following command:

```console
$ firebase deploy --only firestore:indexes
```

Note that index creation is not instantaneous, you can monitor the progress in the Firebase console.

### Configure the app

In the `util/FirestoreInitializer.kt` and `util/AuthInitializer.kt` files we configured the Firebase SDK to connect to the emulators when in debug mode:

```kotlin
    override fun create(context: Context): FirebaseFirestore {
        val firestore = Firebase.firestore
        // Use emulators only in debug builds
        if (BuildConfig.DEBUG) {
            firestore.useEmulator(FIRESTORE_EMULATOR_HOST, FIRESTORE_EMULATOR_PORT)
        }
        return firestore
    }
```

If you would like to test your app with your real Firebase project you can either:

1. Build the app in release mode and run it on a device.
1. Temporarily replace `BuildConfig.DEBUG` with `false` and run the app again.

Note that you may need to **Sign Out** of the app and sign in again in order to properly connect to production.




================================================
File: codelabs/codelab-friendlyeats-web/vanilla-js/steps/index.lab.md
================================================
---
id: firestore-web
summary: In this codelab, you'll learn how to build a web app that uses Cloud Firestore.
status: [published]
authors: Abe Haskins, Nicolas Garnier
categories: Firebase
tags: devfest18,firebase17,firebase18,gdd17,io2018,jsconfeu,kiosk,tag-firebase,tag-web,web
feedback link: https://github.com/firebase/friendlyeats-web/issues
source: 1BWtoYJ4wh9MAgVx6KsIhEnvG3KqRyjkqNS0DscWA5xQ
duration: 47

---

# Cloud Firestore Web Codelab

[Codelab Feedback](https://github.com/firebase/friendlyeats-web/issues)


## Overview
Duration: 01:00

> aside negative
This codelab uses v8 of the Firebase JavaScript SDKs. It is recommended that you use
v9 for your applications. This codelab will soon be updated to v9. The concepts
described in this codelab are still valid. See Firebase documentation to
[learn more about SDK versions 8 and 9](https://firebase.google.com/docs/web/learn-more?authuser=0#modular-version).

### Goals

In this codelab, you'll build a restaurant recommendation web app powered by  [Cloud Firestore](https://firebase.google.com/docs/firestore/). 

<img src="img/img5.png" alt="img5.png"  width="624.00" />

#### **What you'll learn**

* Read and write data to Cloud Firestore from a web app
* Listen to changes in Cloud Firestore data in real time
* Use Firebase Authentication and security rules to secure Cloud Firestore data
* Write complex Cloud Firestore queries

#### **What you'll need**

Before starting this codelab, make sure that you've installed:

*  [npm](https://www.npmjs.com/) which typically comes with  [Node.js](https://nodejs.org/en/) - Node v8 is recommended
* The IDE/text editor of your choice, such as  [WebStorm](https://www.jetbrains.com/webstorm),  [Atom](https://atom.io/),  [VS Code](https://code.visualstudio.com/), or  [Sublime](https://www.sublimetext.com/)

> aside positive
> 
> **Note**:  Although Node.js is a requirement for running and testing our app during development, the final application will not be dependent on Node.js.


## Create and set up a Firebase project
Duration: 05:00


### Create a Firebase project

1. In the  [Firebase console](https://console.firebase.google.com), click **Add project**, then name the Firebase project **FriendlyEats**.

> Remember the Project ID for your Firebase project.

2. Click **Create project**.

> aside positive
> 
> **Important**:  Your Firebase project will be named **FriendlyEats**, but Firebase will automatically assign it a unique Project ID in the form **friendlyeats-1234**.  This unique identifier is how your project is actually identified (including in the CLI), whereas *FriendlyEats* is simply a display name.

The application that we're going to build uses a few Firebase services available on the web:

* **Firebase Authentication** to easily identify your users
* **Cloud Firestore** to save structured data on the Cloud and get instant notification when the data is updated
* **Firebase Hosting** to host and serve your static assets

For this specific codelab, we've already configured Firebase Hosting.  However, for Firebase Auth and Cloud Firestore,  we'll walk you through the configuration and enabling of the services using the Firebase console.

### Enable Anonymous Auth

Although authentication isn't the focus of this codelab, it's important to have some form of authentication in our app. We'll use **Anonymous login** - meaning that the user will be silently signed in without being prompted.

You'll need to enable **Anonymous login.**

1. In the Firebase console, locate the **Build** section in the left nav.
2. Click **Authentication**, then click the **Sign-in method** tab (or [click here](https://console.firebase.google.com/project/_/authentication/providers) to go directly there).
3. Enable the **Anonymous** Sign-in Provider, then click **Save**.

<img src="img/img7.png" alt="img7.png"  width="624.00" />

This will allow the application to silently sign in your users when they access the web app. Feel free to read the  [Anonymous Authentication documentation](https://firebase.google.com/docs/auth/web/anonymous-auth) to learn more.

### Enable Cloud Firestore

The app uses Cloud Firestore to save and receive restaurant information and ratings.

You'll need to enable Cloud Firestore.  In the Firebase console's **Build** section, click **Firestore Database**. Click **Create database** in the Cloud Firestore pane.

Access to data in Cloud Firestore is controlled by Security Rules.  We'll talk more about rules later in this codelab but first we need to set some basic rules on our data to get started.  In the  [Rules tab](https://console.firebase.google.com/project/_/database/firestore/rules) of the Firebase console add the following rules and then click **Publish**.

```console
service cloud.firestore {
  match /databases/{database}/documents {
    match /{document=**} {
      //
      // WARNING: These rules are insecure! We will replace them with
      // more secure rules later in the codelab
      //
      allow read, write: if request.auth != null;
    }
  }
}
```

The rules above restrict data access to users who are signed in, which prevents unauthenticated users from reading or writing.  This is better than allowing public access but is still far from secure, we will improve these rules later in the codelab.


## Get the sample code
Duration: 02:00


Clone the  [GitHub repository](https://github.com/firebase/friendlyeats-web) from the command line:

```console
git clone https://github.com/firebase/friendlyeats-web
```

The sample code should have been cloned into the 📁`friendlyeats-web` directory. From now on, make sure to run all your commands from this directory: 

```console
cd friendlyeats-web
```

#### **Import the starter app**

Using your IDE (WebStorm, Atom, Sublime, Visual Studio Code...) open or import the 📁`friendlyeats-web` directory. This directory contains the starting code for the codelab which consists of a not-yet functional restaurant recommendation app. We'll make it functional throughout this codelab so you will need to edit code in that directory soon.


## Install the Firebase Command Line Interface
Duration: 02:00


The Firebase Command Line Interface (CLI) allows you to serve your web app locally and deploy your web app to Firebase Hosting.

> aside positive
> 
> **Note**:  To install the CLI, you need to install  [npm](https://www.npmjs.com/) which typically comes with  [NodeJS](https://nodejs.org/en/).

1. Install the CLI by running the following npm command:

```console
npm -g install firebase-tools
```

> aside negative
> 
> Doesn't work? You may need to  [change npm permissions.](https://docs.npmjs.com/getting-started/fixing-npm-permissions)

2. Verify that the CLI has been installed correctly by running the following command:

```console
firebase --version
```

Make sure the version of the Firebase CLI is v7.4.0 or later.

3. Authorize the Firebase CLI by running the following command:

```console
firebase login
```

We've set up the web app template to pull your app's configuration for Firebase Hosting from your app's local directory and files. But to do this, we need to associate your app with your Firebase project.

4. Make sure that your command line is accessing your app's local directory.

5. Associate your app with your Firebase project by running the following command:

```console
firebase use --add
```

6. When prompted, select your **Project ID**, then give your Firebase project an alias.

An alias is useful if you have multiple environments (production, staging, etc). However, for this codelab, let's just use the alias of `default`.

7. Follow the remaining instructions in your command line.


## Run the local server
Duration: 01:00


We're ready to actually start work on our app! Let's run our app locally! 

1.  Run the following Firebase CLI command:

```console
firebase emulators:start --only hosting
```

2. Your command line should display the following response:

```console
hosting: Local server: http://localhost:5000
```

We're using the  [Firebase Hosting](https://firebase.google.com/docs/hosting/) emulator to serve our app locally. The web app should now be available from  [http://localhost:5000](http://localhost:5000).

3. Open your app at  [http://localhost:5000](http://localhost:5000).

You should see your copy of FriendlyEats which has been connected to your Firebase project.

The app has automatically connected to your Firebase project and silently signed you in as an anonymous user.

<img src="img/img2.png" alt="img2.png"  width="624.00" />


## Write data to Cloud Firestore
Duration: 05:00


In this section, we'll write some data to Cloud Firestore so that we can populate the app's UI. This can be done manually via the  [Firebase console](https://console.firebase.google.com), but we'll do it in the app itself to demonstrate a basic Cloud Firestore write.

### Data Model

Firestore data is split into collections, documents, fields, and subcollections. We will store each restaurant as a document in a top-level collection called `restaurants`.

<img src="img/img3.png" alt="img3.png"  width="333.60" />

Later, we'll store each review in a subcollection called `ratings` under each restaurant.

<img src="img/img4.png" alt="img4.png"  width="295.53" />

> aside positive
> 
> **Tip**: To learn more about the Firestore data model, read about documents and collections in  [the documentation](https://firebase.google.com/docs/firestore/data-model).

### Add restaurants to Firestore

The main model object in our app is a restaurant. Let's write some code that adds a restaurant document to the `restaurants` collection.

1. From your downloaded files, open `scripts/FriendlyEats.Data.js`.
2. Find the function `FriendlyEats.prototype.addRestaurant`.
3. Replace the entire function with the following code.

####  [FriendlyEats.Data.js](https://github.com/firebase/friendlyeats-web/blob/master/scripts/FriendlyEats.Data.js#L18-L22.js)

```console
FriendlyEats.prototype.addRestaurant = function(data) {
  var collection = firebase.firestore().collection('restaurants');
  return collection.add(data);
};
```

The code above adds a new document to the `restaurants` collection. The document data comes from a plain JavaScript object. We do this by first getting a reference to a Cloud Firestore collection `restaurants` then `add`'ing the data.

### Let's add restaurants!

1. Go back to your FriendlyEats app in your browser and refresh it.
2. Click **Add Mock Data**.

The app will automatically generate a random set of restaurants objects, then call your `addRestaurant` function. However, ***you won't yet see the data in your actual web app*** because we still need to implement *retrieving* the data (the next section of the codelab).

If you navigate to the  [Cloud Firestore tab](https://console.firebase.google.com/project/_/database/firestore/data) in the Firebase console, though, you should now see new documents in the `restaurants` collection!

<img src="img/img6.png" alt="img6.png"  width="624.00" />

Congratulations, you have just written data to Cloud Firestore from a web app!

In the next section, you'll learn how to retrieve data from Cloud Firestore and display it in your app.


## Display data from Cloud Firestore
Duration: 05:00


In this section, you'll learn how to retrieve data from Cloud Firestore and display it in your app. The two key steps are creating a query and adding a snapshot listener. This listener will be notified of all existing data that matches the query and will receive updates in real time.

First, let's construct the query that will serve the default, unfiltered list of restaurants.

1. Go back to the file `scripts/FriendlyEats.Data.js`.
2. Find the function `FriendlyEats.prototype.getAllRestaurants`.
3. Replace the entire function with the following code.

####  [FriendlyEats.Data.js](https://github.com/firebase/friendlyeats-web/blob/master/scripts/FriendlyEats.Data.js#L24-L28.js)

```console
FriendlyEats.prototype.getAllRestaurants = function(renderer) {
  var query = firebase.firestore()
      .collection('restaurants')
      .orderBy('avgRating', 'desc')
      .limit(50);

  this.getDocumentsInQuery(query, renderer);
};
```

In the code above, we construct a query which will retrieve up to 50 restaurants from the top-level collection named `restaurants`, which are ordered by the average rating (currently all zero). After we declared this query, we pass it to the `getDocumentsInQuery()` method which is responsible for loading and rendering the data.

We'll do this by adding a snapshot listener.

1. Go back to the file `scripts/FriendlyEats.Data.js`.
2. Find the function `FriendlyEats.prototype.getDocumentsInQuery`.
3. Replace the entire function with the following code.

####  [FriendlyEats.Data.js](https://github.com/firebase/friendlyeats-web/blob/master/scripts/FriendlyEats.Data.js#L30-L34.js)

```console
FriendlyEats.prototype.getDocumentsInQuery = function(query, renderer) {
  query.onSnapshot(function(snapshot) {
    if (!snapshot.size) return renderer.empty(); // Display "There are no restaurants".

    snapshot.docChanges().forEach(function(change) {
      if (change.type === 'removed') {
        renderer.remove(change.doc);
      } else {
        renderer.display(change.doc);
      }
    });
  });
};
```

In the code above, `query.onSnapshot` will trigger its callback every time there's a change to the result of the query.

* The first time, the callback is triggered with the entire result set of the query -- meaning the whole `restaurants` collection from Cloud Firestore. It then passes all the individual documents to the `renderer.display` function.
* When a document is deleted, `change.type` equals to `removed`. So in this case, we'll call a function that removes the restaurant from the UI.

Now that we've implemented both methods, refresh the app and verify that the restaurants we saw earlier in the Firebase console are now visible in the app. If you completed this section successfully, then your app is now reading and writing data with Cloud Firestore!

As your list of restaurants changes, this listener will keep updating automatically. Try going to the Firebase console and manually deleting a restaurant or changing its name - you'll see the changes show up on your site immediately!

> aside positive
> 
> **Note**:  It's also possible to fetch documents from Cloud Firestore once, rather than listening for real time updates using the `Query.get()` method.

<img src="img/img5.png" alt="img5.png"  width="624.00" />


## Get() data
Duration: 05:00


So far, we've shown how to use `onSnapshot` to retrieve updates in real time; however, that's not always what we want. Sometimes it makes more sense to only fetch the data once.

We'll want to implement a method that's triggered when a user clicks into a specific restaurant in your app.

1. Go back to your file `scripts/FriendlyEats.Data.js`.
2. Find the function `FriendlyEats.prototype.getRestaurant`.
3. Replace the entire function with the following code.

####  [FriendlyEats.Data.js](https://github.com/firebase/friendlyeats-web/blob/master/scripts/FriendlyEats.Data.js#L36-L40.js)

```console
FriendlyEats.prototype.getRestaurant = function(id) {
  return firebase.firestore().collection('restaurants').doc(id).get();
};
```

After you've implemented this method, you'll be able to view pages for each restaurant. Just click on a restaurant in the list and you should see the restaurant's details page:

<img src="img/img1.png" alt="img1.png"  width="624.00" />

For now, you can't add ratings as we still need to implement adding ratings later on in the codelab.


## Sort and filter data
Duration: 05:00


Currently, our app displays a list of restaurants, but there's no way for the user to filter based on their needs. In this section, you'll use Cloud Firestore's advanced querying to enable filtering.

Here's an example of a simple query to fetch all `Dim Sum` restaurants:

```console
var filteredQuery = query.where('category', '==', 'Dim Sum')
```

As its name implies, the `where()` method will make our query download only members of the collection whose fields meet the restrictions we set. In this case, it'll only download restaurants where `category` is `Dim Sum`.

In our app, the user can chain multiple filters to create specific queries, like "Pizza in San Francisco" or "Seafood in Los Angeles ordered by Popularity".

We'll create a method that builds up a query which will filter our restaurants based on multiple criteria selected by our users.

1. Go back to your file `scripts/FriendlyEats.Data.js`.
2. Find the function `FriendlyEats.prototype.getFilteredRestaurants`.
3. Replace the entire function with the following code.

####  [FriendlyEats.Data.js](https://github.com/firebase/friendlyeats-web/blob/master/scripts/FriendlyEats.Data.js#L42-L46.js)

```console
FriendlyEats.prototype.getFilteredRestaurants = function(filters, renderer) {
  var query = firebase.firestore().collection('restaurants');

  if (filters.category !== 'Any') {
    query = query.where('category', '==', filters.category);
  }

  if (filters.city !== 'Any') {
    query = query.where('city', '==', filters.city);
  }

  if (filters.price !== 'Any') {
    query = query.where('price', '==', filters.price.length);
  }

  if (filters.sort === 'Rating') {
    query = query.orderBy('avgRating', 'desc');
  } else if (filters.sort === 'Reviews') {
    query = query.orderBy('numRatings', 'desc');
  }

  this.getDocumentsInQuery(query, renderer);
};
```

The code above adds multiple `where` filters and a single `orderBy` clause to build a compound query based on user input. Our query will now only return restaurants that match the user's requirements.

Refresh your FriendlyEats app in your browser, then verify that you can filter by price, city, and category. While testing, you'll see errors in the JavaScript Console of your browser that look like this:

```console
The query requires an index. You can create it here: https://console.firebase.google.com/project/.../database/firestore/indexes?create_index=...
```

These errors are because Cloud Firestore requires indexes for most compound queries. Requiring indexes on queries keeps Cloud Firestore fast at scale.

Opening the link from the error message will automatically open the index creation UI in the Firebase console with the correct parameters filled in. In the next section, we'll write and deploy the indexes needed for this application.


## Deploy indexes
Duration: 05:00


If we don't want to explore every path in our app and follow each of the index creation links, we can easily deploy many indexes at once using the Firebase CLI.

1. In your app's downloaded local directory, you'll find a `firestore.indexes.json` file.

This file describes all the indexes needed for all the possible combinations of filters.

####  [firestore.indexes.json](https://github.com/firebase/friendlyeats-web/blob/master/firestore.indexes.json)

```console
{
 "indexes": [
   {
     "collectionGroup": "restaurants",
     "queryScope": "COLLECTION",
     "fields": [
       { "fieldPath": "city", "order": "ASCENDING" },
       { "fieldPath": "avgRating", "order": "DESCENDING" }
     ]
   },

   ...

 ]
}
```

2. Deploy these indexes with the following command:

```console
firebase deploy --only firestore:indexes
```

After a few minutes, your indexes will be live and the error messages will go away.

> aside positive
> 
> **Tip**:  To learn more about indexes in Cloud Firestore,  [visit the documentation](https://firebase.google.com/docs/firestore/query-data/indexing). 


## Write data in a transaction
Duration: 05:00


In this section, we'll add the ability for users to submit reviews to restaurants. So far, all of our writes have been atomic and relatively simple. If any of them errored, we'd likely just prompt the user to retry them or our app would retry the write automatically.

Our app will have many users who want to add a rating for a restaurant, so we'll need to coordinate multiple reads and writes. First the review itself has to be submitted, then the restaurant's rating `count` and `average rating` need to be updated. If one of these fails but not the other, we're left in an inconsistent state where the data in one part of our database doesn't match the data in another.

Fortunately, Cloud Firestore provides transaction functionality that allows us to perform multiple reads and writes in a single atomic operation, ensuring that our data remains consistent.

1. Go back to your file `scripts/FriendlyEats.Data.js`.
2. Find the function `FriendlyEats.prototype.addRating`.
3. Replace the entire function with the following code.

####  [FriendlyEats.Data.js](https://github.com/firebase/friendlyeats-web/blob/master/scripts/FriendlyEats.Data.js#L48-L52.js)

```console
FriendlyEats.prototype.addRating = function(restaurantID, rating) {
  var collection = firebase.firestore().collection('restaurants');
  var document = collection.doc(restaurantID);
  var newRatingDocument = document.collection('ratings').doc();

  return firebase.firestore().runTransaction(function(transaction) {
    return transaction.get(document).then(function(doc) {
      var data = doc.data();

      var newAverage =
          (data.numRatings * data.avgRating + rating.rating) /
          (data.numRatings + 1);

      transaction.update(document, {
        numRatings: data.numRatings + 1,
        avgRating: newAverage
      });
      return transaction.set(newRatingDocument, rating);
    });
  });
};
```

In the block above, we trigger a transaction to update the numeric values of `avgRating` and `numRatings` in the restaurant document. At the same time, we add the new `rating` to the `ratings` subcollection.

> aside positive
> 
> **Note**:  Adding ratings is a good example for using a transaction for this particular codelab. However, in a production app you should perform the average rating calculation on a trusted server to avoid manipulation by users. A good way to do this is to write the rating document directly from the client, then use  [Cloud Functions](https://firebase.google.com/docs/functions/) to update the new restaurant average rating.

> aside negative
> 
> **Warning**:  When a transaction fails on the server, the callback is also re-executed repeatedly. Never place logic that modifies app state inside the transaction callback.


## Secure your data
Duration: 05:00


At the beginning of this codelab, we set our app's security rules to completely open the database to any read or write. ***In a real application, we'd want to set much more fine-grained rules to prevent undesirable data access or modification.***

1. In the Firebase console's **Build** section, click **Firestore Database**.
2. Click the **Rules** tab in the Cloud Firestore section (or  [click here](https://console.firebase.google.com/project/_/database/firestore/rules) to go directly there).
3. Replace the defaults with the following rules, then click **Publish**.

####  [firestore.rules](https://github.com/firebase/friendlyeats-web/blob/master/firestore.rules)

```console
rules_version = '2';
service cloud.firestore {

  // Determine if the value of the field "key" is the same
  // before and after the request.
  function unchanged(key) {
    return (key in resource.data) 
      && (key in request.resource.data) 
      && (resource.data[key] == request.resource.data[key]);
  }

  match /databases/{database}/documents {
    // Restaurants:
    //   - Authenticated user can read
    //   - Authenticated user can create/update (for demo purposes only)
    //   - Updates are allowed if no fields are added and name is unchanged
    //   - Deletes are not allowed (default)
    match /restaurants/{restaurantId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null;
      allow update: if request.auth != null
                    && (request.resource.data.keys() == resource.data.keys()) 
                    && unchanged("name");
      
      // Ratings:
      //   - Authenticated user can read
      //   - Authenticated user can create if userId matches
      //   - Deletes and updates are not allowed (default)
      match /ratings/{ratingId} {
        allow read: if request.auth != null;
        allow create: if request.auth != null
                      && request.resource.data.userId == request.auth.uid;
      }
    }
  }
}
```

These rules restrict access to ensure that clients only make safe changes. For example: 

* Updates to a restaurant document can only change the ratings, not the name or any other immutable data.
* Ratings can only be created if the user ID matches the signed-in user, which prevents spoofing.

Alternatively to using the Firebase console, you can use the Firebase CLI to deploy rules to your Firebase project. The  [firestore.rules](https://github.com/firebase/friendlyeats-web/blob/master/firestore.rules) file in your working directory already contains the rules from above. To deploy these rules from your local filesystem (rather than using the Firebase console), you'd run the following command:

```console
firebase deploy --only firestore:rules
```

> aside positive
> 
> **Important**:  To learn more about security rules, have a look at the  [security rules documentation](https://firebase.google.com/docs/firestore/security/get-started).


## Conclusion
Duration: 01:00


In this codelab, you learned how to perform basic and advanced reads and writes with Cloud Firestore, as well as how to secure data access with security rules. You can find the full solution in the  [quickstarts-js repository](https://github.com/firebase/quickstart-js/tree/master/firestore).

To learn more about Cloud Firestore, visit the following resources:

*  [Introduction to Cloud Firestore](https://firebase.google.com/docs/firestore/)
*  [Choosing a Data Structure](https://firebase.google.com/docs/firestore/manage-data/structure-data)
*  [Cloud Firestore Web Samples](https://firebase.google.com/docs/firestore/client/samples-web)



================================================
File: codelabs/codelab-friendlyeats-web/vanilla-js/steps/.gitignore
================================================
firestore-web
!firestore-web/.firebaserc
!firestore-web/firebase.json




================================================
File: docs/flutter/README.md
================================================
# Flutter docs on firebase.google.com

This directory contains the source of the Flutter documentation on
https://firebase.google.com/docs/.

We welcome your corrections and improvements! If you're interested in
contributing, see [`CONTRIBUTING.md`](../CONTRIBUTING.md) for general
guidelines.

This file has some information on how our documentation is organized and some
non-standard extensions we use.

## Where are the Firestore docs?

Only the code snippets are on GitHub. You can find them in the
[`firebase/snippets-flutter`][snippets-repo] repository.

## Standalone files vs. page fragments

There are two kinds of source file for our docs:

- **Standalone files** map one-to-one to a single page on firebase.google.com.
  These files are mostly-standard Markdown with filenames that correspond with
  the URL at which they're eventually published.

  For example, the file [`read-and-write.md`](/docs/database/read-and-write.md)
  is published to https://firebase.google.com/docs/database/flutter/read-and-write.

  Standalone pages must have filenames that don't begin with an
  underscore (`_`).

- **Page fragments** are included in other pages. We use page fragments either
  to include common text in multiple pages or to help organize large pages.
  Like standalone files, page fragments are also mostly-standard Markdown, but
  their filenames often don't correspond with the URL at which they're
  eventually published.

  For example, the file [`_deobfuscated.md`](/docs/crashlytics/_deobfuscated.md)
  is published to https://firebase.google.com/docs/crashlytics/get-deobfuscated-reports?platform=flutter.

  Page fragments almost always have filenames that begin with an underscore
  (`_`).

## Non-standard Markdown

### File includes

> Probably not useful to you as a contributor, but documented FYI.

We use double angle brackets to include content from another file:

```
<<path/to/file>>
```

Note that the path is based on our internal directory structure, and not the
layout on GitHub. Also note that we sometimes use this to include non-Flutter
related content that's not on GitHub.

### Page metadata

> Probably not useful to you as a contributor, but documented FYI.

Every standalone page begins with the following header:

```
Project: /docs/_project.yaml
Book: /docs/_book.yaml
```

These are non-standard metadata declarations used by our internal publishing
system. There's nothing you can really do with this, but it has to be on every
standalone page.

## Non-standard Jinja

### includecode

Code snippets are included from standalone Dart files, which helps facilitate
automated testing. The following custom Jinja tag includes a code snippet into
a file:

```
{% includecode github_path="organization/repository/path/to/file" region_tag="tag_name" %}
```

For example, the file [`firestore.dart`][firestore-snippets] in the
[`firebase/snippets-flutter`][snippets-repo] repository contains a passage like
this:

```dart
void addData_addADocument() {
    // [START add_data_add_a_document]
    db.collection("cities").doc("new-city-id").set({"name": "Chicago"});
    // [END add_data_add_a_document]
}
```

To include the line between the `START` and `END` tags in a page, do the
following:

```
{% includecode
   github_path="firebase/snippets-flutter/packages/firebase_snippets_app/lib/snippets/firestore.dart"
   region_tag="add_data_add_a_document"
   adjust_indentation="auto" %}
```

To update a snippet, submit a PR to the [`snippets-flutter` repo][snippets-repo].

[firestore-snippets]: https://github.com/firebase/snippets-flutter/blob/main/packages/firebase_snippets_app/lib/snippets/firestore.dart
[snippets-repo]: https://github.com/firebase/snippets-flutter/



================================================
File: docs/flutter/analytics/_events.md
================================================
{# This content gets published to the following location:               #}
{#   https://firebase.google.com/docs/analytics/events?platform=flutter #}

Analytics automatically logs some
[events](https://support.google.com/analytics/answer/9234069) for you; you don't
need to add any code to receive them. If your app needs to collect additional
data, you can log up to 500 different Analytics Event *types* in your app.
There is no limit on the total volume of events your app logs. Note that event
names are case-sensitive and that logging two events whose names differ only in
case will result in two distinct events.

## Before you begin

Make sure that you've set up your project and can access Analytics as
described in [Get Started with Analytics](get-started).

## Log events

After you have created a `FirebaseAnalytics` instance, you can use it to log
events with the library's `log`- methods.

### Predefined events

To help you get started, the Analytics SDK defines a number of
recommended events that are common among different types of apps, including
retail and ecommerce, travel, and gaming apps. To learn more
[about these events](https://support.google.com/analytics/answer/9322688)
and when to use them, see
[Recommended events](https://support.google.com/analytics/answer/9267735).

Note: To get the maximum detail in reports, log the recommended events that make
sense for your app and their prescribed parameters. This also ensures that you
benefit from the latest Google Analytics features as
they become available.

You can find the log methods for the recommended event types in the
[API reference](https://pub.dev/documentation/firebase_analytics/latest/firebase_analytics/FirebaseAnalytics-class.html).

The following example demonstrates how to log a `select_content` event:

```dart
await FirebaseAnalytics.instance.logSelectContent(
    contentType: "image",
    itemId: itemId,
);
```

Alternatively, you can log the same event using `logEvent()`:

```dart
await FirebaseAnalytics.instance.logEvent(
    name: "select_content",
    parameters: {
        "content_type": "image",
        "item_id": itemId,
    },
);
```

This can be useful if you want to specify additional parameters other than the
prescribed (required) parameters. You can add the following parameters
to any event:

* Custom parameters: Custom parameters can be used as
  [dimensions or metrics](https://support.google.com/analytics/answer/10075209)
  in [Analytics reports](https://support.google.com/analytics/answer/9212670).
  You can use custom dimensions for non-numerical event parameter data and
  custom metrics for any parameter data better represented numerically. After
  you've logged a custom parameter using the SDK, register the dimension or
  metric to ensure those custom parameters appear in Analytics
  reports. Do this using *Analytics > Events > Manage Custom Definitions >
  Create Custom Dimensions*.

  Custom parameters can be used in
  [audience](https://support.google.com/firebase/answer/6317509)
  definitions that may be applied to every report.
  Custom parameters are also included in data
  [exported to BigQuery](https://support.google.com/firebase/answer/7030014)
  if your app is linked to a BigQuery project. Find sample queries and much more
  at [Google Analytics 4 BigQuery Export](https://developers.google.com/analytics/bigquery).

* `value` parameter: a general purpose parameter
  that is useful for accumulating a key metric that pertains to an
  event. Examples include revenue, distance, time, and points.
* Parameter names can be up to 40 characters long and must start with an alphabetic
  character and contain only alphanumeric characters and underscores. String and num
  types are supported. String parameter values can be up to 100 characters long.
  The "firebase_", "google_" and "ga_" prefixes are reserved and shouldn't be
  used for parameter names.

### Custom events

If your application has specific needs not covered by a recommended
event type, you can log your own custom events as shown in this example:

```dart
await FirebaseAnalytics.instance.logEvent(
    name: "share_image",
    parameters: {
        "image_name": name,
        "full_text": text,
    },
);
```

## Set default event parameters

You can log parameters across events using `setDefaultEventParameters()`.
Default parameters are associated with all future events that are logged.

As with custom parameters, register the default event parameters to ensure they
appear in Analytics reports.

Valid parameter values are String and num. Setting a key's value to `null`
clears that parameter. Passing in a null value clears all parameters.

```dart
// Not supported on web
await FirebaseAnalytics.instance
  .setDefaultEventParameters({
    version: '1.2.3'
  });
```

If a parameter is specified in the `logEvent()` or `log`-
method, that value is used instead of the default.

To clear a default parameter, call the `setDefaultEventParameters()`
method with the parameter set to `null`.



================================================
File: docs/flutter/analytics/_get-started.md
================================================
{# This content gets published to the following location:                    #}
{#   https://firebase.google.com/docs/analytics/get-started?platform=flutter #}

Google Analytics collects usage and behavior data for your app. The SDK
logs two primary types of information:

* **Events:** What is happening in your app, such as user actions, system
  events, or errors.
* **User properties:** Attributes you define to describe segments of your
  user base, such as language preference or geographic location.

Analytics automatically logs some
[events](https://support.google.com/analytics/answer/9234069) and
[user properties](https://support.google.com/analytics/answer/9268042);
you don't need to add any code to enable them.

## Before you begin

1. [Install `firebase_core`](/docs/flutter/setup) and add the initialization code
  to your app if you haven't already.
1. Add your app to your Firebase project in the
  [Firebase console](https://console.firebase.google.com).

## Add the Analytics SDK to your app {:#add-sdk}

1.  From the root of your Flutter project, run the following command to install the plugin:

    ```bash {5}
    flutter pub add firebase_analytics
    ```

1.  Once complete, rebuild your Flutter application:

    ```bash
    flutter run
    ```

1.  Once installed, you can access the `firebase_analytics`
    plugin by importing it in your Dart code:

    ```dart
    import 'package:firebase_analytics/firebase_analytics.dart';
    ```

1.  Create a new Firebase Analytics instance by accessing the
    `instance` property on
    `FirebaseAnalytics`:

    ```dart
    FirebaseAnalytics analytics = FirebaseAnalytics.instance;
    ```


## Start logging events

After you have created a `FirebaseAnalytics` instance, you can begin to log
events with the library's `log`- methods.

Certain events are
[recommended for all apps](https://support.google.com/analytics/answer/9267735);
others are recommended for specific business types or verticals. You should send
recommended events along with their prescribed parameters, to ensure maximum
available detail in your reports and to benefit from future features and
integrations as they become available. This section demonstrates logging a
predefined event, for more information on logging events, see
[Log events](events).

The following code logs a checkout event:

```dart
await FirebaseAnalytics.instance
  .logBeginCheckout(
    value: 10.0,
    currency: 'USD',
    items: [
      AnalyticsEventItem(
        itemName: 'Socks',
        itemId: 'xjw73ndnw',
        price: '10.0'
      ),
    ],
    coupon: '10PERCENTOFF'
  );
```

## Next steps

* Use the [DebugView](/docs/analytics/debugview) to verify your events.
* Explore your data in the [Firebase console](https://console.firebase.google.com/project/_/analytics/).
* Explore the guides on [events](events) and
  [user properties](user-properties).
* Learn how to export your data to [BigQuery](https://support.google.com/firebase/answer/7030014).



================================================
File: docs/flutter/analytics/_user-properties.md
================================================
{# This content gets published to the following location:                        #}
{#   https://firebase.google.com/docs/analytics/user-properties?platform=flutter #}

{# TODO(markarndt): Sync all this content up with Analytics content
consolidation plan. #}

## Before you begin

Make sure that you've set up your project and can access {{analytics}} as
described in [Get Started with {{analytics}}](get-started).

## Set user properties

You can set {{ analytics }} user properties to describe the users of your app.
You can make use of user properties by creating custom definitions, then using
them to apply comparisons in your reports or as audience evaluation criteria.

To set a user property, follow these steps:

1. Create a custom definition for the user property in the
  [**Custom Definitions** page](https://console.firebase.google.com/project/_/analytics/userproperty){: .external}
  of _{{analytics}}_ in the {{name_appmanager}}. For more information, see
  [Custom dimensions and metrics](https://support.google.com/analytics/answer/10075209).
1. Set a user property in your app with the `setUserProperty()` method.

The following example adds a hypothetical favorite food property, which
assigns the value in `favoriteFood` to the active user:

```dart
await FirebaseAnalytics.instance
  .setUserProperty({
    name: 'favorite_food',
    value: favoriteFood,
  });
```



================================================
File: docs/flutter/app-check/custom-resource.md
================================================
Project: /docs/_project.yaml
Book: /docs/_book.yaml

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# Protect non-Firebase resources with App Check

You can protect your app's non-Firebase resources, such as self-hosted backends,
with App Check. To do so, you will need to do both of the following:

- Modify your app client to send an App Check token along with each request
  to your backend, as described on this page.
- Modify your backend to require a valid App Check token with every request,
  as described in [Verify App Check tokens from a custom backend](/docs/app-check/custom-resource-backend).

## Before you begin

Add App Check to your app, using the [default providers](default-providers).

## Send App Check tokens with backend requests

To ensure your backend requests include a valid, unexpired, App Check token,
precede each request with a call to `getToken()`. The App Check library
will refresh the token if necessary.

Once you have a valid token, send it along with the request to your backend. The
specifics of how you accomplish this are up to you, but _don't send
App Check tokens as part of URLs_, including in query parameters, as this
makes them vulnerable to accidental leakage and interception. The recommended
approach is to send the token in a custom HTTP header.

For example:

```dart
void callApiExample() async {
    final appCheckToken = await FirebaseAppCheck.instance.getToken();
    if (appCheckToken != null) {
        final response = await http.get(
            Uri.parse("https://yourbackend.example.com/yourExampleEndpoint"),
            headers: {"X-Firebase-AppCheck": appCheckToken},
        );
    } else {
        // Error: couldn't get an App Check token.
    }
}
```



================================================
File: docs/flutter/app-check/debug-provider.md
================================================
Project: /docs/app-check/_project.yaml
Book: /docs/_book.yaml
page_type: guide

{% include "docs/app-check/_local_variables.html" %}
{% include "_shared/firebase/_snippet_include_comment.html" %}

#  Use App Check with the debug provider with Flutter

After you have registered your app for App Check, your app normally won't run
in an emulator or from a continuous integration (CI) environment, since those
environments don't qualify as valid devices. If you want to run your app in such
an environment during development and testing, you can create a debug build of
your app that uses the App Check debug provider instead of a real attestation
provider.

Warning: The debug provider allows access to your Firebase resources from
unverified devices. Don't use the debug provider in production builds of your
app, and don't share your debug builds with untrusted parties.

## Apple platforms

To use the debug provider while running your app in a simulator interactively
(during development, for example), do the following:

1.  Activate App Check with the debug provider right after you have initialized
    your Firebase app:

    ```dart
    import 'package:flutter/material.dart';
    import 'package:firebase_core/firebase_core.dart';

    // Import the firebase_app_check plugin
    import 'package:firebase_app_check/firebase_app_check.dart';

    Future<void> main() async {
      WidgetsFlutterBinding.ensureInitialized();
      await Firebase.initializeApp();
      await FirebaseAppCheck.instance.activate(
        // Set appleProvider to `AppleProvider.debug`
        appleProvider: AppleProvider.debug,
      );
      runApp(App());
    }
    ```

1.  Enable debug logging in your Xcode project (v11.0 or newer):

    1.  Open **Product > Scheme > Edit scheme**.
    1.  Select **Run** from the left menu, then select the **Arguments** tab.
    1.  In the **Arguments Passed on Launch** section, add `-FIRDebugEnabled`.

1.  Open `ios/Runner.xcworkspace` with Xcode and run your app in the Simulator.
    Your app will print a local debug token to the debug output when Firebase
    tries to send a request to the backend. For example:

    <pre>Firebase App Check Debug Token:
    123a4567-b89c-12d3-e456-789012345678</pre>

{# Google-internal common file: #}
<<../_includes/manage-debug-tokens.md>>

After you register the token, Firebase backend services will accept it as valid.

Because this token allows access to your Firebase resources without a
valid device, it is crucial that you keep it private. Don't commit it to a
public repository, and if a registered token is ever compromised, revoke it
immediately in the Firebase console.

## Android

To use the debug provider while running your Flutter app in an Android environment,
implement the following code in your Flutter application:

```dart
import 'package:flutter/material.dart';
import 'package:firebase_core/firebase_core.dart';

// Import the firebase_app_check plugin
import 'package:firebase_app_check/firebase_app_check.dart';

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp();
  await FirebaseAppCheck.instance.activate(
    webRecaptchaSiteKey: 'recaptcha-v3-site-key',
    // Set androidProvider to `AndroidProvider.debug`
    androidProvider: AndroidProvider.debug,
  );
  runApp(App());
}

```

Your app will print a local debug token to the debug output when Firebase tries
to send a request to the backend. For example:

<pre>D DebugAppCheckProvider: Enter this debug secret into the allow list in
the Firebase Console for your project: 123a4567-b89c-12d3-e456-789012345678</pre>

{# Google-internal common file: #}
<<../_includes/manage-debug-tokens.md>>

After you register the token, Firebase backend services will accept it as valid.

## Web

To use the debug provider while running your app from `localhost` (during
development, for example), do the following:

Warning: _Do not_ try to enable `localhost` debugging by adding `localhost` to
reCAPTCHA’s allowed domains. Doing so would allow anyone to run your app from
their local machines!

1.  In the file `web/index.html`, enable debug mode by setting
    `self.FIREBASE_APPCHECK_DEBUG_TOKEN` to `true`:

    ```html
    <body>
      <script>
        self.FIREBASE_APPCHECK_DEBUG_TOKEN = true;
      </script>

      ...

    </body>
    ```

1.  Run your web app locally and open the browser’s developer tool. In the
    debug console, you’ll see a debug token:

    <pre>AppCheck debug token: "123a4567-b89c-12d3-e456-789012345678". You will
    need to safelist it in the Firebase console for it to work.</pre>

    This token is stored locally in your browser and will be used whenever you
    use your app in the same browser on the same machine. If you want to use the
    token in another browser or on another machine, set
    `self.FIREBASE_APPCHECK_DEBUG_TOKEN` to the token string instead of `true`.

{# Google-internal common file: #}
<<../_includes/manage-debug-tokens.md>>

After you register the token, Firebase backend services will accept it as valid.

Because this token allows access to your Firebase resources without a
valid device, it is crucial that you keep it private. Don't commit it to a
public repository, and if a registered token is ever compromised, revoke it
immediately in the Firebase console.



================================================
File: docs/flutter/app-check/default-providers.md
================================================
Project: /docs/_project.yaml
Book: /docs/_book.yaml

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# Get started using App Check in Flutter apps

This page shows you how to enable App Check in a Flutter app, using the
default providers: Play Integrity on Android, Device Check on Apple platforms, and
reCAPTCHA v3 on web. When you enable App Check, you help ensure that
only your app can access your project's Firebase resources. See an
[Overview](/docs/app-check) of this feature.


## 1. Set up your Firebase project {:#project-setup}

1.  [Install and initialize FlutterFire](/docs/flutter/setup) if you haven't
    already done so.

1.  Register your apps to use App Check with the Play Integrity, Device Check, and reCAPTCHA providers in the
    [**Project Settings > App Check**](https://console.firebase.google.com/project/_/appcheck)
    section of the Firebase console.

    You usually need to register all of your project's apps, because once you
    enable enforcement for a Firebase product, only registered apps will be able
    to access the product's backend resources.

1.  **Optional**: In the app registration settings, set a custom time-to-live
    (TTL) for App Check tokens issued by the provider. You can set the TTL
    to any value between 30 minutes and 7 days. When changing this value, be
    aware of the following tradeoffs:

    - Security: Shorter TTLs provide stronger security, because it reduces the
      window in which a leaked or intercepted token can be abused by an
      attacker.
    - Performance: Shorter TTLs mean your app will perform attestation more
      frequently. Because the app attestation process adds latency to network
      requests every time it's performed, a short TTL can impact the performance
      of your app.
    - Quota and cost: Shorter TTLs and frequent re-attestation deplete your
      quota faster, and for paid services, potentially cost more.
      See [Quotas &amp; limits](/docs/app-check#quotas_limits).

    The default TTL
    is reasonable for most apps. Note that the App Check library refreshes
    tokens at approximately half the TTL duration.


## 2. Add the App Check library to your app {:#install-sdk}

1.  From the root of your Flutter project, run the following command to install the plugin:

    ```bash
    flutter pub add firebase_app_check
    ```

1.  Once complete, rebuild your Flutter application:

    ```bash
    flutter run
    ```


## 3. Initialize App Check {:#initialize}

Add the following initialization code to your app so that it runs before you
use any Firebase services such as Storage, but after calling
`Firebase.initializeApp()`;

```dart
import 'package:flutter/material.dart';
import 'package:firebase_core/firebase_core.dart';

// Import the firebase_app_check plugin
import 'package:firebase_app_check/firebase_app_check.dart';

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp();
  await FirebaseAppCheck.instance.activate(
    // You can also use a `ReCaptchaEnterpriseProvider` provider instance as an
    // argument for `webProvider`
    webProvider: ReCaptchaV3Provider('recaptcha-v3-site-key'),
    // Default provider for Android is the Play Integrity provider. You can use the "AndroidProvider" enum to choose
    // your preferred provider. Choose from:
    // 1. Debug provider
    // 2. Safety Net provider
    // 3. Play Integrity provider
    androidProvider: AndroidProvider.debug,
    // Default provider for iOS/macOS is the Device Check provider. You can use the "AppleProvider" enum to choose
        // your preferred provider. Choose from:
        // 1. Debug provider
        // 2. Device Check provider
        // 3. App Attest provider
        // 4. App Attest provider with fallback to Device Check provider (App Attest provider is only available on iOS 14.0+, macOS 14.0+)
    appleProvider: AppleProvider.appAttest,
  );
  runApp(App());
}
```

## Next steps

Once the App Check library is installed in your app, start distributing the
updated app to your users.

The updated client app will begin sending App Check tokens along with every
request it makes to Firebase, but Firebase products will not require the tokens
to be valid until you enable enforcement in the App Check section of the
Firebase console.

### Monitor metrics and enable enforcement {:#monitor}

Before you enable enforcement, however, you should make sure that doing so won't
disrupt your existing legitimate users. On the other hand, if you're seeing
suspicious use of your app resources, you might want to enable enforcement
sooner.

To help make this decision, you can look at App Check metrics for the
services you use:

- [Monitor App Check request metrics](/docs/app-check/monitor-metrics) for
  Realtime Database, Cloud Firestore, Cloud Storage, and Authentication.
- [Monitor App Check request metrics for Cloud Functions](/docs/app-check/monitor-functions-metrics).

### Enable App Check enforcement {:#enforce}

When you understand how App Check will affect your users and you're ready to
proceed, you can enable App Check enforcement:

- [Enable App Check enforcement](/docs/app-check/enable-enforcement) for
  Realtime Database, Cloud Firestore, Cloud Storage, and Authentication.
- [Enable App Check enforcement for Cloud Functions](/docs/app-check/cloud-functions).

### Use App Check in debug environments {:#debug}

If, after you have registered your app for App Check, you want to run your
app in an environment that App Check would normally not classify as valid,
such as an emulator during development, or from a continuous integration (CI)
environment, you can create a debug build of your app that uses the
App Check debug provider instead of a real attestation provider.

See [Use App Check with the debug provider in Flutter apps](/docs/app-check/flutter/debug-provider).



================================================
File: docs/flutter/auth/account-linking.md
================================================
Project: /docs/_project.yaml
Book: /docs/_book.yaml

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# Link Multiple Auth Providers to an Account

You can allow users to sign in to your app using multiple authentication
providers by linking auth provider credentials to an existing user account.
Users are identifiable by the same Firebase user ID regardless of the
authentication provider they used to sign in. For example, a user who signed in
with a password can link a Google account and sign in with either method in the
future. Or, an anonymous user can link a Facebook account and then, later, sign
in with Facebook to continue using your app.

## Before you begin

Add support for two or more authentication providers (possibly including
anonymous authentication) to your app.

## Link auth provider credentials to a user account

To link auth provider credentials to an existing user account:

1.  Sign in the user using any authentication provider or method.

1.  Complete the sign-in flow for the new authentication provider up to, but not
    including, calling one of the `signInWith`- methods. For example, get
    the user's Google ID token, Facebook access token, or email and password.

1.  Get a `Credential` object for the new authentication provider:

    ```dart
    // Google Sign-in
    final credential = GoogleAuthProvider.credential(idToken: idToken);

    // Email and password sign-in
    final credential =
        EmailAuthProvider.credential(email: emailAddress, password: password);

    // Etc.
    ```

1.  Pass the `Credential` object to the sign-in user's `linkWithCredential()`
    method:

    ```dart
    try {
      final userCredential = await FirebaseAuth.instance.currentUser
          ?.linkWithCredential(credential);
    } on FirebaseAuthException catch (e) {
      switch (e.code) {
        case "provider-already-linked":
          print("The provider has already been linked to the user.");
          break;
        case "invalid-credential":
          print("The provider's credential is not valid.");
          break;
        case "credential-already-in-use":
          print("The account corresponding to the credential already exists, "
              "or is already linked to a Firebase User.");
          break;
        // See the API reference for the full list of error codes.
        default:
          print("Unknown error.");
      }
      ```

If the call to `linkWithCredential()` succeeds, the user can now sign in using
any linked authentication provider and access the same Firebase data.

## Unlink an auth provider from a user account

You can unlink an auth provider from an account, so that the user can no
longer sign in with that provider.

To unlink an auth provider from a user account, pass the provider ID to the
`unlink()` method. You can get the provider IDs of the auth providers linked to
a user from the `User` object's `providerData` property.

```dart
try {
  await FirebaseAuth.instance.currentUser?.unlink(providerId);
} on FirebaseAuthException catch (e) {
  switch (e.code) {
    case "no-such-provider":
      print("The user isn't linked to the provider or the provider "
          "doesn't exist.");
      break;
    default:
      print("Unknown error.");
  }
}
```



================================================
File: docs/flutter/auth/anonymous-auth.md
================================================
Project: /docs/_project.yaml
Book: /docs/_book.yaml

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# Authenticate with Firebase Anonymously

You can use Firebase Authentication to create and use temporary anonymous accounts
to authenticate with Firebase. These temporary anonymous accounts can be used to
allow users who haven't yet signed up to your app to work with data protected
by security rules. If an anonymous user decides to sign up to your app, you can
[link their sign-in credentials](account-linking) to the anonymous account so
that they can continue to work with their protected data in future sessions.

## Before you begin

1.  If you haven't already, follow the steps in the [Get started](start) guide.

1.  Enable Anonymous sign-in:

    - In the Firebase console's **Authentication** section, open the
      [Sign in method](https://console.firebase.google.com/project/_/authentication/providers)
      page.
    - From the **Sign in method** page, enable the **Anonymous sign-in**
      method and click **Save**.

## Authenticate with Firebase anonymously

When a signed-out user uses an app feature that requires authentication with
Firebase, sign in the user anonymously by calling `signInAnonymously()`:

```dart
try {
  final userCredential =
      await FirebaseAuth.instance.signInAnonymously();
  print("Signed in with temporary account.");
} on FirebaseAuthException catch (e) {
  switch (e.code) {
    case "operation-not-allowed":
      print("Anonymous auth hasn't been enabled for this project.");
      break;
    default:
      print("Unknown error.");
  }
}
```

Note: To protect your project from abuse, Firebase limits the number of new
email/password and anonymous sign-ups that your application can have from the
same IP address in a short period of time. You can request and schedule
temporary changes to this quota from the
[Firebase console](https://console.firebase.google.com/project/_/authentication/providers).

## Convert an anonymous account to a permanent account

When an anonymous user signs up to your app, you might want to allow them to
continue their work with their new account&mdash;for example, you might want to
make the items the user added to their shopping cart before they signed up
available in their new account's shopping cart. To do so, complete the following
steps:

1.  When the user signs up, complete the sign-in flow for the user's
    authentication provider up to, but not including, calling one of the
    `signInWith`- methods. For example, get the user's Google ID token,
    Facebook access token, or email address and password.

1.  Get a `Credential` object for the new authentication provider:

    ```dart
    // Google Sign-in
    final credential = GoogleAuthProvider.credential(idToken: idToken);

    // Email and password sign-in
    final credential =
        EmailAuthProvider.credential(email: emailAddress, password: password);

    // Etc.
    ```

1.  Pass the `Credential` object to the sign-in user's `linkWithCredential()`
    method:

    ```dart
    try {
      final userCredential = await FirebaseAuth.instance.currentUser
          ?.linkWithCredential(credential);
    } on FirebaseAuthException catch (e) {
      switch (e.code) {
        case "provider-already-linked":
          print("The provider has already been linked to the user.");
          break;
        case "invalid-credential":
          print("The provider's credential is not valid.");
          break;
        case "credential-already-in-use":
          print("The account corresponding to the credential already exists, "
              "or is already linked to a Firebase User.");
          break;
        // See the API reference for the full list of error codes.
        default:
          print("Unknown error.");
      }
      ```

If the call to `linkWithCredential()` succeeds, the user's new account can
access the anonymous account's Firebase data.

Note: This technique can also be used to [link any two accounts](account-linking).


## Next steps

After a user creates a new account, this account is stored as part of your
Firebase project, and can be used to identify a user across every app in your
project, regardless of what sign-in method the user used.

In your apps, you can get the user's basic profile information from the
`User` object. See [Manage Users](manage-users).

In your Firebase Realtime Database and Cloud Storage Security Rules, you can
get the signed-in user's unique user ID from the `auth` variable, and use it to
control what data a user can access.

You can allow users to sign in to your app using multiple authentication
providers by [linking auth provider credentials](account-linking)) to an
existing user account.

To sign out a user, call `signOut()`:

```dart
await FirebaseAuth.instance.signOut();
```



================================================
File: docs/flutter/auth/custom-auth.md
================================================
Project: /docs/_project.yaml
Book: /docs/_book.yaml

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# Authenticate with Firebase Using a Custom Authentication System

You can integrate Firebase Authentication with a custom authentication system by
modifying your authentication server to produce custom signed tokens when a user
successfully signs in. Your app receives this token and uses it to authenticate
with Firebase.

## Before you begin

1.  If you haven't already, follow the steps in the [Get started](start) guide.
1.  [Install and configure the Firebase Admin SDK](/docs/admin/setup).
    Be sure to [initialize the SDK](/docs/admin/setup#initialize-sdk)
    with the correct credentials for your Firebase project.

## Authenticate with Firebase

1.  When users sign in to your app, send their sign-in credentials (for
    example, their username and password) to your authentication server. Your
    server checks the credentials and, if they are valid,
    [creates a custom Firebase token](/docs/auth/admin/create-custom-tokens)
    and sends the token back to your app.

1.  After you receive the custom token from your authentication server, pass it
    to `signInWithCustomToken()` to sign in the user:

    ```dart
    try {
        final userCredential =
            await FirebaseAuth.instance.signInWithCustomToken(token);
        print("Sign-in successful.");
    } on FirebaseAuthException catch (e) {
        switch (e.code) {
            case "invalid-custom-token":
                print("The supplied token is not a Firebase custom auth token.");
                break;
            case "custom-token-mismatch":
                print("The supplied token is for a different Firebase project.");
                break;
            default:
                print("Unknown error.");
        }
    }
    ```

## Next steps

After a user creates a new account, this account is stored as part of your
Firebase project, and can be used to identify a user across every app in your
project, regardless of what sign-in method the user used.

In your apps, you can get the user's basic profile information from the
`User` object. See [Manage Users](manage-users).

In your Firebase Realtime Database and Cloud Storage Security Rules, you can
get the signed-in user's unique user ID from the `auth` variable, and use it to
control what data a user can access.

You can allow users to sign in to your app using multiple authentication
providers by [linking auth provider credentials](account-linking)) to an
existing user account.

To sign out a user, call `signOut()`:

```dart
await FirebaseAuth.instance.signOut();
```



================================================
File: docs/flutter/auth/email-link-auth.md
================================================
Project: /docs/_project.yaml
Book: /docs/_book.yaml

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# Authenticate with Firebase Using Email Links

You can use Firebase Authentication to sign in a user by sending them an email
containing a link, which they can click to sign in. In the process, the user's
email address is also verified.

There are numerous benefits to signing in by email:

* Low friction sign-up and sign-in.
* Lower risk of password reuse across applications, which can undermine security
  of even well-selected passwords.
* The ability to authenticate a user while also verifying that the user is the
  legitimate owner of an email address.
* A user only needs an accessible email account to sign in. No ownership of a
  phone number or social media account is required.
* A user can sign in securely without the need to provide (or remember) a
  password, which can be cumbersome on a mobile device.
* An existing user who previously signed in with an email identifier (password
  or federated) can be upgraded to sign in with just the email. For example, a
  user who has forgotten their password can still sign in without needing to
  reset their password.


## Before you begin

1.  If you haven't already, follow the steps in the [Get started](start) guide.

1.  Enable Email Link sign-in for your Firebase project.

    To sign in users by email link, you must first enable the Email provider
    and Email link sign-in method for your Firebase project:

    1.  In the [Firebase console](https://console.firebase.google.com/), open the **Auth** section.
    1.  On the **Sign in method** tab, enable the **Email/Password** provider.
        Note that email/password sign-in must be enabled to use email link
        sign-in.
    1.  In the same section, enable **Email link (passwordless sign-in)**
        sign-in method.
    1.  Click **Save**.


## Send an authentication link to the user's email address

To initiate the authentication flow, present an interface that prompts the user to provide their email address and then call `sendSignInLinkToEmail()` to request that Firebase send the authentication link to the user's email.

1.  Construct the ActionCodeSettings object, which provides Firebase with instructions on how to construct the email link. Set the following fields:

    * `url`: The deep link to embed and any additional state to be passed along. The link's domain has to be whitelisted in the Firebase Console list of authorized domains, which can be found by going to the Settings tab (Authentication -> Settings -> Authorized Domains). The link will redirect the user to this URL if the app is not installed on their device and the app was not able to be installed.

    * `androidPackageName` and `IOSBundleId`: The apps to use when the sign-in link is opened on an Android or iOS device. Learn more on how to configure Firebase Dynamic Links to open email action links via mobile apps.

    * `handleCodeInApp`: Set to `true`. The sign-in operation has to always be completed in the app unlike other out of band email actions (password reset and email verifications). This is because, at the end of the flow, the user is expected to be signed in and their Auth state persisted within the app.

    * `dynamicLinkDomain`: When multiple custom dynamic link domains are defined for a project, specify which one to use when the link is to be opened via a specified mobile app (for example, `example.page.link`). Otherwise the first domain is automatically selected.

    ```dart
    var acs = ActionCodeSettings(
        // URL you want to redirect back to. The domain (www.example.com) for this
        // URL must be whitelisted in the Firebase Console.
        url: 'https://www.example.com/finishSignUp?cartId=1234',
        // This must be true
        handleCodeInApp: true,
        iOSBundleId: 'com.example.ios',
        androidPackageName: 'com.example.android',
        // installIfNotAvailable
        androidInstallApp: true,
        // minimumVersion
        androidMinimumVersion: '12');
    ```

1.  Ask the user for their email.

1.  Send the authentication link to the user's email, and save the user's email in case the user completes the email sign-in on the same device.

    ```dart
    var emailAuth = 'someemail@domain.com';
    FirebaseAuth.instance.sendSignInLinkToEmail(
            email: emailAuth, actionCodeSettings: acs)
        .catchError((onError) => print('Error sending email verification $onError'))
        .then((value) => print('Successfully sent email verification'));
    });
    ```


## Complete sign in with the email link

### Security concerns


To prevent a sign-in link from being used to sign in as an unintended user or on
an unintended device, Firebase Auth requires the user's email address to be
provided when completing the sign-in flow. For sign-in to succeed, this email
address must match the address to which the sign-in link was originally sent.

You can streamline this flow for users who open the sign-in link on the same
device they request the link, by storing their email address locally - for
instance using SharedPreferences - when you send the sign-in email. Then,
use this address to complete the flow.
Do not pass the user's email in the redirect URL parameters and re-use it as
this may enable session injections.

After sign-in completion, any previous unverified mechanism of sign-in will be
removed from the user and any existing sessions will be invalidated.
For example, if someone previously created an unverified account with the same
email and password, the user's password will be removed to prevent the
impersonator who claimed ownership and created that unverified account from
signing in again with the unverified email and password.

Also make sure you use an HTTPS URL in production to avoid your link being
potentially intercepted by intermediary servers.

### Verify email link and sign in

Firebase Authentication uses Firebase Dynamic Links to send the email link to a mobile device. For sign-in completion via mobile application, the application has to be configured to detect the incoming application link, parse the underlying deep link and then complete the sign-in.

1.  Set up your app to receive Dynamic Links on Flutter in the [guide](/docs/dynamic-links/flutter/receive).

1.  In your link handler, check if the link is meant for email link authentication and, if so, complete the sign-in process.

    ```dart
    // Confirm the link is a sign-in with email link.
    if (FirebaseAuth.instance.isSignInWithEmailLink(emailLink)) {
      try {
        // The client SDK will parse the code from the link for you.
        final userCredential = await FirebaseAuth.instance
            .signInWithEmailLink(email: emailAuth, emailLink: emailLink);

        // You can access the new user via userCredential.user.
        final emailAddress = userCredential.user?.email;

        print('Successfully signed in with email link!');
      } catch (error) {
        print('Error signing in with email link.');
      }
    }
    ```

### Linking/re-authentication with email link

You can also link this method of authentication to an existing user. For example
a user previously authenticated with another provider, such as a phone number,
can add this method of sign-in to their existing account.

The difference would be in the second half of the operation:

```dart
final authCredential = EmailAuthProvider
    .credentialWithLink(email: emailAuth, emailLink: emailLink.toString());
try {
    await FirebaseAuth.instance.currentUser
        ?.linkWithCredential(authCredential);
} catch (error) {
    print("Error linking emailLink credential.");
}
```

This can also be used to re-authenticate an email link user before running a
sensitive operation.

```dart
final authCredential = EmailAuthProvider
    .credentialWithLink(email: emailAuth, emailLink: emailLink.toString());
try {
    await FirebaseAuth.instance.currentUser
        ?.reauthenticateWithCredential(authCredential);
} catch (error) {
    print("Error reauthenticating credential.");
}
```

However, as the flow could end up on a different device where the original user
was not logged in, this flow might not be completed. In that case, an error can
be shown to the user to force them to open the link on the same device. Some
state can be passed in the link to provide information on the type of operation
and the user uid.

## Deprecated: Differentiating email-password from email link {:#differentiating_emailpassword_from_email_link}

If you created your project on or after September 15, 2023, email enumeration
protection is enabled by default. This feature improves the security of your
project's user accounts, but it disables the `fetchSignInMethodsForEmail()`
method, which we formerly recommended to implement identifier-first flows.

Although you can disable email enumeration protection for your project, we
recommend against doing so.

See the documentation on [email enumeration protection](https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection)
for more details.

## Next steps

After a user creates a new account, this account is stored as part of your
Firebase project, and can be used to identify a user across every app in your
project, regardless of what sign-in method the user used.

In your apps, you can get the user's basic profile information from the
`User` object. See [Manage Users](manage-users).

In your Firebase Realtime Database and Cloud Storage Security Rules, you can
get the signed-in user's unique user ID from the `auth` variable, and use it to
control what data a user can access.

You can allow users to sign in to your app using multiple authentication
providers by [linking auth provider credentials](account-linking)) to an
existing user account.

To sign out a user, call `signOut()`:

```dart
await FirebaseAuth.instance.signOut();
```



================================================
File: docs/flutter/auth/errors.md
================================================
Project: /docs/_project.yaml
Book: /docs/_book.yaml

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# Error Handling

The Firebase Authentication SDKs provide a simple way for catching the various errors which may occur which using
authentication methods. The SDKs for Flutter expose these errors via the `FirebaseAuthException`
class.

At a minimum, a `code` and `message` are provided, however in some cases additional properties such as an email address
and credential are also provided. For example, if the user is attempting to sign in with an email and password,
any errors thrown can be explicitly caught:

```dart
try {
  await FirebaseAuth.instance.signInWithEmailAndPassword(
    email: "barry.allen@example.com",
    password: "SuperSecretPassword!"
  );
} on FirebaseAuthException catch  (e) {
  print('Failed with error code: ${e.code}');
  print(e.message);
}
```

Each method provides various error codes and messages depending on the type of authentication invocation type. The
[Reference API](https://pub.dev/documentation/firebase_auth/latest/) provides up-to-date details on the errors for each method.

Other errors such as `too-many-requests` or `operation-not-allowed` may be thrown if you reach the Firebase Authentication quota,
or have not enabled a specific auth provider.

## Handling `account-exists-with-different-credential` Errors

If you enabled the One account per email address setting in the [Firebase console](https://console.firebase.google.com/project/_/authentication/providers),
when a user tries to sign in a to a provider (such as Google) with an email that already exists for another Firebase user's provider
(such as Facebook), the error `auth/account-exists-with-different-credential` is thrown along with an `AuthCredential` class (Google ID token).
To complete the sign-in flow to the intended provider, the user has to first sign in to the existing provider (e.g. Facebook) and then link to the former
`AuthCredential` (Google ID token).

```dart
FirebaseAuth auth = FirebaseAuth.instance;

// Create a credential from a Google Sign-in Request
var googleAuthCredential = GoogleAuthProvider.credential(accessToken: 'xxxx');

try {
  // Attempt to sign in the user in with Google
  await auth.signInWithCredential(googleAuthCredential);
} on FirebaseAuthException catch (e) {
  if (e.code == 'account-exists-with-different-credential') {
    // The account already exists with a different credential
    String email = e.email;
    AuthCredential pendingCredential = e.credential;

    // Fetch a list of what sign-in methods exist for the conflicting user
    List<String> userSignInMethods = await auth.fetchSignInMethodsForEmail(email);

    // If the user has several sign-in methods,
    // the first method in the list will be the "recommended" method to use.
    if (userSignInMethods.first == 'password') {
      // Prompt the user to enter their password
      String password = '...';

      // Sign the user in to their account with the password
      UserCredential userCredential = await auth.signInWithEmailAndPassword(
        email: email,
        password: password,
      );

      // Link the pending credential with the existing account
      await userCredential.user.linkWithCredential(pendingCredential);

      // Success! Go back to your application flow
      return goToApplication();
    }

    // Since other providers are now external, you must now sign the user in with another
    // auth provider, such as Facebook.
    if (userSignInMethods.first == 'facebook.com') {
      // Create a new Facebook credential
      String accessToken = await triggerFacebookAuthentication();
      var facebookAuthCredential = FacebookAuthProvider.credential(accessToken);

      // Sign the user in with the credential
      UserCredential userCredential = await auth.signInWithCredential(facebookAuthCredential);

      // Link the pending credential with the existing account
      await userCredential.user.linkWithCredential(pendingCredential);

      // Success! Go back to your application flow
      return goToApplication();
    }

    // Handle other OAuth providers...
  }
}
```



================================================
File: docs/flutter/auth/federated-auth.md
================================================
Project: /docs/_project.yaml
Book: /docs/_book.yaml

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# Federated identity & social sign-in

Social authentication is a multi-step authentication flow, allowing you to sign a user into an account or link
them with an existing one.

Both native platforms and web support creating a credential which can then be passed to the `signInWithCredential`
or `linkWithCredential` methods. Alternatively on web platforms, you can trigger the authentication process via
a popup or redirect.

## Google

Most configuration is already setup when using Google Sign-In with Firebase, however you need to ensure your machine's
SHA1 key has been configured for use with Android. You can see how to generate the key in the
[authentication documentation](https://developers.google.com/android/guides/client-auth).

Ensure the "Google" sign-in provider is enabled on the [Firebase Console](https://console.firebase.google.com/project/_/authentication/providers).

> If your user signs in with Google, after having already manually registered an account, their authentication provider will automatically
> change to Google, due to Firebase Authentications concept of trusted providers. You can find out more about
> this [here](https://groups.google.com/g/firebase-talk/c/ms_NVQem_Cw/m/8g7BFk1IAAAJ).

* {iOS+ and Android}

  On native platforms, a 3rd party library is required to trigger the authentication flow.

  Install the official [`google_sign_in`](https://pub.dev/packages/google_sign_in) plugin.

  Once installed, trigger the sign-in flow and create a new credential:

  ```dart
  import 'package:google_sign_in/google_sign_in.dart';

  Future<UserCredential> signInWithGoogle() async {
    // Trigger the authentication flow
    final GoogleSignInAccount? googleUser = await GoogleSignIn().signIn();

    // Obtain the auth details from the request
    final GoogleSignInAuthentication? googleAuth = await googleUser?.authentication;

    // Create a new credential
    final credential = GoogleAuthProvider.credential(
      accessToken: googleAuth?.accessToken,
      idToken: googleAuth?.idToken,
    );

    // Once signed in, return the UserCredential
    return await FirebaseAuth.instance.signInWithCredential(credential);
  }
  ```

* {Web}

  On the web, the Firebase SDK provides support for automatically handling the authentication flow using your Firebase project. For example:

  Create a Google auth provider, providing any additional [permission scope](https://developers.google.com/identity/protocols/oauth2/scopes)
  you wish to obtain from the user:

  ```dart
  GoogleAuthProvider googleProvider = GoogleAuthProvider();

  googleProvider.addScope('https://www.googleapis.com/auth/contacts.readonly');
  googleProvider.setCustomParameters({
    'login_hint': 'user@example.com'
  });
  ```

  Provide the credential to the `signInWithPopup` method. This will trigger a new
  window to appear prompting the user to sign-in to your project. Alternatively you can use `signInWithRedirect` to keep the
  authentication process in the same window.

  ```dart
  Future<UserCredential> signInWithGoogle() async {
    // Create a new provider
    GoogleAuthProvider googleProvider = GoogleAuthProvider();

    googleProvider.addScope('https://www.googleapis.com/auth/contacts.readonly');
    googleProvider.setCustomParameters({
      'login_hint': 'user@example.com'
    });

    // Once signed in, return the UserCredential
    return await FirebaseAuth.instance.signInWithPopup(googleProvider);

    // Or use signInWithRedirect
    // return await FirebaseAuth.instance.signInWithRedirect(googleProvider);
  }
  ```

## Google Play Games (Android only) {:#games}

Ensure the "Play Games" sign-in provider is enabled on the [Firebase Console](https://console.firebase.google.com/project/_/authentication/providers).
Follow these instructions for [Play Games Firebase project set-up](https://firebase.google.com/docs/auth/android/play-games#set-up-firebase-project).

Follow these [instructions for configuring Play Games services](https://firebase.google.com/docs/auth/android/play-games#configure-play-games-with-firebase-info)
with your Firebase app.

* {Android}

```dart
Future<void> _signInWithPlayGames() async {
  // Get server auth code from 3rd party provider
  // See PR description for details on how you might get the server auth code:
  // https://github.com/firebase/flutterfire/pull/12201#issue-2100392487
  final serverAuthCode = '...';
  final playGamesCredential = PlayGamesAuthProvider.credential(
                                          serverAuthCode: serverAuthCode);

  await FirebaseAuth.instance
    .signInWithCredential(playGamesCredential);
}
```

## Facebook

Before getting started setup your [Facebook Developer App](https://developers.facebook.com/apps/) and follow the setup process to enable Facebook Login.

Ensure the "Facebook" sign-in provider is enabled on the [Firebase Console](https://console.firebase.google.com/project/_/authentication/providers).
with the Facebook App ID and Secret set.

* {iOS+ and Android}

  On native platforms, a 3rd party library is required to both install the Facebook SDK and trigger the authentication flow.

  Install the [`flutter_facebook_auth`](https://pub.dev/packages/flutter_facebook_auth) plugin.

  You will need to follow the steps in the plugin documentation to ensure that both the Android & iOS Facebook SDKs have been initialized
  correctly. Once complete, trigger the sign-in flow, create a Facebook credential and sign the user in:

  ```dart
  import 'package:flutter_facebook_auth/flutter_facebook_auth.dart';

  Future<UserCredential> signInWithFacebook() async {
    // Trigger the sign-in flow
    final LoginResult loginResult = await FacebookAuth.instance.login();

    // Create a credential from the access token
    final OAuthCredential facebookAuthCredential = FacebookAuthProvider.credential(loginResult.accessToken.token);

    // Once signed in, return the UserCredential
    return FirebaseAuth.instance.signInWithCredential(facebookAuthCredential);
  }
  ```

* {Web}

  On the web, the Firebase SDK provides support for automatically handling the authentication flow using the
  Facebook application details provided on the Firebase console. For example:

  Create a Facebook provider, providing any additional [permission scope](https://developers.facebook.com/docs/facebook-login/permissions/)
  you wish to obtain from the user.

  Ensure that the OAuth redirect URI from the Firebase console is added as a valid OAuth Redirect URI
  in your Facebook App.

  ```dart
  FacebookAuthProvider facebookProvider = FacebookAuthProvider();

  facebookProvider.addScope('email');
  facebookProvider.setCustomParameters({
    'display': 'popup',
  });
  ```

  Provide the credential to the `signInWithPopup` method. This will trigger a new
  window to appear prompting the user to sign-in to your Facebook application:

  ```dart
  Future<UserCredential> signInWithFacebook() async {
    // Create a new provider
    FacebookAuthProvider facebookProvider = FacebookAuthProvider();

    facebookProvider.addScope('email');
    facebookProvider.setCustomParameters({
      'display': 'popup',
    });

    // Once signed in, return the UserCredential
    return await FirebaseAuth.instance.signInWithPopup(facebookProvider);

    // Or use signInWithRedirect
    // return await FirebaseAuth.instance.signInWithRedirect(facebookProvider);
  }
  ```

Note: Firebase will not set the `User.isEmailVerified` property
to `true` if your user logs in with Facebook. Should your user login using a provider that verifies email (e.g. Google sign-in) then this will be set to true.
For further information, see this [issue](https://github.com/firebase/flutterfire/issues/4612#issuecomment-782107867).


## Apple

* {iOS+}

  Before you begin, [configure Sign In with Apple](/docs/auth/ios/apple#configure-sign-in-with-apple)
  and [enable Apple as a sign-in provider](/docs/auth/ios/apple#enable-apple-as-a-sign-in-provider).

  Next, make sure that your `Runner` apps have the "Sign in with Apple" capability.

* {Android}
  Before you begin, [configure Sign In with Apple](/docs/auth/android/apple#configure_sign_in_with_apple)
  and [enable Apple as a sign-in provider](/docs/auth/android/apple#enable-apple-as-a-sign-in-provider).

* {Web}

  Before you begin, [configure Sign In with Apple](/docs/auth/web/apple#configure-sign-in-with-apple)
  and [enable Apple as a sign-in provider](/docs/auth/web/apple#enable-apple-as-a-sign-in-provider).


```dart
import 'package:firebase_auth/firebase_auth.dart';

Future<UserCredential> signInWithApple() async {
  final appleProvider = AppleAuthProvider();
  if (kIsWeb) {
    await FirebaseAuth.instance.signInWithPopup(appleProvider);
  } else {
    await FirebaseAuth.instance.signInWithProvider(appleProvider);
  }
}
```

#### Apple platform sign-in only

Apple sign-in on iOS+ platforms can also be achieved with the following method:

```dart
// Implement a function that generates a nonce. See iOS documentation for how to create a nonce:
// https://firebase.google.com/docs/auth/ios/apple#sign_in_with_apple_and_authenticate_with_firebase
String rawNonce = createNonce();
// Create a SHA-256 hash of the nonce. Consider using the `crypto` package from the pub.dev registry.
String hashSHA256String = createHashSHA256String(rawNonce);
// Use the hash of the nonce to get the idToken. Consider using the `sign_in_with_apple` plugin from the pub.dev registry.
String idToken = await getIdToken();

final fullName = AppleFullPersonName(
  familyName: 'Name',
  givenName: 'Your',
);
// Use the `rawNonce` and `idToken` to get the credential
final credential = AppleAuthProvider.credentialWithIDToken(
  idToken,
  rawNonce,
  fullName,
);

await FirebaseAuth.instance.signInWithCredential(credential);
```

### Revoke Apple auth tokens {:#revoke-apple}

Apple sign-in on Apple platforms returns an authorization code that can be used
to revoke the Apple auth token using the `revokeTokenWithAuthorizationCode()`
API.

```dart
import 'package:firebase_auth/firebase_auth.dart';

Future<UserCredential> signInWithApple() async {
  final appleProvider = AppleAuthProvider();

  UserCredential userCredential = await FirebaseAuth.instance.signInWithPopup(appleProvider);
  // Keep the authorization code returned from Apple platforms
  String? authCode = userCredential.additionalUserInfo?.authorizationCode;
  // Revoke Apple auth token
  await FirebaseAuth.instance.revokeTokenWithAuthorizationCode(authCode!);
}
```

## Apple Game Center (Apple only) {:#games}

Ensure the "Game Center" sign-in provider is enabled on the [Firebase Console](https://console.firebase.google.com/project/_/authentication/providers).
Follow these instructions for [Game Center Firebase project set-up](https://firebase.google.com/docs/auth/ios/game-center#before_you_begin).

You will need to login with Game Center before a Firebase Game Center credential can be issued and logged in via Firebase. [Here are some instructions](https://firebase.google.com/docs/auth/ios/game-center#integrate_game_center_sign-in_into_your_game)
on how that can be achieved.

* {iOS+}

```dart
Future<void> _signInWithGameCenter() async {
  final credential = GameCenterAuthProvider.credential();
  await FirebaseAuth.instance
      .signInWithCredential(credential);
}
```

## Microsoft

* {iOS+}

  Before you begin [configure Microsoft Login for iOS](/docs/auth/ios/microsoft-oauth#before_you_begin) and add the [custom URL schemes
  to your Runner (step 1)](https://firebase.google.com/docs/auth/ios/microsoft-oauth#handle_the_sign-in_flow_with_the_firebase_sdk).

* {Android}
  Before you begin [configure Microsoft Login for Android](/docs/auth/android/microsoft-oauth#before_you_begin).

  Don't forget to add your app's SHA-1 fingerprint.

* {Web}

  Before you begin [configure Microsoft Login for Web](/docs/auth/web/microsoft-oauth#configure-sign-in-with-apple).

```dart
import 'package:firebase_auth/firebase_auth.dart';

Future<UserCredential> signInWithMicrosoft() async {
  final microsoftProvider = MicrosoftAuthProvider();
  if (kIsWeb) {
    await FirebaseAuth.instance.signInWithPopup(microsoftProvider);
  } else {
    await FirebaseAuth.instance.signInWithProvider(microsoftProvider);
  }
}
```

## Twitter

Ensure the "Twitter" sign-in provider is enabled on the [Firebase Console](https://console.firebase.google.com/project/_/authentication/providers)
with an API Key and API Secret set. Ensure your Firebase OAuth redirect URI (e.g. my-app-12345.firebaseapp.com/__/auth/handler)
is set as your Authorization callback URL in your app's settings page on your [Twitter app's config](https://apps.twitter.com/).

You also might need to request elevated [API access depending on your app](https://developer.twitter.com/en/portal/products/elevated).

* {iOS+}

  You need to configure your custom URL scheme as [described in iOS guide step 1](https://firebase.google.com/docs/auth/ios/twitter-login#handle_the_sign-in_flow_with_the_firebase_sdk).

* {Android}

  If you haven't yet specified your app's SHA-1 fingerprint, do so from the [Settings page](https://console.firebase.google.com/project/_/settings/general/)
  of the Firebase console. Refer to [Authenticating Your Client](https://developers.google.com/android/guides/client-auth) for details on how to get your app's SHA-1 fingerprint.

* {Web}

  Works out of the box.

```dart
import 'package:firebase_auth/firebase_auth.dart';

Future<void> _signInWithTwitter() async {
  TwitterAuthProvider twitterProvider = TwitterAuthProvider();

  if (kIsWeb) {
    await FirebaseAuth.instance.signInWithPopup(twitterProvider);
  } else {
    await FirebaseAuth.instance.signInWithProvider(twitterProvider);
  }
}
```


## GitHub

Ensure that you have setup an OAuth App from your [GitHub Developer Settings](https://github.com/settings/developers) and
that the "GitHub" sign-in provider is enabled on the [Firebase Console](https://console.firebase.google.com/project/_/authentication/providers)
with the Client ID and Secret are set, with the callback URL set in the GitHub app.

* {iOS+ and Android}

  For native platforms, you need to add the `google-services.json` and `GoogleService-Info.plist`.

  For iOS, add the custom URL scheme as [described on the iOS guide](https://firebase.google.com/docs/auth/ios/github-auth#handle_the_sign-in_flow_with_the_firebase_sdk) step 1.

  ```dart
  Future<UserCredential> signInWithGitHub() async {
    // Create a new provider
    GithubAuthProvider githubProvider = GithubAuthProvider();

    return await FirebaseAuth.instance.signInWithProvider(githubProvider);
  }
  ```

* {Web}

  On the web, the GitHub SDK provides support for automatically handling the authentication flow using the
  GitHub application details provided on the Firebase console. Ensure that the callback URL in the Firebase console is added
  as a callback URL in your GitHub application on the developer console.

  For example:

  Create a GitHub provider and provide the credential to the `signInWithPopup` method. This will trigger a new
  window to appear prompting the user to sign-in to your GitHub application:

  ```dart
  Future<UserCredential> signInWithGitHub() async {
    // Create a new provider
    GithubAuthProvider githubProvider = GithubAuthProvider();

    // Once signed in, return the UserCredential
    return await FirebaseAuth.instance.signInWithPopup(githubProvider);

    // Or use signInWithRedirect
    // return await FirebaseAuth.instance.signInWithRedirect(githubProvider);
  }
  ```



## Yahoo

Ensure the "Yahoo" sign-in provider is enabled on the [Firebase Console](https://console.firebase.google.com/project/_/authentication/providers)
with an API Key and API Secret set. Also make sure your Firebase OAuth redirect URI (e.g. my-app-12345.firebaseapp.com/__/auth/handler)
is set as a redirect URI in your app's Yahoo Developer Network configuration.


* {iOS+}

  Before you begin, [configure Yahoo Login for iOS](/docs/auth/ios/yahoo-oauth#before_you_begin) and add the [custom URL schemes
  to your Runner (step 1)](https://firebase.google.com/docs/auth/ios/yahoo-oauth#handle_the_sign-in_flow_with_the_firebase_sdk).

* {Android}
  Before you begin, [configure Yahoo Login for Android](/docs/auth/android/yahoo-oauth#before_you_begin).

  Don't forget to add your app's SHA-1 fingerprint.

* {Web}

  Works out of the box.

```dart
import 'package:firebase_auth/firebase_auth.dart';

Future<UserCredential> signInWithYahoo() async {
  final yahooProvider = YahooAuthProvider();
  if (kIsWeb) {
    await _auth.signInWithPopup(yahooProvider);
  } else {
    await _auth.signInWithProvider(yahooProvider);
  }
}
```

# Using the OAuth access token

By using an AuthProvider, you can retrieve the access token associated with the provider
by making the following request.

```dart
final appleProvider = AppleAuthProvider();

final user = await FirebaseAuth.instance.signInWithProvider(appleProvider);
final accessToken = user.credential?.accessToken;

// You can send requests with the `accessToken`
```


# Linking an Authentication Provider

If you want to link a provider to a current user, you can use the following method:
```dart
await FirebaseAuth.instance.signInAnonymously();

final appleProvider = AppleAuthProvider();

if (kIsWeb) {
  await FirebaseAuth.instance.currentUser?.linkWithPopup(appleProvider);

  // You can also use `linkWithRedirect`
} else {
  await FirebaseAuth.instance.currentUser?.linkWithProvider(appleProvider);
}

// You're anonymous user is now upgraded to be able to connect with Sign In With Apple
```

# Reauthenticate with provider

The same pattern can be used with `reauthenticateWithProvider` which can be used to retrieve fresh
credentials for sensitive operations that require recent login.

```dart
final appleProvider = AppleAuthProvider();

if (kIsWeb) {
  await FirebaseAuth.instance.currentUser?.reauthenticateWithPopup(appleProvider);

  // Or you can reauthenticate with a redirection
  // await FirebaseAuth.instance.currentUser?.reauthenticateWithRedirect(appleProvider);
} else {
  await FirebaseAuth.instance.currentUser?.reauthenticateWithProvider(appleProvider);
}

// You can now perform sensitive operations
```



================================================
File: docs/flutter/auth/manage-users.md
================================================
Project: /docs/_project.yaml
Book: /docs/_book.yaml

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# Manage Users in Firebase

## Create a user

You create a new user in your Firebase project in four ways:

- Call the `createUserWithEmailAndPassword()` method.
- Sign in a user for the first time using a [federated identity provider](/docs/auth/flutter/federated-auth),
  such as Google Sign-In, Facebook Login, or Apple.

You can also create new password-authenticated users from the Authentication
section of the [Firebase console](https://console.firebase.google.com/), on the Users page.

## Get a user's profile

To get a user's profile information, use the properties of `User`. There are
three ways to get a `User` object representing the current user:

- The `authStateChanges`, `idTokenChanges` and `userChanges` streams: your
  listeners will receive the current `User`, or `null` if no user is
  authenticated:

  ```dart
  FirebaseAuth.instance
    .authStateChanges()
    .listen((User? user) {
      if (user != null) {
        print(user.uid);
      }
    });
  ```

  When the app starts, an event fires after the user credentials (if any) from
  local storage have been restored, meaning that your listeners always get
  called when the user state is initialized. Then, whenever the authentication
  state changes, a new event will be raised with the updated user state.

  By listening to the authentication state, you can build a user interface that
  reacts to these changes in authentication state.

- The `UserCredential` object returned by the authentication (`signIn`-)
  methods: the `UserCredential` object has a `user` property with the current
  `User`:

  ```dart
  final userCredential =
      await FirebaseAuth.instance.signInWithCredential(credential);
  final user = userCredential.user;
  print(user?.uid);
  ```

- The `currentUser` property of the `FirebaseAuth` instance: if you are sure the
  user is currently signed-in, you can access the `User` from the `currentUser`
  property:

  ```dart
  if (FirebaseAuth.instance.currentUser != null) {
    print(FirebaseAuth.instance.currentUser?.uid);
  }
  ```

  The `currentUser` can be `null` for two reasons:

  - The user isn't signed in.
  - The auth object has not finished initializing. If you use a listener to keep
    track of the user's sign-in status, you don't need to handle this case.


## Get a user's provider-specific profile information

To get the profile information retrieved from the sign-in providers linked to a
user, use the `providerData` property. For example:

```dart
if (user != null) {
    for (final providerProfile in user.providerData) {
        // ID of the provider (google.com, apple.com, etc.)
        final provider = providerProfile.providerId;

        // UID specific to the provider
        final uid = providerProfile.uid;

        // Name, email address, and profile photo URL
        final name = providerProfile.displayName;
        final emailAddress = providerProfile.email;
        final profilePhoto = providerProfile.photoURL;
    }
}
```

## Update a user's profile

You can update a user's basic profile information&mdash;the user's display name
and profile photo URL&mdash;with the `update`- methods. For example:

```dart
await user?.updateDisplayName("Jane Q. User");
await user?.updatePhotoURL("https://example.com/jane-q-user/profile.jpg");
```

## Set a user's email address

You can set a user's email address with the `updateEmail()` method. For example:

```dart
await user?.updateEmail("janeq@example.com");
```

Note: To set a user's email address, the user must have signed in recently.
See [Re-authenticate a user](#re-authenticate_a_user).

## Send a user a verification email {:#verify-email}

You can send an address verification email to a user with the
`sendEmailVerification()` method. For example:

```dart
await user?.sendEmailVerification();
```

You can customize the email template that is used in Authentication section of
the [Firebase console](https://console.firebase.google.com/), on the Email Templates page.
See [Email Templates](https://support.google.com/firebase/answer/7000714) in
Firebase Help Center.

It is also possible to pass state via a
[continue URL](passing-state-in-email-actions) to redirect back
to the app when sending a verification email.

Additionally you can localize the verification email by updating the language
code on the Auth instance before sending the email. For example:

```dart
await FirebaseAuth.instance.setLanguageCode("fr");
await user?.sendEmailVerification();
```

## Set a user's password

You can set a user's password with the `updatePassword()` method. For example:

```dart
await user?.updatePassword(newPassword);
```

Important: To set a user's email address, the user must have signed in recently.
See [Re-authenticate a user](#re-authenticate_a_user).

## Send a password reset email

You can send a password reset email to a user with the `sendPasswordResetEmail()`
method. For example:

```dart
await FirebaseAuth.instance
    .sendPasswordResetEmail(email: "user@example.com");
```

You can customize the email template that is used in Authentication section of
the [Firebase console](https://console.firebase.google.com/), on the Email Templates page.
See [Email Templates](https://support.google.com/firebase/answer/7000714) in
Firebase Help Center.

It is also possible to pass state via a
[continue URL](/docs/auth/android/passing-state-in-email-actions) to redirect back
to the app when sending a password reset email.

Additionally you can localize the password reset email by updating the language
code on the Auth instance before sending the email. For example:

```dart
await FirebaseAuth.instance.setLanguageCode("fr");
```

You can also send password reset emails from the Firebase console.

## Delete a user

You can delete a user account with the `delete()` method. For example:

```dart
await user?.delete();
```

Important: To set a user's email address, the user must have signed in recently.
See [Re-authenticate a user](#re-authenticate_a_user).


You can also delete users from the Authentication section of the
[Firebase console](https://console.firebase.google.com/), on the Users page.

## Re-authenticate a user

Some security-sensitive actions&mdash;such as
[deleting an account](#delete_a_user),
[setting a primary email address](#set_a_users_email_address), and
[changing a password](#set_a_users_password)&mdash;require that the user has
recently signed in. If you perform one of these actions, and the user signed in
too long ago, the action fails and throws a `FirebaseAuthException` with the code
`requires-recent-login`.
When this happens, re-authenticate the user by getting new sign-in credentials
from the user and passing the credentials to `reauthenticate`. For example:

```dart
// Prompt the user to re-provide their sign-in credentials.
// Then, use the credentials to reauthenticate:
await user?.reauthenticateWithCredential(credential);
```

## Import user accounts

You can import user accounts from a file into your Firebase project by using the
Firebase CLI's [`auth:import`](/docs/cli/auth-import) command. For example:

```bash
firebase auth:import users.json --hash-algo=scrypt --rounds=8 --mem-cost=14
```



================================================
File: docs/flutter/auth/multi-factor.md
================================================
Project: /docs/_project.yaml
Book: /docs/_book.yaml

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# Add multi-factor authentication to your Flutter app

If you've upgraded to Firebase Authentication with Identity Platform,
 you can add SMS multi-factor authentication to your Flutter app.

Multi-factor authentication (MFA) increases the security of your app. While attackers
often compromise passwords and social accounts, intercepting a text message is
more difficult.

## Before you begin

Note: Using multi-factor authentication with
[multiple tenants](https://cloud.google.com/identity-platform/docs/multi-tenancy)
is not supported on Flutter.

1.  Enable at least one provider that supports multi-factor authentication.
    Every provider supports MFA, **except** phone auth, anonymous auth, and
    Apple Game Center.

1.  Ensure your app is verifying user emails. MFA requires email verification.
    This prevents malicious actors from registering for a service with an email
    they don't own, and then locking out the real owner by adding a second
    factor.

1. **Android**: If you haven't already set your app's SHA-256 hash in the
 [Firebase console](https://console.firebase.google.com/), do so.
 See [Authenticating Your Client](https://developers.google.com/android/guides/client-auth)
  for information about finding your app's SHA-256 hash.
1. **iOS**: In Xcode, [enable push notifications](http://help.apple.com/xcode/mac/current/#/devdfd3d04a1) for your project & ensure
   your APNs authentication key is [configured with Firebase Cloud Messaging (FCM)](/docs/cloud-messaging/ios/certs). Additionally, you must
   [enable background modes](https://help.apple.com/xcode/mac/current/#/deve49d0ba96) for remote notifications.
   To view an in-depth explanation of this step, view the [Firebase iOS Phone Auth](/docs/auth/ios/phone-auth) documentation.
1. **Web**: Ensure that you have added your applications domain on the [Firebase console](https://console.firebase.google.com/), under
   **OAuth redirect domains**.

## Enabling multi-factor authentication

1.  Open the [**Authentication > Sign-in method**](https://console.firebase.google.com/project/_/authentication/providers)
    page of the Firebase console.

1.  In the **Advanced** section, enable **SMS Multi-factor Authentication**.

    You should also enter the phone numbers you'll be testing your app with.
    While optional, registering test phone numbers is strongly recommended to
    avoid throttling during development.

1.  If you haven't already authorized your app's domain, add it to the allow
    list on the [**Authentication > Settings**](https://console.firebase.google.com/project/_/authentication/settings)
    page of the Firebase console.

## Choosing an enrollment pattern

You can choose whether your app requires multi-factor authentication, and how
and when to enroll your users. Some common patterns include:

* Enroll the user's second factor as part of registration. Use this
  method if your app requires multi-factor authentication for all users.

* Offer a skippable option to enroll a second factor during registration. Apps
  that want to encourage, but not require, multi-factor authentication might
  prefer this approach.

* Provide the ability to add a second factor from the user's account or profile
  management page, instead of the sign up screen. This minimizes friction during
  the registration process, while still making multi-factor authentication
  available for security-sensitive users.

* Require adding a second factor incrementally when the user wants to access
  features with increased security requirements.

## Enrolling a second factor

To enroll a new secondary factor for a user:

1.  Re-authenticate the user.

1.  Ask the user enter their phone number.

    Note: Google stores and uses phone numbers to improve spam and abuse
    prevention across all Google services. Ensure you obtain appropriate consent
    from your users before sending their phone numbers to
    Firebase.

1.  Get a multi-factor session for the user:

  ```dart
  final multiFactorSession = await user.multiFactor.getSession();
  ```


1.  Verify the phone number with a multi factor session and your callbacks:

  ```dart
  await FirebaseAuth.instance.verifyPhoneNumber(
    multiFactorSession: multiFactorSession,
    phoneNumber: phoneNumber,
    verificationCompleted: (_) {},
    verificationFailed: (_) {},
    codeSent: (String verificationId, int? resendToken) async {
      // The SMS verification code has been sent to the provided phone number.
      // ...
    },
    codeAutoRetrievalTimeout: (_) {},
  ); 
  ```

1. Once the SMS code is sent, ask the user to verify the code:

  ```dart
  final credential = PhoneAuthProvider.credential(
    verificationId: verificationId,
    smsCode: smsCode,
  );
  ```

1. Complete the enrollment:

  ```dart
  await user.multiFactor.enroll(
    PhoneMultiFactorGenerator.getAssertion(
      credential,
    ),
  );
  ```

The code below shows a complete example of enrolling a second factor:

  ```dart
  final session = await user.multiFactor.getSession();
  final auth = FirebaseAuth.instance;
  await auth.verifyPhoneNumber(
    multiFactorSession: session,
    phoneNumber: phoneController.text,
    verificationCompleted: (_) {},
    verificationFailed: (_) {},
    codeSent: (String verificationId, int? resendToken) async {
      // See `firebase_auth` example app for a method of retrieving user's sms code: 
      // https://github.com/firebase/flutterfire/blob/main/packages/firebase_auth/firebase_auth/example/lib/auth.dart#L591
      final smsCode = await getSmsCodeFromUser(context);

      if (smsCode != null) {
        // Create a PhoneAuthCredential with the code
        final credential = PhoneAuthProvider.credential(
          verificationId: verificationId,
          smsCode: smsCode,
        );

        try {
          await user.multiFactor.enroll(
            PhoneMultiFactorGenerator.getAssertion(
              credential,
            ),
          );
        } on FirebaseAuthException catch (e) {
          print(e.message);
        }
      }
    },
    codeAutoRetrievalTimeout: (_) {},
  );
  ```

Congratulations! You successfully registered a second authentication factor for
a user.

Important: You should strongly encourage your users to register more than one
second factor for account recovery purposes. If a user only registers a single
second factor and later loses access to it, they will be locked out of their
account.

## Signing users in with a second factor

To sign in a user with two-factor SMS verification:

1.  Sign the user in with their first factor, then catch the
    `FirebaseAuthMultiFactorException` exception. This error contains a
    resolver, which you can use to obtain the user's enrolled second factors.
    It also contains an underlying session proving the user successfully
    authenticated with their first factor.

    For example, if the user's first factor was an email and password:

    ```dart
    try {
      await _auth.signInWithEmailAndPassword(
          email: emailController.text,
          password: passwordController.text,
      );
      // User is not enrolled with a second factor and is successfully
      // signed in.
      // ...
    } on FirebaseAuthMultiFactorException catch (e) {
      // The user is a multi-factor user. Second factor challenge is required
      final resolver = e.resolver
      // ...
    }
    ```

1.  If the user has multiple secondary factors enrolled, ask them which one
    to use:

    ```dart
    final session = e.resolver.session;

    final hint = e.resolver.hints[selectedHint];
    ```

1.  Send a verification message to the user's phone with the hint and
  multi-factor session:

    ```dart
    await FirebaseAuth.instance.verifyPhoneNumber(
      multiFactorSession: session,
      multiFactorInfo: hint,
      verificationCompleted: (_) {},
      verificationFailed: (_) {},
      codeSent: (String verificationId, int? resendToken) async {
        // ...
      },
      codeAutoRetrievalTimeout: (_) {},
    );
    ```

1.  Call `resolver.resolveSignIn()` to complete secondary authentication:

    ```dart
    final smsCode = await getSmsCodeFromUser(context);
    if (smsCode != null) {
      // Create a PhoneAuthCredential with the code
      final credential = PhoneAuthProvider.credential(
        verificationId: verificationId,
        smsCode: smsCode,
      );

      try {
        await e.resolver.resolveSignIn(
          PhoneMultiFactorGenerator.getAssertion(credential)
        );
      } on FirebaseAuthException catch (e) {
        print(e.message);
      }
    }
    ```

The code below shows a complete example of signing in a multi-factor user:

```dart
try {
  await _auth.signInWithEmailAndPassword(
    email: emailController.text,
    password: passwordController.text,
  );
} on FirebaseAuthMultiFactorException catch (e) {
  setState(() {
    error = '${e.message}';
  });
  final firstHint = e.resolver.hints.first;
  if (firstHint is! PhoneMultiFactorInfo) {
    return;
  }
  await FirebaseAuth.instance.verifyPhoneNumber(
    multiFactorSession: e.resolver.session,
    multiFactorInfo: firstHint,
    verificationCompleted: (_) {},
    verificationFailed: (_) {},
    codeSent: (String verificationId, int? resendToken) async {
      // See `firebase_auth` example app for a method of retrieving user's sms code: 
      // https://github.com/firebase/flutterfire/blob/main/packages/firebase_auth/firebase_auth/example/lib/auth.dart#L591
      final smsCode = await getSmsCodeFromUser(context);

      if (smsCode != null) {
        // Create a PhoneAuthCredential with the code
        final credential = PhoneAuthProvider.credential(
          verificationId: verificationId,
          smsCode: smsCode,
        );

        try {
          await e.resolver.resolveSignIn(
            PhoneMultiFactorGenerator.getAssertion(
              credential,
            ),
          );
        } on FirebaseAuthException catch (e) {
          print(e.message);
        }
      }
    },
    codeAutoRetrievalTimeout: (_) {},
  );
} catch (e) {
  ...
} 
```

Congratulations! You successfully signed in a user using multi-factor
authentication.

## What's next

* [Manage multi-factor users](/docs/auth/admin/manage-mfa-users)
  programmatically with the Admin SDK.



================================================
File: docs/flutter/auth/passing-state-in-email-actions.md
================================================
Project: /docs/_project.yaml
Book: /docs/_book.yaml

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# Passing State in Email Actions

You can pass state via a continue URL when sending email actions for password
resets or verifying a user's email. This provides the user the ability to be
returned to the app after the action is completed. In addition, you can specify
whether to handle the email action link directly from a mobile application when
it is installed instead of a web page.

This can be extremely useful in the following common scenarios:

* A user, not currently logged in, may be trying to access content that
  requires the user to be signed in. However, the user might have forgotten
  their password and therefore trigger the reset password flow. At the end of
  the flow, the user expects to go back to the section of the app they were
  trying to access.

* An application may only offer access to verified accounts. For
  example, a newsletter app may require the user to verify their email before
  subscribing. The user would go through the email verification flow and expect
  to be returned to the app to complete their subscription.

* In general, when a user begins a password reset or email verification flow on
  an Apple app they expect to complete the flow within the app; the ability to
  pass state via continue URL makes this possible.

Having the ability to pass state via a continue URL is a powerful feature that
Firebase Auth provides and which can significantly enhance the user experience.


## Passing state/continue URL in email actions

In order to securely pass a continue URL, the domain for the URL will need to
be allowlisted in the Firebase console.
This is done in the <b>Authentication</b> section by adding this domain to the
list of <b>Authorized domains</b> under the <b>Sign-in method</b> tab if it is not already there.

An `ActionCodeSettings` instance needs to be provided when sending
a password reset email or a verification email. This interface takes the
following parameters:

<table>
  <tr>
    <th>Parameter</th>
    <th>Type</th>
    <th>Description</th>
  </tr>
  <tr>
    <td><code>url</code></td>
    <td>String</td>
    <td><p>Sets the link (state/continue URL) which has different meanings
      in different contexts:</p>
      <ul>
        <li>When the link is handled in the web action widgets, this is the deep
          link in the <code>continueUrl</code> query parameter.</li>
        <li>When the link is handled in the app directly, this is the
          <code>continueUrl</code> query parameter in the deep link of the
          Dynamic Link.</li>
      </ul></td>
  </tr>
  <tr>
    <td><code>iOSBundleId</code></td>
    <td>String</td>
    <td>Sets the bundle ID. This will try to open the link in an Apple app if
      it is installed. The app needs to be registered in the Console. If no
      Bundle ID is provided, the value of this field is set to the bundle ID of
      the App's main bundle.</td>
  </tr>
  <tr>
    <td><code>androidPackageName</code></td>
    <td>String</td>
    <td>Sets the Android package name. This will try to open the link in an
      android app if it is installed.</td>
  </tr>
   <tr>
    <td><code>androidInstallApp</code></td>
    <td>bool</td>
    <td>Specifies whether to install the Android app if the device supports it
      and the app is not already installed. If this field is provided without a
      packageName, an error is thrown explaining that the packageName must be
      provided in conjunction with this field.</td>
  </tr>
  <tr>
    <td><code>androidMinimumVersion</code></td>
    <td>String</td>
    <td>The minimum version of the app that is supported in this flow. If
      minimumVersion is specified, and an older version of the app is installed,
      the user is taken to the Play Store to upgrade the app. The Android app
      needs to be registered in the Console.</td>
  </tr>
  <tr>
    <td><code>handleCodeInApp</code></td>
    <td>bool</td>
    <td>Whether the email action link will be opened in a mobile app or a web
      link first. The default is false. When set to true, the action code link
      will be be sent as a Universal Link or Android App Link and will be opened
      by the app if installed. In the false case, the code will be sent to the
      web widget first and then on continue will redirect to the app if
      installed.</td>
  </tr>
  <tr>
    <td><code>dynamicLinkDomain</code></td>
    <td>String</td>
    <td>Sets the dynamic link domain (or subdomain) to use for the current link
      if it is to be opened using Firebase Dynamic Links. As multiple dynamic
      link domains can be configured per project, this field provides the
      ability to explicitly choose one. If none is provided, the first domain
      is used by default.</td>
  </tr>
</table>

The following example illustrates how to send an email verification link that
will open in a mobile app first as a Firebase Dynamic Link using the custom
dynamic link domain `example.page.link`
(iOS app `com.example.ios` or Android app `com.example.android` where the app
will install if not already installed and the minimum version is `12`). The
deep link will contain the continue URL payload
`https://www.example.com/?email=user@example.com`.

```dart
final user = FirebaseAuth.instance.currentUser;

final actionCodeSettings = ActionCodeSettings(
  url: "http://www.example.com/verify?email=${user?.email}",
  iOSBundleId: "com.example.ios",
  androidPackageName: "com.example.android",
);

await user?.sendEmailVerification(actionCodeSettings);
```

## Configuring Firebase Dynamic Links

Firebase Auth uses [Firebase Dynamic Links](/docs/dynamic-links/) when sending a
link that is meant to be opened in a mobile application. In order to use this
feature, Dynamic Links need to be configured in the Firebase Console.

1.  Enable Firebase Dynamic Links:

    1.  In the Firebase console, open the <b>Dynamic Links</b> section.

    1.  If you have not yet accepted the Dynamic Links terms and created a Dynamic Links
        domain, do so now.

    1.  If you already created a Dynamic Links domain, take note of it. A Dynamic Links
        domain typically looks like the following example: <pre>example.page.link</pre>

    1.  You will need this value when you configure your Apple or Android app to
        intercept the incoming link.

1.  Configuring Android applications:
    1.  If you plan on handling these links from your Android application, the
        Android package name needs to be specified in the Firebase Console
        project settings. In addition, the SHA-1 and SHA-256 of the application
        certificate need to be provided.
    1.  You will also need to configure the intent filter for the deep link in
        you AndroidManifest.xml file.
    1.  For more on this, refer to
        [Receiving Android Dynamic Links instructions](/docs/dynamic-links/android/receive).

1.  Configuring Apple applications:
    1.  If you plan on handling these links from your application, the
        bundle ID needs to be specified in the Firebase Console
        project settings. In addition, the App Store ID and the Apple Developer
        Team ID also need to be specified.
    1.  You will also need to configure the FDL universal link domain as an
        Associated Domain in your application capabilities.
    1.  If you plan to distribute your application to iOS versions 8 and under,
        you will need to set your bundle ID as a custom scheme for incoming
        URLs.
    1.  For more on this, refer to
        [Receiving Apple platforms Dynamic Links instructions](/docs/dynamic-links/ios/receive).

## Handling email actions in a web application

You can specify whether you want to handle the action code link from a web
application first and then redirect to another web page or mobile application
after successful completion, provided the mobile application is available.
This is done by setting `handleCodeInApp` to `false` in the `ActionCodeSettings` object. While
a bundle ID
or Android package name are not required, providing them will allow the user
to redirect back to the specified app on email action code completion.

The web URL used here, is the one configured in the email action templates
section. A default one is provisioned for all projects. Refer to
[customizing email handlers](/docs/auth/custom-email-handler) to learn more on
how to customize the email action handler.

In this case, the link within the `continueURL` query parameter will be
an FDL link whose payload is the `URL` specified in the `ActionCodeSettings`
object. While you can intercept and handle the incoming link from your app
without any additional dependency, we recommend using the FDL client library to
parse the deep link for you.

<p>When handling email actions such as email verification, the action code from the
<code>oobCode</code> query parameter needs to be parsed from the deep link and then applied
via <code>applyActionCode</code> for the change to take effect, i.e. email to be verified.</p>


## Handling email actions in a mobile application

You can specify whether you want to handle the action code link within your
mobile application first, provided it is installed. With Android applications,
you also have the ability to specify via the `androidInstallApp` that
the app is to be installed if the device supports it and it is not already
installed.
If the link is clicked from a device that does not support the mobile
application, it is opened from a web page instead.
This is done by setting `handleCodeInApp` to `true` in the `ActionCodeSettings` object. The
mobile application's Android package name or bundle ID will also need to be
specified.The fallback web URL used here, when no mobile app is available, is
the one configured in the email action templates section. A default one is
provisioned for all projects. Refer to
[customizing email handlers](/docs/auth/custom-email-handler) to learn more on
how to customize the email action handler.

In this case, the mobile app link sent to the user will be an FDL link whose
payload is the action code URL, configured in the Console, with the query
parameters `oobCode`, `mode`, `apiKey` and `continueUrl`. The latter will be the
original `URL` specified in the
`ActionCodeSettings` object. While you can intercept and handle the
incoming link from your app without any additional dependency, we recommend
using the FDL client library to parse the deep link for you. The action code can
be applied directly from a mobile application similar to how it is handled from
the web flow described in the
[customizing email handlers](/docs/auth/custom-email-handler) section.


<p>When handling email actions such as email verification, the action code from the
<code>oobCode</code> query parameter needs to be parsed from the deep link and then applied
via <code>applyActionCode</code> for the change to take effect, i.e. email to be verified.</p>



================================================
File: docs/flutter/auth/password-auth.md
================================================
Project: /docs/_project.yaml
Book: /docs/_book.yaml

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# Authenticate with Firebase using Password-Based Accounts on Flutter

You can use Firebase Authentication to let your users authenticate with
Firebase using email addresses and passwords.

## Before you begin

1.  If you haven't already, follow the steps in the [Get started](start) guide.

1.  Enable Email/Password sign-in:

    - In the Firebase console's **Authentication** section, open the
      [Sign in method](https://console.firebase.google.com/project/_/authentication/providers)
      page.
    - From the **Sign in method** page, enable the **Email/password sign-in**
      method and click **Save**.

## Create a password-based account

To create a new user account with a password, call the `createUserWithEmailAndPassword()`
method:

```dart
try {
  final credential = await FirebaseAuth.instance.createUserWithEmailAndPassword(
    email: emailAddress,
    password: password,
  );
} on FirebaseAuthException catch (e) {
  if (e.code == 'weak-password') {
    print('The password provided is too weak.');
  } else if (e.code == 'email-already-in-use') {
    print('The account already exists for that email.');
  }
} catch (e) {
  print(e);
}
```

Typically, you would do this from your app's sign-up screen. When a new user
signs up using your app's sign-up form, complete any new account validation
steps that your app requires, such as verifying that the new account's password
was correctly typed and meets your complexity requirements.

If the new account was created successfully, the user is also signed in. If you
are listening to changes in [authentication state](start#auth-state), a new
event will be sent to your listeners.

As a follow-up to creating a new account, you can
[Verify the user's email address](manage-users#verify-email).

Note: To protect your project from abuse, Firebase limits the number of new
email/password and anonymous sign-ups that your application can have from the
same IP address in a short period of time. You can request and schedule
temporary changes to this quota from the
[Firebase console](https://console.firebase.google.com/project/_/authentication/providers).

## Sign in a user with an email address and password

The steps for signing in a user with a password are similar to the steps for
creating a new account. From your your app's sign-in screen, call
`signInWithEmailAndPassword()`:

```dart
try {
  final credential = await FirebaseAuth.instance.signInWithEmailAndPassword(
    email: emailAddress,
    password: password
  );
} on FirebaseAuthException catch (e) {
  if (e.code == 'user-not-found') {
    print('No user found for that email.');
  } else if (e.code == 'wrong-password') {
    print('Wrong password provided for that user.');
  }
}
```

Caution: When a user uninstalls your app on iOS or macOS, the user's authentication
state can persist between app re-installs, as the Firebase iOS SDK persists
authentication state to the system keychain.
See issue [#4661](https://github.com/firebase/flutterfire/issues/4661)
for more information.


## Next steps

After a user creates a new account, this account is stored as part of your
Firebase project, and can be used to identify a user across every app in your
project, regardless of what sign-in method the user used.

In your apps, you can get the user's basic profile information from the
`User` object. See [Manage Users](manage-users).

In your Firebase Realtime Database and Cloud Storage Security Rules, you can
get the signed-in user's unique user ID from the `auth` variable, and use it to
control what data a user can access.

You can allow users to sign in to your app using multiple authentication
providers by [linking auth provider credentials](account-linking)) to an
existing user account.

To sign out a user, call `signOut()`:

```dart
await FirebaseAuth.instance.signOut();
```



================================================
File: docs/flutter/auth/phone-auth.md
================================================
Project: /docs/_project.yaml
Book: /docs/_book.yaml

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# Phone Authentication

Phone authentication allows users to sign in to Firebase using their phone as the authenticator. An SMS message is sent
to the user (using the provided phone number) containing a unique code. Once the code has been authorized, the user is able to sign
into Firebase.

> Phone numbers that end users provide for authentication will be sent and stored by Google to improve spam and abuse
> prevention across Google service, including to, but not limited to Firebase. Developers should ensure they have the
> appropriate end-user consent prior to using the Firebase Authentication phone number sign-in service.authentication

Firebase Phone Authentication is not supported in all countries. Please see their [FAQs](/support/faq/#develop) for more information.

## Setup

Before starting with Phone Authentication, ensure you have followed these steps:

1. Enable Phone as a Sign-In method in the [Firebase console](https://console.firebase.google.com/u/0/project/_/authentication/providers).
2. **Android**: If you haven't already set your app's SHA-1 hash in the [Firebase console](https://console.firebase.google.com/), do so.
   See [Authenticating Your Client](https://developers.google.com/android/guides/client-auth) for information about finding your app's SHA-1 hash.
3. **iOS**: In Xcode, [enable push notifications](http://help.apple.com/xcode/mac/current/#/devdfd3d04a1) for your project & ensure
   your APNs authentication key is [configured with Firebase Cloud Messaging (FCM)](/docs/cloud-messaging/ios/certs). Additionally, you must
   [enable background modes](https://help.apple.com/xcode/mac/current/#/deve49d0ba96) for remote notifications.
   To view an in-depth explanation of this step, view the [Firebase iOS Phone Auth](/docs/auth/ios/phone-auth) documentation.
4. **Web**: Ensure that you have added your applications domain on the [Firebase console](https://console.firebase.google.com/), under
   **OAuth redirect domains**.

**Note**; Phone number sign-in is only available for use on real devices and the web. To test your authentication flow on device emulators,
please see [Testing](#testing).

## Usage

The Firebase Authentication SDK for Flutter provides two individual ways to sign a user in with their phone number. Native (e.g. Android & iOS) platforms provide
different functionality to validating a phone number than the web, therefore two methods exist for each platform exclusively:

- **Native Platform**: `verifyPhoneNumber`.
- **Web Platform**: `signInWithPhoneNumber`.

### Native: `verifyPhoneNumber`

On native platforms, the user's phone number must be first verified and then the user can either sign-in or link their account with a
`PhoneAuthCredential`.

First you must prompt the user for their phone number. Once provided, call the `verifyPhoneNumber()` method:

```dart
await FirebaseAuth.instance.verifyPhoneNumber(
  phoneNumber: '+44 7123 123 456',
  verificationCompleted: (PhoneAuthCredential credential) {},
  verificationFailed: (FirebaseAuthException e) {},
  codeSent: (String verificationId, int? resendToken) {},
  codeAutoRetrievalTimeout: (String verificationId) {},
);
```

Note: Depending on your billing plan, you might be limited to a daily quota of
SMS messages sent. See [Firebase Auth Limits](/docs/auth/limits#phone-auth).

There are 4 separate callbacks that you must handle, each will determine how you update the application UI:

1. **[verificationCompleted](#verificationCompleted)**: Automatic handling of the SMS code on Android devices.
2. **[verificationFailed](#verificationFailed)**: Handle failure events such as invalid phone numbers or whether the SMS quota has been exceeded.
3. **[codeSent](#codeSent)**: Handle when a code has been sent to the device from Firebase, used to prompt users to enter the code.
4. **[codeAutoRetrievalTimeout](#codeAutoRetrievalTimeout)**: Handle a timeout of when automatic SMS code handling fails.

#### verificationCompleted

This handler will only be called on Android devices which support automatic SMS code resolution.

When the SMS code is delivered to the device, Android will automatically verify the SMS code without
requiring the user to manually input the code. If this event occurs, a `PhoneAuthCredential` is automatically provided which can be
used to sign-in with or link the user's phone number.

```dart
FirebaseAuth auth = FirebaseAuth.instance;

await auth.verifyPhoneNumber(
  phoneNumber: '+44 7123 123 456',
  verificationCompleted: (PhoneAuthCredential credential) async {
    // ANDROID ONLY!

    // Sign the user in (or link) with the auto-generated credential
    await auth.signInWithCredential(credential);
  },
);
```

#### verificationFailed

If Firebase returns an error, for example for an incorrect phone number or if the SMS quota for the project has exceeded,
a `FirebaseAuthException` will be sent to this handler. In this case, you would prompt your user something went wrong depending on the error
code.

```dart
FirebaseAuth auth = FirebaseAuth.instance;

await auth.verifyPhoneNumber(
  phoneNumber: '+44 7123 123 456',
  verificationFailed: (FirebaseAuthException e) {
    if (e.code == 'invalid-phone-number') {
      print('The provided phone number is not valid.');
    }

    // Handle other errors
  },
);
```

#### codeSent

When Firebase sends an SMS code to the device, this handler is triggered with a `verificationId` and `resendToken` (A `resendToken`
is only supported on Android devices, iOS devices will _always_ return a `null` value).

Once triggered, it would be a good time to update your application UI to prompt the user to enter the SMS code they're expecting.
Once the SMS code has been entered, you can combine the verification ID with the SMS code to create a new `PhoneAuthCredential`:

```dart
FirebaseAuth auth = FirebaseAuth.instance;

await auth.verifyPhoneNumber(
  phoneNumber: '+44 7123 123 456',
  codeSent: (String verificationId, int? resendToken) async {
    // Update the UI - wait for the user to enter the SMS code
    String smsCode = 'xxxx';

    // Create a PhoneAuthCredential with the code
    PhoneAuthCredential credential = PhoneAuthProvider.credential(verificationId: verificationId, smsCode: smsCode);

    // Sign the user in (or link) with the credential
    await auth.signInWithCredential(credential);
  },
);
```

By default, Firebase will not re-send a new SMS message if it has been recently sent. You can however override this behavior
by re-calling the `verifyPhoneNumber` method with the resend token to the `forceResendingToken` argument.
If successful, the SMS message will be resent.

#### codeAutoRetrievalTimeout

On Android devices which support automatic SMS code resolution, this handler will be called if the device has not automatically
resolved an SMS message within a certain timeframe. Once the timeframe has passed, the device will no longer attempt to resolve
any incoming messages.

By default, the device waits for 30 seconds however this can be customized with the `timeout` argument:

```dart
FirebaseAuth auth = FirebaseAuth.instance;

await auth.verifyPhoneNumber(
  phoneNumber: '+44 7123 123 456',
  timeout: const Duration(seconds: 60),
  codeAutoRetrievalTimeout: (String verificationId) {
    // Auto-resolution timed out...
  },
);
```

### Web: `signInWithPhoneNumber`

On web platforms, users can sign-in by confirming they have access to a phone by entering the SMS code sent to the provided phone number.
For added security and spam prevention, users are requested to prove they are human by completing a [Google reCAPTCHA](https://www.google.com/recaptcha/about/)
widget. Once confirmed, the SMS code will be sent.

The Firebase Authentication SDK for Flutter will manage the reCAPTCHA widget out of the box by default, however provides control over how it is displayed and configured if required.
To get started, call the `signInWithPhoneNumber` method with the phone number.

```dart
FirebaseAuth auth = FirebaseAuth.instance;

// Wait for the user to complete the reCAPTCHA & for an SMS code to be sent.
ConfirmationResult confirmationResult = await auth.signInWithPhoneNumber('+44 7123 123 456');
```

Calling the method will first trigger the reCAPTCHA widget to display. The user must complete the
test before an SMS code is sent. Once complete, you can then sign the user in by providing the
SMS code to the `confirm` method on the resolved `ConfirmationResult` response:

```dart
UserCredential userCredential = await confirmationResult.confirm('123456');
```

Like other sign-in flows, a successful sign-in will trigger any authentication state listeners
you have subscribed throughout your application.

#### reCAPTCHA Configuration

The reCAPTCHA widget is a fully managed flow which provides security to your web application.

The second argument of `signInWithPhoneNumber` accepts an optional `RecaptchaVerifier` instance which can be used
to manage the widget. By default, the widget will render as an invisible widget when the sign-in flow is triggered.
An "invisible" widget will appear as a full-page modal on-top of your application.

It is however possible to display an inline widget which the user has to explicitly press to verify themselves.

To add an inline widget, specify a DOM element ID to the `container` argument of the `RecaptchaVerifier` instance.
The element must exist and be empty otherwise an error will be thrown.
If no `container` argument is provided, the widget will be rendered as "invisible".

```dart
ConfirmationResult confirmationResult = await auth.signInWithPhoneNumber('+44 7123 123 456', RecaptchaVerifier(
  container: 'recaptcha',
  size: RecaptchaVerifierSize.compact,
  theme: RecaptchaVerifierTheme.dark,
));
```

You can optionally change the size and theme by customizing the `size` and `theme` arguments as shown above.

It is also possible to listen to events, such as whether the reCAPTCHA has been completed by the user, whether
the reCAPTCHA has expired or an error was thrown:

```dart
RecaptchaVerifier(
  onSuccess: () => print('reCAPTCHA Completed!'),
  onError: (FirebaseAuthException error) => print(error),
  onExpired: () => print('reCAPTCHA Expired!'),
);
```

## Testing

Firebase provides support for locally testing phone numbers:

1. On the Firebase Console, select the "Phone" authentication provider and click on the "Phone numbers for testing" dropdown.
2. Enter a new phone number (e.g. `+44 7444 555666`) and a test code (e.g. `123456`).

If providing a test phone number to either the `verifyPhoneNumber` or `signInWithPhoneNumber` methods, no SMS will actually be sent. You
can instead provide the test code directly to the `PhoneAuthProvider` or with `signInWithPhoneNumber`s confirmation result handler.



================================================
File: docs/flutter/auth/start.md
================================================
Project: /docs/_project.yaml
Book: /docs/_book.yaml

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# Get Started with Firebase Authentication on Flutter

## Connect your app to Firebase

[Install and initialize the Firebase SDKs for Flutter](/docs/flutter/setup) if you haven't already done
so.

## Add Firebase Authentication to your app

1.  From the root of your Flutter project, run the following command to install
    the plugin:

    ```bash
    flutter pub add firebase_auth
    ```

1.  Once complete, rebuild your Flutter application:

    ```bash
    flutter run
    ```

1.  Import the plugin in your Dart code:

    ```dart
    import 'package:firebase_auth/firebase_auth.dart';
    ```

To use an authentication provider, you need to enable it in the [Firebase console](https://console.firebase.google.com/).
Go to the Sign-in Method page in the Firebase Authentication section to enable
Email/Password sign-in and any other identity providers you want for your app.

## (Optional) Prototype and test with Firebase Local Emulator Suite

Before talking about how your app authenticates users, let's introduce a set of
tools you can use to prototype and test Authentication functionality:
Firebase Local Emulator Suite. If you're deciding among authentication techniques
and providers, trying out different data models with public and private data
using Authentication and Firebase Security Rules, or prototyping sign-in UI designs, being able to
work locally without deploying live services can be a great idea.

An Authentication emulator is part of the Local Emulator Suite, which
enables your app to interact with emulated database content and config, as
well as optionally your emulated project resources (functions, other databases,
and security rules).

Using the Authentication emulator involves just a few steps:

1.  Adding a line of code to your app's test config to connect to the emulator.

1.  From the root of your local project directory, running `firebase emulators:start`.

1.  Using the Local Emulator Suite UI for interactive prototyping, or the
    Authentication emulator REST API for non-interactive testing.

1.  Call `useAuthEmulator()` to specify the emulator address and port:

    ```dart
    Future<void> main() async {
    WidgetsFlutterBinding.ensureInitialized();
    await Firebase.initializeApp();

    // Ideal time to initialize
    await FirebaseAuth.instance.useAuthEmulator('localhost', 9099);
    //...
    }
    ```

A detailed guide is available at [Connect your app to the Authentication emulator](/docs/emulator-suite/connect_auth).
For more information, see the [Local Emulator Suite introduction](/docs/emulator-suite/).

Now let's continue with how to authenticate users.

## Check current auth state {:#auth-state}

Firebase Auth provides many methods and utilities for enabling you to integrate
secure authentication into your new or existing Flutter application. In many
cases, you will need to know about the authentication _state_ of your user,
such as whether they're logged in or logged out.

Firebase Auth enables you to subscribe in realtime to this state via a
[`Stream`](https://api.flutter.dev/flutter/dart-async/Stream-class.html).
Once called, the stream provides an immediate event of the user's current
authentication state, and then provides subsequent events whenever
the authentication state changes.

There are three methods for listening to authentication state changes:

### `authStateChanges()`

To subscribe to these changes, call the `authStateChanges()` method on your
`FirebaseAuth` instance:

```dart
FirebaseAuth.instance
  .authStateChanges()
  .listen((User? user) {
    if (user == null) {
      print('User is currently signed out!');
    } else {
      print('User is signed in!');
    }
  });
```

Events are fired when the following occurs:

- Right after the listener has been registered.
- When a user is signed in.
- When the current user is signed out.

### `idTokenChanges()`

To subscribe to these changes, call the `idTokenChanges()` method on your
`FirebaseAuth` instance:

```dart
FirebaseAuth.instance
  .idTokenChanges()
  .listen((User? user) {
    if (user == null) {
      print('User is currently signed out!');
    } else {
      print('User is signed in!');
    }
  });
```

Events are fired when the following occurs:

- Right after the listener has been registered.
- When a user is signed in.
- When the current user is signed out.
- When there is a change in the current user's token.

{{'<aside>'}}
If you set custom claims using the Firebase Admin SDK,
you will only see this event fire when the following occurs:

- A user signs in or re-authenticates after the custom claims are modified. The
  ID token issued as a result will contain the latest claims.
- An existing user session gets its ID token refreshed after an older token expires.
- An ID token is force refreshed by calling `FirebaseAuth.instance.currentUser.getIdTokenResult(true)`.

For further details, see [Propagating custom claims to the client](/docs/auth/admin/custom-claims#propagate_custom_claims_to_the_client)
  {{'</aside>'}}


### `userChanges()`

To subscribe to these changes, call the `userChanges()` method on your
`FirebaseAuth` instance:

```dart
FirebaseAuth.instance
  .userChanges()
  .listen((User? user) {
    if (user == null) {
      print('User is currently signed out!');
    } else {
      print('User is signed in!');
    }
  });
```

Events are fired when the following occurs:

- Right after the listener has been registered.
- When a user is signed in.
- When the current user is signed out.
- When there is a change in the current user's token.
- When the following methods provided by `FirebaseAuth.instance.currentUser` are called:
    * `reload()`
    * `unlink()`
    * `updateEmail()`
    * `updatePassword()`
    * `updatePhoneNumber()`
    * `updateProfile()`

{{'<aside>'}}
`idTokenChanges()`, `userChanges()` & `authStateChanges()` will not fire if you
update the `User` profile with the Firebase Admin SDK. You will have to force a
reload using `FirebaseAuth.instance.currentUser.reload()` to retrieve the latest
`User` profile.

`idTokenChanges()`, `userChanges()` & `authStateChanges()` will also not fire
if you disable or delete the `User` with the Firebase Admin SDK or the Firebase
console. You will have to force a reload using
`FirebaseAuth.instance.currentUser.reload()`, which will cause a `user-disabled`
or `user-not-found` exception that you can catch and handle in your app code.
{{'</aside>'}}


## Persisting authentication state

The Firebase SDKs for all platforms provide out of the box support for ensuring
that your user's authentication state is persisted across app restarts or page
reloads.

On native platforms such as Android & iOS, this behavior is not configurable
and the user's authentication state will be persisted on device between app
restarts. The user can clear the apps cached data using the device settings,
which will wipe any existing state being stored.

On web platforms, the user's authentication state is stored in
[IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API).
You can change the persistence to store data in the [local storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage)
using `Persistence.LOCAL`.
If required, you can change this default behavior to only persist
authentication state for the current session, or not at all. To configure these
settings, call the following method `FirebaseAuth.instanceFor(app: Firebase.app(), persistence: Persistence.LOCAL);`.
You can still update the persistence for each Auth instance using `setPersistence(Persistence.NONE)`.

```dart
// Disable persistence on web platforms. Must be called on initialization:
final auth = FirebaseAuth.instanceFor(app: Firebase.app(), persistence: Persistence.NONE);
// To change it after initialization, use `setPersistence()`:
await auth.setPersistence(Persistence.LOCAL);
```

## Next Steps

Explore the guides on signing in and signing up users with the supported
identity and authentication services.



================================================
File: docs/flutter/cloud-messaging/client.md
================================================
Project: /docs/cloud-messaging/_project.yaml
Book: /docs/_book.yaml
page_type: guide

{% include "_shared/apis/console/_local_variables.html" %}
{% include "_local_variables.html" %}
{% include "docs/cloud-messaging/_local_variables.html" %}
{% include "docs/android/_local_variables.html" %}

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# Set up a Firebase Cloud Messaging client app on Flutter

Follow these steps to set up an FCM client on Flutter.

## Platform-specific setup and requirements

Some of the required steps depend on the platform you're targeting.

### iOS+

#### Enable app capabilities in Xcode

Before your application can start to receive messages, you must enable push
notifications and background modes in your Xcode project.

1.  Open your Xcode project workspace (`ios/Runner.xcworkspace`).
1.  [Enable push notifications](https://help.apple.com/xcode/mac/current/#/devdfd3d04a1){:.external}.
1.  Enable the **Background fetch** and the **Remote notifications**
    [background execution modes](https://developer.apple.com/documentation/xcode/configuring-background-execution-modes){:.external}.

#### Upload your APNs authentication key

Before you use FCM, upload your APNs certificate to Firebase. If you don't
already have an APNs certificate, create one in the
[Apple Developer Member Center](https://developer.apple.com/membercenter/index.action).

1.  Inside your project in the Firebase console, select the gear icon, select
    **Project Settings**, and then select the **Cloud Messaging** tab.
1.  Select the **Upload Certificate** button for your development certificate,
    your production certificate, or both. At least one is required.
1.  For each certificate, select the .p12 file, and provide the password, if
    any. Make sure the bundle ID for this certificate matches the bundle ID of
    your app. Select **Save**.

#### Method swizzling

To use the FCM Flutter plugin on Apple devices, you must not disable method
swizzling. Swizzling is required, and without it, key Firebase features such as
FCM token handling do not function properly.

### Android

#### Google Play services

FCM clients require devices running Android 4.4 or higher that also have Google
Play services installed, or an emulator running Android 4.4 with Google APIs.
Note that you are not limited to deploying your Android apps through Google Play
Store.

Apps that rely on the Play Services SDK should always check the device for a
compatible Google Play services APK before accessing Google Play services
features. It is recommended to do this in two places: in the main activity's
`onCreate()` method, and in its `onResume()` method. The check in `onCreate()`
ensures that the app can't be used without a successful check. The check in
`onResume()` ensures that if the user returns to the running app through some
other means, such as through the back button, the check is still performed.

If the device doesn't have a compatible version of Google Play services, your
app can call [`GoogleApiAvailability.makeGooglePlayServicesAvailable()`](//developers.google.com/android/reference/com/google/android/gms/common/GoogleApiAvailability.html#public-methods) to allow users to download Google Play services from the Play Store.

### Web

#### Configure Web Credentials with FCM

The FCM Web interface uses Web credentials called "Voluntary Application Server
Identification," or "VAPID" keys, to authorize send requests to supported web
push services. To subscribe your app to push notifications, you need to
associate a pair of keys with your Firebase project. You can either generate a
new key pair or import your existing key pair through the Firebase console.

##### Generate a new key pair

1.  Open the [Cloud Messaging](//console.firebase.google.com/project/_/settings/cloudmessaging/)
    tab of the Firebase console **Settings** pane and scroll to the
    **Web configuration** section.

1.  In the **Web Push certificates** tab, click **Generate Key Pair**. The
    console displays a notice that the key pair was generated, and displays the
    public key string and date added.

##### Import an existing key pair

If you have an existing key pair you are already using with your web app, you
can import it to FCM so that you can reach your existing web app
instances through FCM APIs. To import keys, you must have
owner-level access to the Firebase project. Import your existing public and
private key in base64 URL safe encoded form:

1.  Open the [Cloud Messaging](//console.firebase.google.com/project/_/settings/cloudmessaging/)
    tab of the Firebase console **Settings** pane and scroll to the
    **Web configuration** section.

1.  In the **Web Push certificates** tab, find and select the link text, "import
    an existing key pair."

1.  In the **Import a key pair** dialog, provide your public and private keys in
    the corresponding fields and click **Import**. The console displays the
    public key string and date added.

For more information about the format of the keys and how to generate them,
see [Application server keys](https://developers.google.com/web/fundamentals/push-notifications/web-push-protocol#application_server_keys).


## Install the FCM plugin


1.  [Install and initialize the Firebase plugins for Flutter](/docs/flutter/setup)
    if you haven't already done so.

1.  From the root of your Flutter project, run the following command to install
    the plugin:

    ```bash
    flutter pub add firebase_messaging
    ```

1.  Once complete, rebuild your Flutter application:

    ```bash
    flutter run
    ```


## Access the registration token

To send a message to a specific device, you need to know that device's
registration token. Because you'll need to enter the token in a field in the
Notifications console to complete this tutorial, make sure to copy the token
or securely store it after you retrieve it.

To retrieve the current registration token for an app instance, call
`getToken()`. If notification permission has not been granted, this method will
ask the user for notification permissions. Otherwise, it returns a token or
rejects the future due to an error.

Warning: In iOS SDK 10.4.0 and higher, it is a requirement that the APNs token
is available before making API requests. The APNs token is not guaranteed to
have been received before making FCM plugin API requests.

```dart
// You may set the permission requests to "provisional" which allows the user to choose what type
// of notifications they would like to receive once the user receives a notification.
final notificationSettings = await FirebaseMessaging.instance.requestPermission(provisional: true);

// For apple platforms, ensure the APNS token is available before making any FCM plugin API calls
final apnsToken = await FirebaseMessaging.instance.getAPNSToken();
if (apnsToken != null) {
 // APNS token is available, make FCM plugin API requests...
}
```

On web platforms, pass your VAPID public key to `getToken()`:

```dart
final fcmToken = await FirebaseMessaging.instance.getToken(vapidKey: "BKagOny0KF_2pCJQ3m....moL0ewzQ8rZu");
```

To be notified whenever the token is updated, subscribe to the `onTokenRefresh`
stream:

```dart
FirebaseMessaging.instance.onTokenRefresh
    .listen((fcmToken) {
      // TODO: If necessary send token to application server.

      // Note: This callback is fired at each app startup and whenever a new
      // token is generated.
    })
    .onError((err) {
      // Error getting token.
    });
```


## Prevent auto initialization {:#prevent-auto-init}

When an FCM registration token is generated, the library uploads
the identifier and configuration data to Firebase. If you prefer to prevent
token autogeneration, disable auto-initialization at build time.

#### iOS

On iOS, add a metadata value to your `Info.plist`:

```
FirebaseMessagingAutoInitEnabled = NO
```


#### Android

On Android, disable Analytics collection and FCM auto initialization (you must
disable both) by adding these metadata values to your `AndroidManifest.xml`:

```xml
<meta-data
    android:name="firebase_messaging_auto_init_enabled"
    android:value="false" />
<meta-data
    android:name="firebase_analytics_collection_enabled"
    android:value="false" />
```

### Re-enable FCM auto-init at runtime

To enable auto-init for a specific app instance, call `setAutoInitEnabled()`:

```dart
await FirebaseMessaging.instance.setAutoInitEnabled(true);
```

This value persists across app restarts once set.

## Next steps

After the client app is set up, you are ready to start sending downstream
messages with the
[Notifications composer](//console.firebase.google.com/project/_/notification).
See [Send a test message to a backgrounded app](first-message).

To add other, more advanced behavior to your app, you'll need a
[server implementation](/docs/cloud-messaging/server).

Then, in your app client:

- [Receive messages](/docs/cloud-messaging/flutter/receive)
- [Subscribe to message topics](/docs/cloud-messaging/flutter/topic-messaging)



================================================
File: docs/flutter/cloud-messaging/first-message.md
================================================
Project: /docs/cloud-messaging/_project.yaml
Book: /docs/_book.yaml
page_type: guide

{% include "_shared/apis/console/_local_variables.html" %}
{% include "_local_variables.html" %}
{% include "docs/cloud-messaging/_local_variables.html" %}
{% include "docs/android/_local_variables.html" %}

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# Send a test message to a backgrounded app

To get started with FCM, build out the simplest use case: sending a
test notification message from the
<a href="//console.firebase.google.com/project/_/notification">
Notifications composer</a> to a development device
when the app is in the background on the device.
This page lists all the steps to achieve this, from setup to verification
&mdash; it may cover steps you already completed if you
have [set up a Flutter app](/docs/cloud-messaging/flutter/client)
for FCM.

Important: This guide focuses on the background case. If you want to receive
messages when your app is in the foreground as well, see also
[Receive Messages in a Flutter App](/docs/cloud-messaging/flutter/receive).


## Install the FCM plugin

1.  [Install and initialize the Firebase SDKs for Flutter](/docs/flutter/setup)
    if you haven't already done so.

1.  From the root of your Flutter project, run the following command to install
    the plugin:

    ```bash
    flutter pub add firebase_messaging
    ```

1.  Once complete, rebuild your Flutter application:

    ```bash
    flutter run
    ```


## Access the registration token

To send a message to a specific device, you need to know that device's
registration token. Because you'll need to enter the token in a field in the
Notifications console to complete this tutorial, make sure to copy the token
or securely store it after you retrieve it.

To retrieve the current registration token for an app instance, call
`getToken()`. If notification permission has not been granted, this method will
ask the user for notification permissions. Otherwise, it returns a token or
rejects the future due to an error.

```dart
final fcmToken = await FirebaseMessaging.instance.getToken();
```


## Send a test notification message

{# Google-internal include #}
<<../_send-to-device.md>>

For insight into message delivery to your app, see the
<a href="//console.firebase.google.com/project/_/notification/reporting">FCM reporting dashboard</a>,
which records the number of messages sent and opened on Apple and Android
devices, along with data for "impressions" (notifications seen by users) for
Android apps.

## Handling interaction

When users tap a notification, the default behavior on both Android & iOS is to open the application. If the application is terminated,
it will be started, and if it is in the background, it will be brought to the foreground.

Depending on the content of a notification, you may want to handle the user's interaction when the application
opens. For example, if a new chat message is sent using a notification and the user selects it, you may want to
 open the specific conversation when the application opens.

The `firebase-messaging` package provides two ways to handle this interaction:

1. `getInitialMessage()`: If the application is opened from a terminated state, this method returns a `Future` containing a `RemoteMessage`. Once consumed, the `RemoteMessage` will be removed.
2. `onMessageOpenedApp`: A `Stream` which posts a `RemoteMessage` when the application is opened from a
    background state.

To ensure a smooth experience for your users, you should handle both scenarios. The code example
below outlines how this can be achieved:

```dart
class Application extends StatefulWidget {
  @override
  State<StatefulWidget> createState() => _Application();
}

class _Application extends State<Application> {
  // In this example, suppose that all messages contain a data field with the key 'type'.
  Future<void> setupInteractedMessage() async {
    // Get any messages which caused the application to open from
    // a terminated state.
    RemoteMessage? initialMessage =
        await FirebaseMessaging.instance.getInitialMessage();

    // If the message also contains a data property with a "type" of "chat",
    // navigate to a chat screen
    if (initialMessage != null) {
      _handleMessage(initialMessage);
    }

    // Also handle any interaction when the app is in the background via a
    // Stream listener
    FirebaseMessaging.onMessageOpenedApp.listen(_handleMessage);
  }

  void _handleMessage(RemoteMessage message) {
    if (message.data['type'] == 'chat') {
      Navigator.pushNamed(context, '/chat',
        arguments: ChatArguments(message),
      );
    }
  }

  @override
  void initState() {
    super.initState();

    // Run code required to handle interacted messages in an async function
    // as initState() must not be async
    setupInteractedMessage();
  }

  @override
  Widget build(BuildContext context) {
    return Text("...");
  }
}
```

How you handle interaction depends on your application setup. The example above
shows a basic example of using a `StatefulWidget`.

## Next steps

### Send messages to foregrounded apps

Once you have successfully sent notification messages while your app is in
the background, see
[Receive Messages in a Flutter App](/docs/cloud-messaging/flutter/receive)
to get started sending to foregrounded apps.

### Go beyond notification messages

To add other, more advanced behavior to your app, you'll need a
[server implementation](/docs/cloud-messaging/server).

Then, in your app client:

- [Receive messages](/docs/cloud-messaging/flutter/receive)
- [Subscribe to message topics](/docs/cloud-messaging/flutter/topic-messaging)




================================================
File: docs/flutter/cloud-messaging/receive.md
================================================
Project: /docs/cloud-messaging/_project.yaml
Book: /docs/_book.yaml
page_type: guide

{% include "_shared/apis/console/_local_variables.html" %}
{% include "_local_variables.html" %}
{% include "docs/cloud-messaging/_local_variables.html" %}
{% include "docs/android/_local_variables.html" %}

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# Receive messages in a Flutter app

Depending on a device's state, incoming messages are handled differently. To
understand these scenarios and how to integrate FCM into your own application, it
is first important to establish the various states a device can be in:

| State          | Description                                                      |
| -------------- | ---------------------------------------------------------------- |
| **Foreground** | When the application is open, in view and in use.                |
| **Background** | When the application is open, but in the background (minimized). |
: : This typically occurs when the user has pressed the "home" button
: : on the device, has switched to another app using the app switcher,
: : or has the application open in a different tab (web).
| **Terminated** | When the device is locked or the application is not running.

There are a few preconditions which must be met before the application can
receive message payloads via FCM:

- The application must have opened at least once (to allow for registration with FCM).
- On iOS, if the user swipes away the application from the app switcher, it must be manually reopened for background messages to start working again.
- On Android, if the user force-quits the app from device settings, it must be manually reopened for messages to start working.
- On web, you must have requested a token (using `getToken()`) with your web push certificate.

## Request permission to receive messages {:#permissions}

On iOS, macOS, web and Android 13 (or newer), before FCM payloads can be
received on your device, you must first ask the user's permission.

The `firebase_messaging` package provides a simple API for requesting permission via the [`requestPermission`](https://pub.dev/documentation/firebase_messaging/latest/firebase_messaging/FirebaseMessaging/requestPermission.html) method.
This API accepts a number of named arguments which define the type of permissions you'd like to request, such as whether
messaging containing notification payloads can trigger a sound or read out messages via Siri. By default,
the method requests sensible default permissions. The reference API provides full documentation on what each permission is for.

To get started, call the method from your application (on iOS a native modal will be displayed, on web
the browser's native API flow will be triggered):

```dart
FirebaseMessaging messaging = FirebaseMessaging.instance;

NotificationSettings settings = await messaging.requestPermission(
  alert: true,
  announcement: false,
  badge: true,
  carPlay: false,
  criticalAlert: false,
  provisional: false,
  sound: true,
);

print('User granted permission: ${settings.authorizationStatus}');
```

The `authorizationStatus` property of the `NotificationSettings` object returned from
the request can be used to determine the user's overall decision:

- `authorized`: The user granted permission.
- `denied`: The user denied permission.
- `notDetermined`: The user has not yet chosen whether to grant permission.
- `provisional`: The user granted provisional permission

Note: On Android versions prior to 13, `authorizationStatus` returns
`authorized` if the user has not disabled notifications for the app in the
operating system settings. On Android versions 13 and above, there is no way to determine if the user has chosen whether to grant/deny permission. A `denied` value conveys an undetermined or denied permission state, and it will be up to you to track if a permission request has been made.

The other properties on `NotificationSettings` return whether a specific permission is enabled, disabled or not supported on the current
device.

Once permission has been granted and the different types of device state have been understood, your application can now start to handle the incoming
FCM payloads.

## Message handling

Based on your application's current state, incoming payloads of different
[message types](/docs/cloud-messaging/concept-options#notifications_and_data_messages)
require different implementations to handle them:

### Foreground messages

To handle messages while your application is in the foreground, listen to the `onMessage` stream.

```dart
FirebaseMessaging.onMessage.listen((RemoteMessage message) {
  print('Got a message whilst in the foreground!');
  print('Message data: ${message.data}');

  if (message.notification != null) {
    print('Message also contained a notification: ${message.notification}');
  }
});
```

The stream contains a `RemoteMessage`, detailing
various information about the payload, such as where it was from, the unique ID, sent time, whether it contained
a notification and more. Since the message was retrieved whilst your application is in the foreground, you can directly access your Flutter
application's state and context.

#### Foreground and Notification messages

Notification messages which arrive while the application is in the foreground will not display a visible notification by default, on both
Android and iOS. It is, however, possible to override this behavior:

- On Android, you must create a "High Priority" notification channel.
- On iOS, you can update the presentation options for the application.

### Background messages

The process of handling background messages is different on native (Android and
Apple) and web based platforms.

#### Apple platforms and Android

Handle background messages by registering a `onBackgroundMessage` handler. When messages are received, an
isolate is spawned (Android only, iOS/macOS does not require a separate isolate) allowing you to handle messages even when your application is not running.

There are a few things to keep in mind about your background message handler:

1. It must not be an anonymous function.
2. It must be a top-level function (e.g. not a class method which requires initialization).
3. When using Flutter version 3.3.0 or higher, the message handler must be annotated with `@pragma('vm:entry-point')` right above the function declaration (otherwise it may be removed during tree shaking for release mode).

```dart
@pragma('vm:entry-point')
Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  // If you're going to use other Firebase services in the background, such as Firestore,
  // make sure you call `initializeApp` before using other Firebase services.
  await Firebase.initializeApp();

  print("Handling a background message: ${message.messageId}");
}

void main() {
  FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);
  runApp(MyApp());
}
```

Since the handler runs in its own isolate outside your applications context, it is not possible to update
application state or execute any UI impacting logic. You can, however, perform logic such as HTTP requests, perform IO operations
(e.g. updating local storage), communicate with other plugins etc.

It is also recommended to complete your logic as soon as possible. Running long, intensive tasks impacts device performance
and may cause the OS to terminate the process. If tasks run for longer than 30 seconds, the device may automatically kill the process.

#### Web

On the Web, write a JavaScript [Service Worker](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API) which runs in the background.
Use the service worker to handle background messages.

To get started, create a new file in the your `web` directory, and call it `firebase-messaging-sw.js`:

```js title=web/firebase-messaging-sw.js
// Please see this file for the latest firebase-js-sdk version:
// https://github.com/firebase/flutterfire/blob/main/packages/firebase_core/firebase_core_web/lib/src/firebase_sdk_version.dart
importScripts("https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js");
importScripts("https://www.gstatic.com/firebasejs/10.7.0/firebase-messaging-compat.js");

firebase.initializeApp({
  apiKey: "...",
  authDomain: "...",
  databaseURL: "...",
  projectId: "...",
  storageBucket: "...",
  messagingSenderId: "...",
  appId: "...",
});

const messaging = firebase.messaging();

// Optional:
messaging.onBackgroundMessage((message) => {
  console.log("onBackgroundMessage", message);
});
```

The file must import both the app and messaging SDKs, initialize Firebase and expose the `messaging` variable.

Next, the worker must be registered. Within the `index.html` file, register the worker by modifying the `<script>` tag which bootstraps Flutter:

```html
<script src="flutter_bootstrap.js" async>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', function () {
      navigator.serviceWorker.register('firebase-messaging-sw.js', {
        scope: '/firebase-cloud-messaging-push-scope',
      });
    });
  }
</script>
```

If you are still using the old templating system, you can register the worker by modifying the `<script>` tag which bootstraps Flutter as follows:

```html
<html>
<body>
  <script>
      var serviceWorkerVersion = null;
      var scriptLoaded = false;
      function loadMainDartJs() {
        if (scriptLoaded) {
          return;
        }
        scriptLoaded = true;
        var scriptTag = document.createElement('script');
        scriptTag.src = 'main.dart.js';
        scriptTag.type = 'application/javascript';
        document.body.append(scriptTag);
      }

      if ('serviceWorker' in navigator) {
        // Service workers are supported. Use them.
        window.addEventListener('load', function () {
          // Register Firebase Messaging service worker.
          navigator.serviceWorker.register('firebase-messaging-sw.js', {
            scope: '/firebase-cloud-messaging-push-scope',
          });

          // Wait for registration to finish before dropping the <script> tag.
          // Otherwise, the browser will load the script multiple times,
          // potentially different versions.
          var serviceWorkerUrl =
            'flutter_service_worker.js?v=' + serviceWorkerVersion;

          navigator.serviceWorker.register(serviceWorkerUrl).then((reg) => {
            function waitForActivation(serviceWorker) {
              serviceWorker.addEventListener('statechange', () => {
                if (serviceWorker.state == 'activated') {
                  console.log('Installed new service worker.');
                  loadMainDartJs();
                }
              });
            }
            if (!reg.active && (reg.installing || reg.waiting)) {
              // No active web worker and we have installed or are installing
              // one for the first time. Simply wait for it to activate.
              waitForActivation(reg.installing ?? reg.waiting);
            } else if (!reg.active.scriptURL.endsWith(serviceWorkerVersion)) {
              // When the app updates the serviceWorkerVersion changes, so we
              // need to ask the service worker to update.
              console.log('New service worker available.');
              reg.update();
              waitForActivation(reg.installing);
            } else {
              // Existing service worker is still good.
              console.log('Loading app from service worker.');
              loadMainDartJs();
            }
          });

          // If service worker doesn't succeed in a reasonable amount of time,
          // fallback to plaint <script> tag.
          setTimeout(() => {
            if (!scriptLoaded) {
              console.warn(
                'Failed to load app from service worker. Falling back to plain <script> tag.'
              );
              loadMainDartJs();
            }
          }, 4000);
        });
      } else {
        // Service workers not supported. Just drop the <script> tag.
        loadMainDartJs();
      }
  </script>
</body>
```

Next restart your Flutter application. The worker will be registered and any background messages will be handled via this file.

### Handling Interaction

Since notifications are a visible cue, it is common for users to interact with them (by pressing). The default behavior on both Android and iOS is to open the
application. If the application is terminated it will be started; if it is in the background it will be brought to the foreground.

Depending on the content of a notification, you may wish to handle the user's interaction when the application opens. For example, if a new chat message is sent via
a notification and the user presses it, you may want to open the specific conversation when the application opens.

The `firebase-messaging` package provides two ways to handle this interaction:

- `getInitialMessage()`: If the application is opened from a terminated state a `Future` containing a `RemoteMessage` will be returned. Once consumed, the `RemoteMessage` will be removed.
- `onMessageOpenedApp`: A `Stream` which posts a `RemoteMessage` when the application is opened from a background state.

It is recommended that both scenarios are handled to ensure a smooth UX for your users. The code example below outlines how this can be achieved:

```dart
class Application extends StatefulWidget {
  @override
  State<StatefulWidget> createState() => _Application();
}

class _Application extends State<Application> {
  // It is assumed that all messages contain a data field with the key 'type'
  Future<void> setupInteractedMessage() async {
    // Get any messages which caused the application to open from
    // a terminated state.
    RemoteMessage? initialMessage =
        await FirebaseMessaging.instance.getInitialMessage();

    // If the message also contains a data property with a "type" of "chat",
    // navigate to a chat screen
    if (initialMessage != null) {
      _handleMessage(initialMessage);
    }

    // Also handle any interaction when the app is in the background via a
    // Stream listener
    FirebaseMessaging.onMessageOpenedApp.listen(_handleMessage);
  }

  void _handleMessage(RemoteMessage message) {
    if (message.data['type'] == 'chat') {
      Navigator.pushNamed(context, '/chat',
        arguments: ChatArguments(message),
      );
    }
  }

  @override
  void initState() {
    super.initState();

    // Run code required to handle interacted messages in an async function
    // as initState() must not be async
    setupInteractedMessage();
  }

  @override
  Widget build(BuildContext context) {
    return Text("...");
  }
}
```

How you handle interaction depends on your application setup. The above example shows a basic illustration using a StatefulWidget.

## Localize Messages

You can send localized strings in two different ways:

- Store the preferred language of each of your users in your server and send customized notifications for each language
- Embed localized strings in your app and make use of the operating system's native locale settings

Here's how to use the second method:

### Android

1. Specify your default-language messages in `resources/values/strings.xml`:

   ```xml
   <string name="notification_title">Hello world</string>
   <string name="notification_message">This is a message</string>
   ```

2. Specify the translated messages in the <code>values-<var>language</var></code> directory. For example, specify French messages in `resources/values-fr/strings.xml`:

   ```xml
   <string name="notification_title">Bonjour le monde</string>
   <string name="notification_message">C'est un message</string>
   ```

3. In the server payload, instead of using `title`, `message`, and `body` keys, use `title_loc_key` and `body_loc_key` for your localized message, and set them to the `name` attribute of the message you want to display.

   The message payload would look like this:

   ```json
   {
     "android": {
        "notification": {
          "title_loc_key": "notification_title",
          "body_loc_key": "notification_message"
        }
     }
   }
   ```

### iOS

1. Specify your default-language messages in `Base.lproj/Localizable.strings`:

   ```
   "NOTIFICATION_TITLE" = "Hello World";
   "NOTIFICATION_MESSAGE" = "This is a message";
   ```

2. Specify the translated messages in the <code><var>language</var>.lproj</code> directory. For example, specify French messages in `fr.lproj/Localizable.strings`:

   ```
   "NOTIFICATION_TITLE" = "Bonjour le monde";
   "NOTIFICATION_MESSAGE" = "C'est un message";
   ```

   The message payload would look like this:

   ```json
   {
     "apns": {
        "payload": {
          "alert": {
            "title-loc-key": "NOTIFICATION_TITLE",
            "loc-key": "NOTIFICATION_MESSAGE"
          }
        }
     }
   }
   ```

## Enable message delivery data export

You can export your message data into BigQuery for further analysis. BigQuery allows you to analyze the data using BigQuery SQL,
export it to another cloud provider, or use the data for your custom ML models. An export to BigQuery
includes all available data for messages, regardless of message type or whether the message is sent via
the API or the Notifications composer.

To enable the export, first follow the steps [described here](https://firebase.google.com/docs/cloud-messaging/understand-delivery?platform=ios#bigquery-data-export),
then follow these instructions:

### Android

You can use the following code:

```dart
await FirebaseMessaging.instance.setDeliveryMetricsExportToBigQuery(true);
```

### iOS

For iOS, you need to change the `AppDelegate.m` with the following content.

```objective-c
#import "AppDelegate.h"
#import "GeneratedPluginRegistrant.h"
#import <Firebase/Firebase.h>

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application
    didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
  [GeneratedPluginRegistrant registerWithRegistry:self];
  // Override point for customization after application launch.
  return [super application:application didFinishLaunchingWithOptions:launchOptions];
}

- (void)application:(UIApplication *)application
    didReceiveRemoteNotification:(NSDictionary *)userInfo
          fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler {
  [[FIRMessaging extensionHelper] exportDeliveryMetricsToBigQueryWithMessageInfo:userInfo];
}

@end
```

### Web

For Web, you need to change your service worker in order to use the v9 version of the SDK.
The v9 version needs to be bundled, so you need to use a bundler like `esbuild` for instance
to get the service worker to work.
See [the example app](https://github.com/firebase/flutterfire/blob/main/packages/firebase_messaging/firebase_messaging/example/bundled-service-worker) to see how to achieve this.

Once you've migrated to the v9 SDK, you can use the following code:

```typescript
import {
  experimentalSetDeliveryMetricsExportedToBigQueryEnabled,
  getMessaging,
} from 'firebase/messaging/sw';
...

const messaging = getMessaging(app);
experimentalSetDeliveryMetricsExportedToBigQueryEnabled(messaging, true);
```

Don't forget to run `yarn build` in order to export the new version of your service worker to the `web` folder.

## Display images in notifications on iOS

On Apple devices, in order for incoming FCM Notifications to display images from the FCM payload, you must add an additional notification service extension and configure your app to use it.

If you are using Firebase phone authentication, you must add the Firebase Auth pod to your Podfile.

### Step 1 - Add a notification service extension

1.  In Xcode, click **File > New > Target...**
1.  A modal will present a list of possible targets; scroll down or use the filter to select **Notification Service Extension**. Click **Next**.
1.  Add a product name (use "ImageNotification" to follow along with this tutorial), set the language to Objective-C, and click **Finish**.
1.  Enable the scheme by clicking **Activate**.

### Step 2 - Add target to the Podfile

Ensure that your new extension has access to the `Firebase/Messaging` pod by adding it in the Podfile:

1.  From the Navigator, open the Podfile: **Pods > Podfile**

1.  Scroll down to the bottom of the file and add:

    ```ruby
    target 'ImageNotification' do
      use_frameworks!
      pod 'Firebase/Auth' # Add this line if you are using FirebaseAuth phone authentication
      pod 'Firebase/Messaging'
    end
    ```

1.  Install or update your pods using `pod install` from the `ios` or `macos` directory.

### Step 3 - Use the extension helper

At this point, everything should still be running normally. The final step is invoking the extension helper.

1.  From the navigator, select your ImageNotification extension

1.  Open the `NotificationService.m` file.

1.  At the top of the file, import `FirebaseMessaging.h` right after the `NotificationService.h` as shown below.

    Replace the content of `NotificationService.m` with:

    ```objc
    #import "NotificationService.h"
    #import "FirebaseMessaging.h"
    #import "FirebaseAuth.h" // Add this line if you are using FirebaseAuth phone authentication
    #import <UIKit/UIKit.h> // Add this line if you are using FirebaseAuth phone authentication

    @interface NotificationService ()

    @property (nonatomic, strong) void (^contentHandler)(UNNotificationContent *contentToDeliver);
    @property (nonatomic, strong) UNMutableNotificationContent *bestAttemptContent;

    @end

    @implementation NotificationService

    /* Uncomment this if you are using Firebase Auth
    - (BOOL)application:(UIApplication *)app
                openURL:(NSURL *)url
                options:(NSDictionary<UIApplicationOpenURLOptionsKey, id> *)options {
      if ([[FIRAuth auth] canHandleURL:url]) {
        return YES;
      }
      return NO;
    }

    - (void)scene:(UIScene *)scene openURLContexts:(NSSet<UIOpenURLContext *> *)URLContexts {
      for (UIOpenURLContext *urlContext in URLContexts) {
        [FIRAuth.auth canHandleURL:urlContext.URL];
      }
    }
    */

    - (void)didReceiveNotificationRequest:(UNNotificationRequest *)request withContentHandler:(void (^)(UNNotificationContent * _Nonnull))contentHandler {
        self.contentHandler = contentHandler;
        self.bestAttemptContent = [request.content mutableCopy];

        // Modify the notification content here...
        [[FIRMessaging extensionHelper] populateNotificationContent:self.bestAttemptContent withContentHandler:contentHandler];
    }

    - (void)serviceExtensionTimeWillExpire {
        // Called just before the extension will be terminated by the system.
        // Use this as an opportunity to deliver your "best attempt" at modified content, otherwise the original push payload will be used.
        self.contentHandler(self.bestAttemptContent);
    }

    @end
    ```

### Step 4 - Add the image to the payload

In your notification payload, you can now add an image. See the iOS documentation on [how to build a send request](https://firebase.google.com/docs/cloud-messaging/ios/send-image#build_the_send_request). Keep in mind that a 300KB max image size is enforced by the device.



================================================
File: docs/flutter/cloud-messaging/topic-messaging.md
================================================
Project: /docs/cloud-messaging/_project.yaml
Book: /docs/_book.yaml
page_type: guide

{% include "_shared/apis/console/_local_variables.html" %}
{% include "_local_variables.html" %}
{% include "docs/cloud-messaging/_local_variables.html" %}
{% include "docs/android/_local_variables.html" %}

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# Topic messaging on Flutter

Based on the publish/subscribe model, FCM topic messaging allows you to send a message
to multiple devices that have opted in to a particular topic.  You compose topic messages as
needed, and FCM handles routing and delivering the message reliably to the right
devices.

For example, users of a local tide
forecasting app could opt in to a "tidal currents alerts" topic and receive
notifications of optimal saltwater fishing conditions in specified areas. Users of a sports app
could subscribe to automatic updates in live game scores for their favorite
teams.

Some things to keep in mind about topics:

- Topic messaging is best suited for content such as weather, or other publicly
  available information.

- Topic messages are **optimized for throughput rather than latency**. For fast,
  secure delivery to single devices or small groups of devices,
  [target messages to registration tokens](/docs/cloud-messaging/send-message#send_messages_to_specific_devices),
  not topics.

- If you need to send messages to multiple devices _per user_, consider
  [device group messaging](/docs/cloud-messaging/send-message#send_messages_to_device_groups)
  for those use cases.

- Topic messaging supports unlimited subscriptions for each topic. However, FCM
  enforces limits in these areas:

  - One app instance can be subscribed to no more than 2000 topics.
  - If you are using [batch import](https://developers.google.com/instance-id/reference/server#manage_relationship_maps_for_multiple_app_instances)
    to subscribe app instances, each request is limited to 1000 app instances.
  - The frequency of new subscriptions is rate-limited per project. If you send
    too many subscription requests in a short period of time, FCM servers will
    respond with a `429 RESOURCE_EXHAUSTED` ("quota exceeded") response. Retry
    with exponential backoff.


## Subscribe the client app to a topic

Client apps can subscribe to any existing topic, or they can create a new
topic. When a client app subscribes to a new topic name (one that does
not already exist for your Firebase project), a new topic of that name is
created in FCM and any client can subsequently subscribe to it.

To subscribe to a topic, call `subscribeToTopic()` with the topic name. This method
returns a `Future`, which resolves when the subscription succeeded:

```dart
await FirebaseMessaging.instance.subscribeToTopic("topic");
```

To unsubscribe, call `unsubscribeFromTopic()` with the topic name.

`subscribeToTopic()` and `unsubscribeFromTopic()` are not supported for web
clients. To learn how to manage subscriptions for web users, see 
[Send messages to topics on Web/JavaScript](https://firebase.google.com/docs/cloud-messaging/js/topic-messaging).

## Next steps

* Learn how to [send topic messages](/docs/cloud-messaging/send-message#send-messages-to-topics).
* Learn how to [Manage topic subscriptions on the server](/docs/cloud-messaging/manage-topics).


================================================
File: docs/flutter/crashlytics/_customize-crash-reports.md
================================================
{# This content gets published to the following location:                                  #}
{#   https://firebase.google.com/docs/crashlytics/customize-crash-reports?platform=flutter #}

In the {{crashlytics}} dashboard, you can click into an issue and get a detailed
event report. You can customize those reports to help you better understand
what's happening in your app and the circumstances around events reported to
{{crashlytics}}.

* Report [uncaught exceptions](#report-uncaught-exceptions) and
  [caught exceptions](#report-caught-exceptions) to {{crashlytics}}.

* Instrument your app to log [custom keys](#add-keys),
  [custom log messages](#add-logs), and [user identifiers](#set-user-ids).

* Automatically get [breadcrumb logs](#get-breadcrumb-logs) if your app uses the
  Firebase SDK for {{firebase_analytics}}. These logs give you visibility into
  user actions leading up to a {{crashlytics}}-collected event in your app.

* Turn off automatic crash reporting and
  [enable opt-in reporting](#enable-reporting) for your users. Note that, by
  default, {{crashlytics}} automatically collects platform-native crash reports
  for all your app's users.

Note: For Flutter apps, fatal reports are sent to {{crashlytics}} in real-time
without the need for the user to restart the application. Non-fatal reports are
written to disk to be sent along with the next fatal report or when the app
restarts.

## Report uncaught exceptions {: #report-uncaught-exceptions}

You can automatically catch all "fatal" errors that are thrown within the Flutter
framework by overriding `FlutterError.onError` with
`FirebaseCrashlytics.instance.recordFlutterFatalError`. Alternatively,
to also catch "non-fatal" exceptions, override `FlutterError.onError` with `FirebaseCrashlytics.instance.recordFlutterError`:

```dart
void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  await Firebase.initializeApp();
  bool weWantFatalErrorRecording = true;
  FlutterError.onError = (errorDetails) {
    if(weWantFatalErrorRecording){
      FirebaseCrashlytics.instance.recordFlutterFatalError(errorDetails);
    } else {
      FirebaseCrashlytics.instance.recordFlutterError(errorDetails);
    }
  };

  runApp(MyApp());
}
```

### Asynchronous errors {: #asynchronous-errors}

Asynchronous errors are not caught by the Flutter framework:

```dart
ElevatedButton(
  onPressed: () async {
    throw Error();
  }
  ...
)
```

To catch such errors, you can use the `PlatformDispatcher.instance.onError` handler:

```dart
Future<void> main() async {
    WidgetsFlutterBinding.ensureInitialized();
    await Firebase.initializeApp();
    FlutterError.onError = (errorDetails) {
      FirebaseCrashlytics.instance.recordFlutterFatalError(errorDetails);
    };
    // Pass all uncaught asynchronous errors that aren't handled by the Flutter framework to Crashlytics
    PlatformDispatcher.instance.onError = (error, stack) {
      FirebaseCrashlytics.instance.recordError(error, stack, fatal: true);
      return true;
    };
    runApp(MyApp());

}
```

### Errors outside of Flutter {: #errors-outside-flutter}

To catch errors that happen outside of the Flutter context, install an error
listener on the current `Isolate`:

```dart
Isolate.current.addErrorListener(RawReceivePort((pair) async {
  final List<dynamic> errorAndStacktrace = pair;
  await FirebaseCrashlytics.instance.recordError(
    errorAndStacktrace.first,
    errorAndStacktrace.last,
    fatal: true,
  );
}).sendPort);
```

## Report caught exceptions {: #report-caught-exceptions}

In addition to automatically reporting your app’s crashes, {{crashlytics}} lets
you record non-fatal exceptions and sends them to you the next time a fatal
event is reported or when the app restarts.

Note: {{crashlytics}} only stores the most recent eight recorded non-fatal
exceptions. If your app throws more than eight, older exceptions are lost. This
count is reset each time a fatal exception is thrown, since this causes a report
to be sent to {{crashlytics}}.

Use the `recordError` method to record non-fatal exceptions in your app's catch
blocks. For example:

```dart
await FirebaseCrashlytics.instance.recordError(
  error,
  stackTrace,
  reason: 'a non-fatal error'
);

// Or you can use:
await FirebaseCrashlytics.instance.recordFlutterError(errorDetails);
```

You may also want to log further information about the error which is possible
using the `information` property:

```dart
await FirebaseCrashlytics.instance.recordError(
  error,
  stackTrace,
  reason: 'a non-fatal error',
  information: ['further diagnostic information about the error', 'version 2.0'],
);
```

Warning: If you want to include a unique value (for example, a user ID or a
timestamp) in your exception message, use a [custom key](#add-keys) instead of
adding the value directly in the exception message. Adding values directly can
result in several issues and may cause {{crashlytics}} to limit reporting errors
in your app.

These exceptions appear as non-fatal issues in the {{name_appmanager}}. The
issue summary contains all the state information you normally get from crashes,
along with breakdowns by version and hardware device.

{{crashlytics}} processes exceptions on a dedicated background thread to
minimize the performance impact to your app. To reduce your users’ network
traffic, {{crashlytics}} will rate-limit the number of reports sent off device,
if necessary.

## Add custom keys {: #add-keys}

Custom keys help you get the specific state of your app leading up to a crash.
You can associate arbitrary key/value pairs with your crash reports, then use
the custom keys to search and filter crash reports in the {{name_appmanager}}.

* In the [{{crashlytics}} dashboard](https://console.firebase.google.com/project/_/crashlytics){:.external},
  you can search for issues that match a custom key.

* When you're reviewing a specific issue in the console, you can view the
  associated custom keys for each event (_Keys_ subtab) and even filter the
  events by custom keys (_Filter_ menu at the top of the page).

Note: {{crashlytics}} supports a maximum of 64 key/value pairs. After you reach
this threshold, additional values are not saved. Each key/value pair can be up
to 1 kB in size.

Use the `setCustomKey` instance method to set key/value pairs. Here are some
examples:

```dart
// Set a key to a string.
FirebaseCrashlytics.instance.setCustomKey('str_key', 'hello');

// Set a key to a boolean.
FirebaseCrashlytics.instance.setCustomKey("bool_key", true);

// Set a key to an int.
FirebaseCrashlytics.instance.setCustomKey("int_key", 1);

// Set a key to a long.
FirebaseCrashlytics.instance.setCustomKey("int_key", 1L);

// Set a key to a float.
FirebaseCrashlytics.instance.setCustomKey("float_key", 1.0f);

// Set a key to a double.
FirebaseCrashlytics.instance.setCustomKey("double_key", 1.0);
```

## Add custom log messages {: #add-logs}

To give yourself more context for the events leading up to a crash, you can add
custom {{crashlytics}} logs to your app. {{crashlytics}} associates the logs
with your crash data and displays them in the
[{{name_appmanager}}](https://console.firebase.google.com/project/_/crashlytics){: .external},
under the {{crashlytics}} **Logs** tab.

Note: To avoid slowing down your app, {{crashlytics}} limits logs to 64kB
and deletes older log entries when a session's logs go over that limit.

Use `log` to help pinpoint issues. For example:

```dart
FirebaseCrashlytics.instance.log("Higgs-Boson detected! Bailing out");
```

## Set user identifiers {: #set-user-ids}

To diagnose an issue, it’s often helpful to know which of your users experienced
a given crash. {{crashlytics}} includes a way to anonymously identify users in
your crash reports.

To add user IDs to your reports, assign each user a unique identifier in the
form of an ID number, token, or hashed value:

```dart
FirebaseCrashlytics.instance.setUserIdentifier("12345");
```

If you ever need to clear a user identifier after you set it, reset the value to
a blank string. Clearing a user identifier does not remove existing
{{crashlytics}} records. If you need to delete records associated with a user
ID, [contact Firebase support](/support/troubleshooter/contact/).

## Get breadcrumb logs {: #get-breadcrumb-logs}

Breadcrumb logs give you a better understanding of the interactions that a user
had with your app leading up to a crash, non-fatal, or ANR event. These logs can
be helpful when trying to reproduce and debug an issue.

Breadcrumb logs are powered by Google Analytics, so to get breadcrumb logs, you
need to
[enable Google Analytics](https://support.google.com/firebase/answer/9289399#linkga){: .external}
for your Firebase project and
[add the Firebase SDK for {{firebase_analytics}}](/docs/analytics/get-started#add-sdk)
to your app. Once these requirements are met, breadcrumb logs are automatically
included with an event's data within the **Logs** tab when you view the details
of an issue.

The {{analytics}} SDK
[automatically logs the `screen_view` event](https://support.google.com/analytics/answer/9234069#screen_view){: .external}
which enables the breadcrumb logs to show a list of screens viewed before the
crash, non-fatal, or ANR event. A `screen_view` breadcrumb log contains a
`firebase_screen_class` parameter.

Breadcrumb logs are also populated with any
[custom events](/docs/analytics/events) that you manually log within the user's
session, including the event's parameter data. This data can help show a series
of user actions leading up to a crash, non-fatal, or ANR event.

Note that you can
[control the collection and use of {{firebase_analytics}} data](/docs/analytics/configure-data-collection),
which includes the data that populates breadcrumb logs.

## Enable opt-in reporting {: #enable-reporting}

By default, {{crashlytics}} automatically collects crash reports for all your
app's users. To give users more control over the data they send, you can enable
opt-in reporting by disabling automatic reporting and only sending data to
{{crashlytics}} when you choose to in your code:

1.  Turn off automatic collection natively:

    **Apple platforms**

    Add a new key to your `Info.plist` file:

    * Key: `FirebaseCrashlyticsCollectionEnabled`
    * Value: `false`

    **Android**

    In the `application` block of your `AndroidManifest.xml` file, add
    a `meta-data` tag to turn off automatic collection:

    ```xml
    <meta-data
        android:name="firebase_crashlytics_collection_enabled"
        android:value="false" />
    ```

1.  Enable collection for select users by calling the {{crashlytics}} data
    collection override at runtime.

    The override value persists across launches of your app so {{crashlytics}}
    can automatically collect reports. To opt out of automatic crash reporting,
    pass `false` as the override value. When set to `false`, the new value does
    not apply until the next run of the app.

    ```dart
    FirebaseCrashlytics.instance.setCrashlyticsCollectionEnabled(true);
    ```

Note: When data collection is disabled, {{crashlytics}} will store crash
information locally on the device. If data collection is subsequently enabled,
any crash information stored on the device will be sent to {{crashlytics}} for
processing.


================================================
File: docs/flutter/crashlytics/_deobfuscated.md
================================================
{# This content gets published to the following location:                                   #}
{#   https://firebase.google.com/docs/crashlytics/get-deobfuscated-reports?platform=flutter #}

By default, {{firebase_crashlytics}} automatically instruments your Flutter
project to upload the necessary symbol files that ensure crash reports are
deobfuscated and human readable.

Unfortunately, there are cases that can result in the project not being fully
configured. This guide outlines what the automation does and provides first
steps to debug your project setup.

## Apple platforms {: #apple}

### Check your configuration for uploading dSYM files {: #apple-upload-dsym-script-configuration}

Adding the {{crashlytics}} Flutter plugin and running the
`flutterfire configure` command will attempt to add a run script to your
project’s Xcode workspace that finds and uploads the necessary dSYM symbol files
to {{crashlytics}}. Without these files, you’ll see a "Missing dSYM" alert in
the {{crashlytics}} dashboard and exceptions will be held by the backend until
the missing files are uploaded.

If you have this issue, first make sure that you have the run script installed:

1.  Locate and open the Xcode workspace file in your project’s iOS directory
    (<code><var>FLUTTER_PROJECT_NAME</var>/ios/Runner.xcworkspace</code>).

1.  Identify whether a run script titled
    `[firebase_crashlytics] Crashlytics Upload Symbols` has been added to the
    Runner target’s Build Phases.

    See the applicable section below for whether the
    [run script does _not_ exist](#run-script-does-not-exist) or the
    [run script exists](#run-script-exists).

{{ '<section class="expandable" id="run-script-does-not-exist">' }}
<h4 class="showalways" id="run-script-does-not-exist">Run script for auto-upload of dSYMs does _not_ exist</h4>

If this run script does _not_ exist, you can add it manually:

1.  Locate the Firebase App ID for your Apple app. Here are two different places
    where you can find this ID:

    * In the {{name_appmanager}}, go to your
      <nobr><span class="material-icons">settings</span> > _Project settings_</nobr>.
      Scroll down to the _Your apps_ card, then click on your
      Firebase Apple App to view the app's information, including its _App ID_.

    * In your Flutter project's top-level directory, find your
      `firebase_options.dart` file. The Firebase App ID for your Apple app is
      labeled as `GOOGLE_APP_ID`.

1.  Click <span class="material-icons">add</span> >
    **New Run Script Phase**.

    Make sure this new _Run Script_ phase is your project's last build
    phase. Otherwise, {{crashlytics}} can't properly process dSYMs.

1.  Expand the new _Run Script_ section.

    Note: For the remaining substeps, copy-and-paste the paths exactly as
    specified, and Xcode will resolve them. However, if you have issues with
    Xcode resolving these paths or a unique project structure, you can
    manually specify the paths instead.

1.  In the script field (located under the _Shell_ label), add the
    following run scripts.

    These scripts process your dSYM files and upload the files to
    {{crashlytics}}.

    <pre class="devsite-click-to-copy">$PODS_ROOT/FirebaseCrashlytics/upload-symbols --build-phase --validate -ai <var>FIREBASE_APP_ID</var> -- $DWARF_DSYM_FOLDER_PATH/App.framework.dSYM</pre>

    <pre class="devsite-click-to-copy">$PODS_ROOT/FirebaseCrashlytics/upload-symbols --build-phase -ai <var>FIREBASE_APP_ID</var> -- $DWARF_DSYM_FOLDER_PATH/App.framework.dSYM </pre>

    * <var>FIREBASE_APP_ID</var>: Your Firebase Apple App ID (not your
      Apple bundle ID)<br>
      Example Firebase Apple App ID: `1:1234567890:ios:321abc456def7890`

    {{ '<section class="expandable">' }}
    <p class="showalways">Need to find your Firebase App ID?</p>

    > Here are two ways to find your Firebase App ID:
    >
    > * In your `GoogleService-Info.plist` file, your App ID is the
    >   `GOOGLE_APP_ID` value; or
    >
    > * In the {{name_appmanager}}, go to your
    >   [_Project settings_](https://console.firebase.google.com/project/_/settings/general/){: .external}.
    >   Scroll down to the _Your apps_ card, then click on the desired Firebase
    >   App to find its App ID.

    {{ '</section>' }}

1.  In the _Input Files_ section, add the paths for the locations of the
    following files:

    <pre class="devsite-click-to-copy">${DWARF_DSYM_FOLDER_PATH}/${DWARF_DSYM_FILE_NAME}</pre>

    <pre class="devsite-click-to-copy">${DWARF_DSYM_FOLDER_PATH}/${DWARF_DSYM_FILE_NAME}/Contents/Resources/DWARF/${PRODUCT_NAME}</pre>

    <pre class="devsite-click-to-copy">${DWARF_DSYM_FOLDER_PATH}/${DWARF_DSYM_FILE_NAME}/Contents/Info.plist</pre>

    <pre class="devsite-click-to-copy">$(TARGET_BUILD_DIR)/$(UNLOCALIZED_RESOURCES_FOLDER_PATH)/GoogleService-Info.plist</pre>

    <pre class="devsite-click-to-copy">$(TARGET_BUILD_DIR)/$(EXECUTABLE_PATH)</pre>

    <section class="expandable">
      <p class="showalways"><b>Understand why the locations of these files are
        needed</b>
      </p>

      <p>Xcode looks in the specified locations for these input files to ensure
        that the build files are available for the run script. Also, if
        <i>User Script Sandboxing</i> is enabled, Xcode only allows the run
        script to access files specified in the <i>Input Files</i>.
      </p>

      <ul>
        <li>Providing the location of your project's dSYM files enables
          {{crashlytics}} to process dSYMs.
        </li>
        <li>Providing the location of your app's built
          <code>GoogleService-Info.plist</code>
          file enables {{crashlytics}} to associate the dSYMs with your
          Firebase app.
        </li>
        <li>Providing the location of your app's executable allows the run
          script to prevent duplicate uploads of the same dSYM. Note that app
          binaries are <em>not uploaded</em>.
        </li>
      </ul>

    </section>

{{ '</section>' }}

{{ '<section class="expandable" id="run-script-exists">' }}
<h4 class="showalways" id="run-script-exists">Run script for auto-upload of dSYMs exists</h4>

If the run script does exist, refer to the
[Apple-specific guide for troubleshooting dSYM issues](/docs/crashlytics/get-deobfuscated-reports?platform=ios).
You’ll need to take the following additional steps if you choose to upload your
dSYM files via the described process:

1.  Locate the Firebase App ID for your Apple app. Here are two different places
    where you can find this ID:

    * In the {{name_appmanager}}, go to your
      <nobr><span class="material-icons">settings</span> > _Project settings_</nobr>.
      Scroll down to the _Your apps_ card, then click on your
      Firebase Apple App to view the app's information, including its _App ID_.

    * In your Flutter project's top-level directory, find your
      `firebase_options.dart` file. The Firebase App ID for your Apple app is
      labeled as `GOOGLE_APP_ID`.

1.  When running the `upload-symbols` script, use
    <code><nobr>-ai <var>FIREBASE_APPLE_APP_ID</var></nobr></code> instead of
    <nobr><code>-gsp /path/to/GoogleService-Info.plist</code></nobr>.

{{ '</section>' }}

### Check your version configuration for Flutter and {{crashlytics}} _(if using the `--split-debug-info` flag)_ {: #apple-split-debug-info}

If your Flutter project uses the `--split-debug-info` flag (and, optionally,
also the `--obfuscate` flag), additional steps are required to show readable
stack traces for your app.

Make sure that your project is using the recommended version configuration
(Flutter 3.12.0+ and {{crashlytics}} Flutter plugin 3.3.4+) so that your project
can automatically generate and upload Flutter symbols (dSYM files) to
{{crashlytics}}.


## Android {: #android}

### Check your dependency configuration {: #android-dependency-configuration}

The `flutterfire configure` command attempts to add necessary dependencies to
your project’s Gradle build files. Without these dependencies, crash reports in
the {{name_appmanager}} may end up obfuscated if obfuscation is turned on.

Make sure the following lines are present in the project-level `build.gradle`
and in the app-level `build.gradle`:

* In the **project-level** build file (`android/build.gradle`), check for the
  following line:

  <pre class="prettyprint">
  dependencies {
    // ... other dependencies

    classpath 'com.google.gms:google-services:4.3.5'
    <strong>classpath 'com.google.firebase:firebase-crashlytics-gradle:2.7.1'</strong>
  }
  </pre>

* In the **app-level** build file (`android/app/build.gradle`), check for the
  following line:

  <pre class="prettyprint">
  // ... other imports

  android {
    // ... your android config
  }

  dependencies {
    // ... your dependencies
  }

  // This section must appear at the bottom of the file
  apply plugin: 'com.google.gms.google-services'
  <strong>apply plugin: 'com.google.firebase.crashlytics'</strong>
  </pre>

### Check that you're using the {{cli}} to upload Flutter symbols _(if using the `--split-debug-info` flag)_ {: #android-split-debug-info}

If your Flutter project uses the `--split-debug-info` flag (and, optionally,
also the `--obfuscate` flag), additional steps are required to show readable
stack traces for your app.

Use the [{{firebase_cli}}](/docs/cli) (v.11.9.0+) to upload Flutter debug
symbols. You need to upload the debug symbols _before_ reporting a crash from an
obfuscated code build.

From the root directory of your Flutter project, run the following command:

<pre class="devsite-terminal" data-terminal-prefix="your-flutter-proj$ ">firebase crashlytics:symbols:upload --app=<var class="readonly">FIREBASE_APP_ID</var> <var class="readonly">PATH/TO</var>/symbols</pre>

* <var>FIREBASE_APP_ID</var>: Your Firebase Android App ID (not your
  package name)<br>
  Example Firebase Android App ID: `1:567383003300:android:17104a2ced0c9b9b`

    {{ '<section class="expandable">' }}
    <p class="showalways">Need to find your Firebase App ID?</p>

    > Here are two ways to find your Firebase App ID:
    >
    > * In your `google-services.json` file, your App ID is the
    >   `mobilesdk_app_id` value; or
    >
    > * In the {{name_appmanager}}, go to your
    >   [_Project settings_](https://console.firebase.google.com/project/_/settings/general/){: .external}.
    >   Scroll down to the _Your apps_ card, then click on the desired Firebase
    >   App to find its App ID.

    {{ '</section>' }}

* <code><var>PATH/TO</var>/symbols</code>: The same directory that you
  pass to the `--split-debug-info` flag when building the application

If problems persist, refer to the
[Android-specific guide for troubleshooting obfuscated reports](/docs/crashlytics/get-deobfuscated-reports?platform=android).



================================================
File: docs/flutter/crashlytics/_force-test-crash.md
================================================
{# This content gets published to the following location:                              #}
{#   https://firebase.google.com/docs/crashlytics/test-implementation?platform=flutter #}

1.  Add code to your app that you can use to force a test exception to be
    thrown.

    If you’ve added an error handler that calls
    `FirebaseCrashlytics.instance.recordError(error, stack, fatal: true)` to the
    top-level `Zone`, you can use the following code to add a button to your app
    that, when pressed, throws a test exception:

    ```dart
    TextButton(
        onPressed: () => throw Exception(),
        child: const Text("Throw Test Exception"),
    ),
    ```

1.  Build and run your app.

1.  Force the test exception to be thrown in order to send your app's first
    report:

    1.  Open your app from your test device or emulator.

    1.  In your app, press the test exception button that you added using the
        code above.

1.  Go to the
    [{{crashlytics}} dashboard](https://console.firebase.google.com/project/_/crashlytics){: .external}
    of the {{name_appmanager}} to see your test crash.



================================================
File: docs/flutter/crashlytics/_get-started.md
================================================
{# This content gets published to the following location:                      #}
{#   https://firebase.google.com/docs/crashlytics/get-started?platform=flutter #}

This quickstart describes how to set up {{firebase_crashlytics}} in your app
with the {{crashlytics}} Flutter plugin so that you can get comprehensive crash
reports in the {{name_appmanager}}.

Setting up {{crashlytics}} involves using both a command-line tool and your IDE.
To finish setup, you'll need to force a test exception to be thrown to send your
first crash report to Firebase.


## Before you begin {: #before-you-begin}

1.  If you haven't already,
    [configure and initialize Firebase](/docs/flutter/setup) in your Flutter
    project.

1.  **Recommended**: To automatically get
    [breadcrumb logs](/docs/crashlytics/customize-crash-reports#get-breadcrumb-logs)
    to understand user actions leading up to a crash, non-fatal, or ANR event,
    you need to enable {{firebase_analytics}} in your Firebase project.

    * If your existing Firebase project doesn't have {{firebase_analytics}}
      enabled, you can enable {{firebase_analytics}} from the
      {{firebase_console_integrations_link}} of your
      <nobr><span class="material-icons">settings</span> > _Project settings_</nobr>
      in the {{name_appmanager}}.

    * If you're creating a new Firebase project, enable {{firebase_analytics}}
      during the project creation workflow.

    Note that breadcrumb logs are available for all Android and Apple platforms
    supported by {{crashlytics}} (except watchOS).

## **Step 1**: Add {{crashlytics}} to your Flutter project {: #add-sdk}

1.  From the root of your Flutter project, run the following command to install
    the Flutter plugin for {{crashlytics}}.

    To take advantage of
    [breadcrumb logs](/docs/crashlytics/customize-crash-reports#get-breadcrumb-logs),
    also add the Flutter plugin for {{firebase_analytics}} to your app.
    Make sure that
    [Google Analytics is enabled](https://support.google.com/firebase/answer/9289399#linkga){: .external}
    in your Firebase project.

    ```sh {: .devsite-terminal .devsite-click-to-copy data-terminal-prefix="your-flutter-proj$ " }
    flutter pub add firebase_crashlytics && flutter pub add firebase_analytics
    ```

1.  From the root directory of your Flutter project, run the following command:

    ```sh {: .devsite-terminal .devsite-click-to-copy data-terminal-prefix="your-flutter-proj$ " }
    flutterfire configure
    ```

    Running this command ensures that your Flutter app's Firebase configuration
    is up-to-date and, for Android, adds the required {{crashlytics}} Gradle
    plugin to your app.

1.  Once complete, rebuild your Flutter project:

    ```sh {: .devsite-terminal .devsite-click-to-copy data-terminal-prefix="your-flutter-proj$ " }
    flutter run
    ```

1.  _(Optional)_ If your Flutter project uses the `--split-debug-info` flag
    (and, optionally, also the `--obfuscate` flag), additional steps are
    required to show readable stack traces for your apps.

    * **Apple platforms:** Make sure that your project is using the recommended
      version configuration (Flutter 3.12.0+ and
      {{crashlytics}} Flutter plugin 3.3.4+) so that your project can
      automatically generate and upload Flutter symbols (dSYM files) to
      {{crashlytics}}.

    * **Android:** Use the [{{firebase_cli}}](/docs/cli) (v.11.9.0+) to upload
      Flutter debug symbols. You need to upload the debug symbols _before_
      reporting a crash from an obfuscated code build.

      From the root directory of your Flutter project, run the following
      command:

      <pre class="devsite-terminal" data-terminal-prefix="your-flutter-proj$ ">firebase crashlytics:symbols:upload --app=<var class="readonly">FIREBASE_APP_ID</var> <var class="readonly">PATH/TO</var>/symbols</pre>

      * <var>FIREBASE_APP_ID</var>: Your Firebase Android App ID (not your
        package name)<br>
        Example Firebase Android App ID: `1:567383003300:android:17104a2ced0c9b9b`

          {{ '<section class="expandable">' }}
          <p class="showalways">Need to find your Firebase App ID?</p>

          > Here are two ways to find your Firebase App ID:
          >
          > * In your `google-services.json` file, your App ID is the
          >   `mobilesdk_app_id` value; or
          >
          > * In the {{name_appmanager}}, go to your
          >   [_Project settings_](https://console.firebase.google.com/project/_/settings/general/){: .external}.
          >   Scroll down to the _Your apps_ card, then click on the desired Firebase
          >   App to find its App ID.

          {{ '</section>' }}

      * <code><var>PATH/TO</var>/symbols</code>: The same directory that you
        pass to the `--split-debug-info` flag when building the application


## **Step 2**: Configure crash handlers {: #configure-crash-handlers}

You can automatically catch all errors that are thrown within the Flutter
framework by overriding `FlutterError.onError` with
`FirebaseCrashlytics.instance.recordFlutterFatalError`:

```dart
void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  await Firebase.initializeApp();

  // Pass all uncaught "fatal" errors from the framework to Crashlytics
  FlutterError.onError = FirebaseCrashlytics.instance.recordFlutterFatalError;

  runApp(MyApp());
}
```

To catch asynchronous errors that aren't handled by the Flutter framework, use
`PlatformDispatcher.instance.onError`:


```dart
Future<void> main() async {
    WidgetsFlutterBinding.ensureInitialized();
    await Firebase.initializeApp();
    FlutterError.onError = (errorDetails) {
      FirebaseCrashlytics.instance.recordFlutterFatalError(errorDetails);
    };
    // Pass all uncaught asynchronous errors that aren't handled by the Flutter framework to Crashlytics
    PlatformDispatcher.instance.onError = (error, stack) {
      FirebaseCrashlytics.instance.recordError(error, stack, fatal: true);
      return true;
    };
    runApp(MyApp());

}
```

For examples of how to handle other types of errors, see
[Customize crash reports](/docs/crashlytics/customize-crash-reports?platform=flutter).


## **Step 3**: Force a test crash to finish setup {:#force-test-crash}

To finish setting up {{crashlytics}} and see initial data in the {{crashlytics}}
dashboard of the {{name_appmanager}}, you need to force a test exception to be
thrown.

<<_force-test-crash.md>>

  If you've refreshed the console and you're still not seeing the test crash
  after five minutes,
  [enable debug logging](test-implementation#enable-debug-logging)
  to see if your app is sending crash reports.

<br>
And that's it! {{crashlytics}} is now monitoring your app for crashes and, on
Android, non-fatal errors and ANRs. Visit the
[{{crashlytics}} dashboard](https://console.firebase.google.com/project/_/crashlytics){: .external}
to view and investigate all your reports and statistics.


## Next steps {:#next-steps}

* [Customize your crash report setup](/docs/crashlytics/customize-crash-reports)
  by adding opt-in reporting, logs, keys, and tracking of additional non-fatal
  errors.

* [Integrate with {{play_name}}](/docs/crashlytics/integrate-with-google-play)
  so that you can filter your Android app's crash reports by {{play_name}} track
  directly in the {{crashlytics}} dashboard. This allows you to better focus
  your dashboard on specific builds.

* [View stack traces and crash statistics alongside your
  code](https://developer.android.com/studio/preview/features#aqi){: .external}
  with the _App Quality Insights_ window in Android Studio (available starting
  with Electric Eel 2022.1.1).


================================================
File: docs/flutter/crashlytics/_start-using-analytics.md
================================================
{# This content gets published to the following location:                                #}
{#   https://firebase.google.com/docs/crashlytics/start-using-analytics?platform=flutter #}

1.  Make sure that {{firebase_analytics}} is enabled in your Firebase project:
    Go to <nobr><span class="material-icons">settings</span> > _Project settings_</nobr> > _Integrations_ tab,
    then follow the on-screen instructions for {{firebase_analytics}}.

1.  From the root of your Flutter project, run the following command to install
    the {{analytics}} Flutter plugin:

    <pre class="devsite-terminal devsite-click-to-copy"
         data-terminal-prefix="your-flutter-proj$ ">flutter pub add firebase_analytics
    </pre>

1.  Make sure that your Flutter app's Firebase configuration is up-to-date by
    running the following command from the root directory of your Flutter
    project:

    <pre class="devsite-terminal devsite-click-to-copy"
         data-terminal-prefix="your-flutter-proj$ ">flutterfire configure
    </pre>

1.  Once complete, rebuild your Flutter application:

    <pre class="devsite-terminal devsite-click-to-copy"
         data-terminal-prefix="your-flutter-proj$ ">flutter run
    </pre>

Your Flutter project is now set up to use {{firebase_analytics}}.



================================================
File: docs/flutter/database/_usecase_security_preamble.md
================================================
Note: By default, read and write access to your database is restricted so only
authenticated users can read or write data. To get started without setting up
Firebase Authentication, you can [configure your rules for public access](/docs/rules/basics#default_rules_locked_mode).
This does make your database open to anyone, even people not using your app, so
be sure to restrict your database again when you set up authentication.



================================================
File: docs/flutter/database/lists-of-data.md
================================================
Project: /docs/database/_project.yaml
Book: /docs/_book.yaml
page_type: guide

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# Work with Lists of Data

## Get a database reference

To read or write data from the database, you need an instance of
`DatabaseReference`:

```dart
DatabaseReference ref = FirebaseDatabase.instance.ref();
```

<<_usecase_security_preamble.md>>

## Reading and writing lists

### Append to a list of data

Use the `push()` method to append data to a list in multiuser applications.
The `push()` method generates a unique key every time a new child is added to
the specified Firebase reference. By using these auto-generated keys for each
new element in the list, several clients can add children to the same location
at the same time without write conflicts. The unique key generated by `push()`
is based on a timestamp, so list items are automatically ordered
chronologically.

You can use the reference to the new data returned by the `push()` method to get
the value of the child's auto-generated key or set data for the child. The
`.key` property of a `push()` reference contains the auto-generated key.

You can use these auto-generated keys to simplify flattening your data
structure. For more information, see the [data fan-out example](structure-data#fanout).

For example, `push()` could be used to add a new post to a list of posts
in a social application:

```dart
DatabaseReference postListRef = FirebaseDatabase.instance.ref("posts");
DatabaseReference newPostRef = postListRef.push();
newPostRef.set({
  // ...
});
```

### Listen for child events

Child events are triggered in response to specific operations that happen to
the children of a node from an operation such as a new child added through the
`push()` method or a child being updated through the `update()` method.

<table>
  <tr>
    <th>Event</th>
    <th>Typical usage</th>
  </tr>
  <tr>
    <td><code>onChildAdded</code></td>
    <td>
      Retrieve lists of items or listen for additions to a list of items.
      This event is triggered once for each existing child and then again
      every time a new child is added to the specified path. The listener is
      passed a snapshot containing the new child's data.
    </td>
  </tr>
  <tr>
    <td><code>onChildChanged</code></td>
    <td>
      Listen for changes to the items in a list.
      This event is triggered any time a child node is modified. This includes
      any modifications to descendants of the child node. The snapshot passed
      to the event listener contains the updated data for the child.
    </td>
  </tr>
  <tr>
    <td><code>onChildRemoved</code></td>
    <td>
      Listen for items being removed from a list. This event is triggered when
      an immediate child is removed.The snapshot passed to the callback block
      contains the data for the removed child.
    </td>
  </tr>
  <tr>
    <td><code>onChildMoved</code></td>
    <td>
      Listen for changes to the order of items in an ordered list.
      onChildMoved events always follow the
      onChildChanged event that caused the item's order to
      change (based on your current order-by method).
    </td>
  </tr>
</table>

Each of these together can be useful for listening to changes to a specific
node in a database. For example, a social blogging app might use these methods
together to monitor activity in the comments of a post, as shown below:

```dart
final commentsRef = FirebaseDatabase.instance.ref("post-comments/$postId");
commentsRef.onChildAdded.listen((event) {
  // A new comment has been added, so add it to the displayed list.
});
commentsRef.onChildChanged.listen((event) {
  // A comment has changed; use the key to determine if we are displaying this
  // comment and if so displayed the changed comment.
});
commentsRef.onChildRemoved.listen((event) {
  // A comment has been removed; use the key to determine if we are displaying
  // this comment and if so remove it.
});
```

### Listen for value events

While listening for child events is the recommended way to read lists of data,
there are situations listening for value events on a list reference is useful.

Attaching a `value` listener to a list of data will return the
entire list of data as a single snapshot which you can then loop over to
access individual children.

Even when there is only a single match for the query, the snapshot is still a
list; it just contains a single item. To access the item, you need to loop
over the result:

```dart
myTopPostsQuery.onValue.listen((event) {
  for (final child in event.snapshot.children) {
    // Handle the post.
  }
}, onError: (error) {
  // Error.
});
```

This pattern can be useful when you want to fetch all children of a list
in a single operation, rather than listening for additional child added
events.

## Sorting and filtering data

You can use the `Query` class to retrieve data sorted by
key, by value, or by value of a child. You can also filter
the sorted result to a specific number of results or a range of keys or
values.

Note: Filtering and sorting can be expensive, especially when done on the
client. If your app uses queries, define the `.indexOn` rule to index those
keys on the server and improve query performance as described in
[Indexing Your Data](/docs/database/security/indexing-data).


### Sort data

To retrieve sorted data, start by specifying one of the order-by methods to
determine how results are ordered:

<table>
  <tr>
    <th>Method</th>
    <th>Usage</th>
  </tr>
  <tr>
    <td><code>orderByChild()</code></td>
    <td>Order results by the value of a specified child key or nested child path.</td>
  </tr>
    <td><code>orderByKey()</code></td>
    <td>Order results by child keys.</td>
  <tr>
    <td><code>orderByValue()</code></td>
    <td>Order results by child values.</td>
  </tr>
</table>

You can only use **one** order-by method at a time. Calling an order-by method
multiple times in the same query throws an error.

The following example demonstrates how you could retrieve a list of a user's
top posts sorted by their star count:

```dart
final myUserId = FirebaseAuth.instance.currentUser?.uid;
final topUserPostsRef = FirebaseDatabase.instance
    .ref("user-posts/$myUserId")
    .orderByChild("starCount");
```

This defines a query that when combined with a [child listener](#child-events)
synchronizes the client with the user's posts from the path in the database
based on their user ID, ordered by the number of stars each post has received.
This technique of using IDs as index keys is called data fan out, you can read
more about it in
[Structure Your Database](structure-data#fanout).

The call to the `orderByChild()` method specifies the child key to order the
results by. In this case, posts are sorted by the value of their
respective `"starCount"` child. Queries can also be ordered by nested
children, in case you have data that looks like this:

```
"posts": {
  "ts-functions": {
    "metrics": {
      "views" : 1200000,
      "likes" : 251000,
      "shares": 1200,
    },
    "title" : "Why you should use TypeScript for writing Cloud Functions",
    "author": "Doug",
  },
  "android-arch-3": {
    "metrics": {
      "views" : 900000,
      "likes" : 117000,
      "shares": 144,
    },
    "title" : "Using Android Architecture Components with Firebase Realtime Database (Part 3)",
    "author": "Doug",
  }
},
```

In this case, we can order our list elements by values nested under the
`metrics` key by specifying the relative path to the nested child in our
`orderByChild()` call.

```dart
final mostViewedPosts =
    FirebaseDatabase.instance.ref('posts').orderByChild('metrics/views');
```

For more information on how other data types are ordered,
see [How query data is ordered](#data-order).


### Filtering data

To filter data, you can combine any of the limit or range methods with an
order-by method when constructing a query.

Note: You shouldn't use special Unicode characters in your keys, such as `\u{0000}`.
See the [Flutter issue](https://github.com/flutter/flutter/issues/116652) for more details.

<table>
  <tr>
    <th>Method</th>
    <th>Usage</th>
  </tr>
  <tr>
  <td><code>limitToFirst()</code></td>
  <td>Sets the maximum number of items to return from the beginning of the
    ordered list of results.</td>
  </tr>
  <tr>
  <td><code>limitToLast()</code></td>
  <td>Sets the maximum number of items to return from the end of the ordered
    list of results.</td>
  </tr>
  <tr>
  <td><code>startAt()</code></td>
  <td>Return items greater than or equal to the specified key or value,
    depending on the order-by method chosen.</td>
  </tr>
  <tr>
  <td><code>startAfter()</code></td>
  <td>Return items greater than the specified key or value
    depending on the order-by method chosen.</td>
  </tr>
  <tr>
  <td><code>endAt()</code></td>
  <td>Return items less than or equal to the specified key or value,
    depending on the order-by method chosen.</td>
  </tr>
  <tr>
  <td><code>endBefore()</code></td>
  <td>Return items less than the specified key or value
    depending on the order-by method chosen.</td>
  </tr>
  <tr>
  <td><code>equalTo()</code></td>
  <td>Return items equal to the specified key or value, depending on the
    order-by method chosen.</td>
  </tr>
</table>

Unlike the order-by methods, you can combine multiple limit or range functions.
For example, you can combine the `startAt()` and `endAt()` methods to limit
the results to a specified range of values.


#### Limit the number of results

You can use the `limitToFirst()` and `limitToLast()` methods to set a
maximum number of children to be synced for a given event. For example, if
you use `limitToFirst()` to set a limit of 100, you initially only receive up
to 100 `onChildAdded` events. If you have fewer than 100 items stored in your
Firebase database, a `onChildAdded` event fires for each item.

As items change, you receive `onChildAdded` events for items that enter the
query and `onChildRemoved` events for items that drop out of it so that
the total number stays at 100.

The following example demonstrates how example blogging app defines a query to
retrieve a list of the 100 most recent posts by all users:

```dart
final recentPostsRef = FirebaseDatabase.instance.ref('posts').limitToLast(100);
```

This example only defines a query, to actually synchronize data it needs to
have an attached [listener](#child-events).

#### Filter by key or value

You can use `startAt()`, `startAfter()`,`endAt()`, `endBefore()`, and
`equalTo()` to choose arbitrary starting, ending, and equivalence points for
queries. This can be useful for paginating data or finding items with children
that have a specific value.

### How query data is ordered {:#data-order}

This section explains how data is sorted by each of the order-by methods in the
`Query` class.


#### `orderByChild`
When using `orderByChild()`, data that contains the specified child key is
ordered as follows:

<ol>
  <li>Children with a <code>null</code> value for the specified child key come
    first.</li>
  <li>Children with a value of <code>false</code> for the specified child key
    come next. If multiple children have a value of <code>false</code>, they are
    sorted <a href="http://en.wikipedia.org/wiki/Lexicographical_order">lexicographically</a> by key.</li>
  <li>Children with a value of <code>true</code> for the specified child key
    come next. If multiple children have a value of <code>true</code>, they are
    sorted lexicographically by key.</li>
  <li>Children with a numeric value come next, sorted in ascending order. If
    multiple children have the same numerical value for the specified child
    node, they are sorted by key.</li>
  <li>Strings come after numbers and are sorted lexicographically in ascending
    order. If multiple children have the same value for the specified child
    node, they are ordered lexicographically by key.</li>
  <li>Objects come last and are sorted lexicographically by key in ascending order.</li>
</ol>

#### `orderByKey`

When using `orderByKey()` to sort your data, data is returned in ascending order
by key.

<ol>
  <li>Children with a key that can be parsed as a 32-bit integer come first, sorted in ascending order.</li>
  <li>Children with a string value as their key come next, sorted lexicographically in ascending order.</li>
</ol>


#### `orderByValue`

When using `orderByValue()`, children are ordered by their value. The ordering
criteria are the same as in `orderByChild()`, except the value of the node is
used instead of the value of a specified child key.

## Detach listeners

Callbacks are removed by calling the `off()` method on your
Firebase database reference.

You can remove a single listener by passing it as a parameter to `off()`.
Calling `off()` on the location with no arguments removes all listeners at that
location.

Calling `off()` on a parent listener does not
automatically remove listeners registered on its child nodes;
`off()` must also be called on any child listeners
to remove the callback.

## Next steps

  * [Learn how to structure data](structure-data)
  * [Store data offline](offline-capabilities)



================================================
File: docs/flutter/database/offline-capabilities.md
================================================
Project: /docs/database/_project.yaml
Book: /docs/_book.yaml
page_type: guide

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# Enabling Offline Capabilities

Firebase applications work even if your app temporarily loses its network
connection. In addition, Firebase provides tools for persisting data locally,
managing presence, and handling latency.

## Disk Persistence {:#section-disk-persistence}

Firebase apps automatically handle temporary network interruptions.
Cached data is available while offline and Firebase resends any writes
when network connectivity is restored.

When you enable disk persistence, your app writes the data locally to the
device so your app can maintain state while offline, even if the user
or operating system restarts the app.

You can enable disk persistence with just one line of code.

```dart
FirebaseDatabase.instance.setPersistenceEnabled(true);
```

### Persistence Behavior {:#section-offline-behavior}

By enabling persistence, any data that the Firebase Realtime Database client
would sync while online persists to disk and is available offline,
even when the user or operating system restarts the app. This means your
app works as it would online by using the local data stored in the cache.
Listener callbacks will continue to fire for local updates.

The Firebase Realtime Database client automatically keeps a queue of all
write operations that are performed while your app is offline.
When persistence is enabled, this queue is also persisted to disk so all
of your writes are available when the user or operating system
restarts the app. When the app regains connectivity, all of
the operations are sent to the Firebase Realtime Database server.

If your app uses [Firebase Authentication](/docs/auth),
the Firebase Realtime Database client persists the user's authentication
token across app restarts.
If the auth token expires while your app is offline, the client pauses
write operations until your app re-authenticates the user, otherwise the
write operations might fail due to security rules.

### Keeping Data Fresh {:#section-prioritizing-the-local-cache}

The Firebase Realtime Database synchronizes and stores a local copy of the
data for active listeners. In addition, you can keep specific locations
in sync.

```dart
final scoresRef = FirebaseDatabase.instance.ref("scores");
scoresRef.keepSynced(true);
```

The Firebase Realtime Database client automatically downloads the data at
these locations and keeps it in sync even if the reference has no
active listeners. You can turn synchronization back off with the
following line of code.

```dart
scoresRef.keepSynced(false);
```

By default, 10MB of previously synced data is cached. This should be
enough for most applications. If the cache outgrows its configured size,
the Firebase Realtime Database purges data that has been used least recently.
Data that is kept in sync is not purged from the cache.

### Querying Data Offline {:#section-offline-queries}

The Firebase Realtime Database stores data returned from a query for use
when offline. For queries constructed while offline,
the Firebase Realtime Database continues to work for previously loaded data.
If the requested data hasn't loaded, the Firebase Realtime Database loads
data from the local cache. When network connectivity is available again,
the data loads and will reflect the query.

For example, this code queries for the last four items in a database of scores:

```dart
final scoresRef = FirebaseDatabase.instance.ref("scores");
scoresRef.orderByValue().limitToLast(4).onChildAdded.listen((event) {
  debugPrint("The ${event.snapshot.key} dinosaur's score is ${event.snapshot.value}.");
});
```

Assume that the user loses connection, goes offline, and restarts the app.
While still offline, the app queries for the last two items from the
same location. This query will successfully return the last two items
because the app had loaded all four items in the query above.

```dart
scoresRef.orderByValue().limitToLast(2).onChildAdded.listen((event) {
  debugPrint("The ${event.snapshot.key} dinosaur's score is ${event.snapshot.value}.");
});
```

In the preceding example, the Firebase Realtime Database client raises
'child added' events for the highest scoring two dinosaurs, by using the
persisted cache. But it will not raise a 'value' event, since the app has
never executed that query while online.

If the app were to request the last six items while offline, it would get
'child added' events for the four cached items straight away. When the
device comes back online, the Firebase Realtime Database client synchronizes
with the server and gets the final two 'child added' and the
'value' events for the app.

### Handling Transactions Offline {:#section-handling-transactions-offline}

Any transactions that are performed while the app is offline, are queued.
Once the app regains network connectivity, the transactions are sent to
the Realtime Database server.

Note: **Transactions are not persisted across app restarts.**
Even with persistence enabled, transactions are not persisted across
app restarts. So you cannot rely on transactions done offline
being committed to your Firebase Realtime Database. To provide the best
user experience, your app should show that a transaction has not
been saved into your Firebase Realtime Database yet, or make sure your
app remembers them manually and executes them again after an app
restart.



The Firebase Realtime Database has many features for dealing with offline
scenarios and network connectivity. The rest of this guide applies to
your app whether or not you have persistence enabled.

## Managing Presence {:#section-presence}

In realtime applications it is often useful to detect when clients
connect and disconnect. For example, you may
want to mark a user as 'offline' when their client disconnects.

Firebase Database clients provide simple primitives that you can use to
write to the database when a client disconnects from the Firebase Database
servers. These updates occur whether the client disconnects cleanly or not,
so you can rely on them to clean up data even if a connection is dropped
or a client crashes. All write operations, including setting,
updating, and removing, can be performed upon a disconnection.

Here is a simple example of writing data upon disconnection by using the
`onDisconnect` primitive:

```dart
final presenceRef = FirebaseDatabase.instance.ref("disconnectmessage");
// Write a string when this client loses connection
presenceRef.onDisconnect().set("I disconnected!");
```

### How onDisconnect Works

When you establish an `onDisconnect()` operation, the operation
lives on the Firebase Realtime Database server. The server checks security to
make sure the user can perform the write event requested, and informs
the your app if it is invalid. The server then
monitors the connection. If at any point the connection times out, or is
actively closed by the Realtime Database client, the server checks security a
second time (to make sure the operation is still valid) and then invokes
the event.

```dart
try {
    await presenceRef.onDisconnect().remove();
} catch (error) {
    debugPrint("Could not establish onDisconnect event: $error");
}
```

An onDisconnect event can also be canceled by calling `.cancel()`:

```dart
final onDisconnectRef = presenceRef.onDisconnect();
onDisconnectRef.set("I disconnected");
// ...
// some time later when we change our minds
// ...
onDisconnectRef.cancel();
```

## Detecting Connection State {:#section-connection-state}

For many presence-related features, it is useful for your app
to know when it is online or offline. Firebase Realtime Database
provides a special location at `/.info/connected` which
is updated every time the Firebase Realtime Database client's connection state
changes. Here is an example:

```dart
final connectedRef = FirebaseDatabase.instance.ref(".info/connected");
connectedRef.onValue.listen((event) {
  final connected = event.snapshot.value as bool? ?? false;
  if (connected) {
    debugPrint("Connected.");
  } else {
    debugPrint("Not connected.");
  }
});
```

`/.info/connected` is a boolean value which is not
synchronized between Realtime Database clients because the value is
dependent on the state of the client. In other words, if one client
reads `/.info/connected` as false, this is no
guarantee that a separate client will also read false.

## Handling Latency {:#section-latency}

### Server Timestamps

The Firebase Realtime Database servers provide a mechanism to insert
timestamps generated on the server as data. This feature, combined with
`onDisconnect`, provides an easy way to reliably make note of
the time at which a Realtime Database client disconnected:

```dart
final userLastOnlineRef =
    FirebaseDatabase.instance.ref("users/joe/lastOnline");
userLastOnlineRef.onDisconnect().set(ServerValue.timestamp);
```

### Clock Skew

While `ServerValue.timestamp` is much more
accurate, and preferable for most read/write operations,
it can occasionally be useful to estimate the client's clock skew with
respect to the Firebase Realtime Database's servers. You
can attach a callback to the location `/.info/serverTimeOffset`
to obtain the value, in milliseconds, that Firebase Realtime Database clients
add to the local reported time (epoch time in milliseconds) to estimate
the server time. Note that this offset's accuracy can be affected by
networking latency, and so is useful primarily for discovering
large (> 1 second) discrepancies in clock time.

```dart
final offsetRef = FirebaseDatabase.instance.ref(".info/serverTimeOffset");
offsetRef.onValue.listen((event) {
  final offset = event.snapshot.value as num? ?? 0.0;
  final estimatedServerTimeMs =
      DateTime.now().millisecondsSinceEpoch + offset;
});
```

## Sample Presence App {:#section-sample}

By combining disconnect operations with connection state monitoring and
server timestamps, you can build a user presence system. In this system,
each user stores data at a database location to indicate whether or not a
Realtime Database client is online. Clients set this location to true when
they come online and a timestamp when they disconnect. This timestamp
indicates the last time the given user was online.

Note that your app should queue the disconnect operations before a user is
marked online, to avoid any race conditions in the event that the client's
network connection is lost before both commands can be sent to the server.

```dart
// Since I can connect from multiple devices, we store each connection
// instance separately any time that connectionsRef's value is null (i.e.
// has no children) I am offline.
final myConnectionsRef =
    FirebaseDatabase.instance.ref("users/joe/connections");

// Stores the timestamp of my last disconnect (the last time I was seen online)
final lastOnlineRef =
    FirebaseDatabase.instance.ref("/users/joe/lastOnline");

final connectedRef = FirebaseDatabase.instance.ref(".info/connected");
connectedRef.onValue.listen((event) {
  final connected = event.snapshot.value as bool? ?? false;
  if (connected) {
    final con = myConnectionsRef.push();

    // When this device disconnects, remove it.
    con.onDisconnect().remove();

    // When I disconnect, update the last time I was seen online.
    lastOnlineRef.onDisconnect().set(ServerValue.timestamp);

    // Add this device to my connections list.
    // This value could contain info about the device or a timestamp too.
    con.set(true);
  }
});
```



================================================
File: docs/flutter/database/read-and-write.md
================================================
Project: /docs/database/_project.yaml
Book: /docs/_book.yaml
page_type: guide

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# Read and Write Data

## (Optional) Prototype and test with Firebase Emulator Suite

Before talking about how your app reads from and writes to Realtime Database,
let's introduce a set of tools you can use to prototype and test Realtime Database
functionality: Firebase Emulator Suite. If you're trying out different data
models, optimizing your security rules, or working to find the most
cost-effective way to interact with the back-end, being able to work locally
without deploying live services can be a great idea.

A Realtime Database emulator is part of the Emulator Suite, which
enables your app to interact with your emulated database content and config, as
well as optionally your emulated project resources (functions, other databases,
and security rules).emulator_suite_short

Using the Realtime Database emulator involves just a few steps:

1.  Adding a line of code to your app's test config to connect to the emulator.
1.  From the root of your local project directory, running `firebase emulators:start`.
1.  Making calls from your app's prototype code using a Realtime Database platform
    SDK as usual, or using the Realtime Database REST API.

A detailed [walkthrough involving Realtime Database and Cloud Functions](/docs/emulator-suite/connect_and_prototype?database=RTDB) is available. You should also have a look at the [Emulator Suite introduction](/docs/emulator-suite/).

## Get a DatabaseReference

To read or write data from the database, you need an instance of
`DatabaseReference`:

```dart
DatabaseReference ref = FirebaseDatabase.instance.ref();
```

## Write data

This document covers the basics of reading and writing Firebase data.

Firebase data is written to a `DatabaseReference` and retrieved by
awaiting or listening for events emitted by the reference. Events are emitted
once for the initial state of the data and again anytime the data changes.

<<_usecase_security_preamble.md>>

### Basic write operations {:#basic_write}

For basic write operations, you can use `set()` to save data to a specified
reference, replacing any existing data at that path. You can set a reference
to the following types: `String`, `boolean`, `int`, `double`, `Map`, `List`.

For instance, you can add a user with `set()` as follows:

```dart
DatabaseReference ref = FirebaseDatabase.instance.ref("users/123");

await ref.set({
  "name": "John",
  "age": 18,
  "address": {
    "line1": "100 Mountain View"
  }
});
```

Using `set()` in this way overwrites data at the specified location,
including any child nodes. However, you can still update a child without
rewriting the entire object. If you want to allow users to update their profiles
you could update the username as follows:

```dart
DatabaseReference ref = FirebaseDatabase.instance.ref("users/123");

// Only update the age, leave the name and address!
await ref.update({
  "age": 19,
});
```

The `update()` method accepts a sub-path to nodes, allowing you to update multiple
nodes on the database at once:

```dart
DatabaseReference ref = FirebaseDatabase.instance.ref("users");

await ref.update({
  "123/age": 19,
  "123/address/line1": "1 Mountain View",
});
```

## Read data

### Read data by listening for value events {:#read_value_events}

To read data at a path and listen for changes, use the
`onValue` property of `DatabaseReference` to listen for
`DatabaseEvent`s.

You can use the `DatabaseEvent` to read the data at a given path,
as it exists at the time of the event. This event is triggered once when the
listener is attached and again every time the data, including any children,
changes. The event has a `snapshot` property containing all data at that
location, including child data. If there is no data, the snapshot's
`exists` property will be `false` and its `value` property will be null.

Important: A `DatabaseEvent` is fired every time data is changed at
the specified database reference, including changes to children. To limit the
size of your snapshots, attach only at the highest level needed for watching
changes. For example, attaching a listener to the root of your database is
not recommended.

The following example demonstrates a social blogging application retrieving the
details of a post from the database:

```dart
DatabaseReference starCountRef =
        FirebaseDatabase.instance.ref('posts/$postId/starCount');
starCountRef.onValue.listen((DatabaseEvent event) {
    final data = event.snapshot.value;
    updateStarCount(data);
});
```

The listener receives a `DataSnapshot` that contains the data at the specified
location in the database at the time of the event in its `value` property.

### Read data once

#### Read once using get()

The SDK is designed to manage interactions with database servers whether your
app is online or offline.

Generally, you should use the value events techniques described above to read
data to get notified of updates to the data from the backend. Those techniques
reduce your usage and billing, and are optimized to give your users the best
experience as they go online and offline.

If you need the data only once, you can use `get()` to get a snapshot of the
data from the database. If for any reason `get()` is unable to return the
server value, the client will probe the local storage cache and return an error
if the value is still not found.

The following example demonstrates retrieving a user's public-facing username
a single time from the database:

```dart
final ref = FirebaseDatabase.instance.ref();
final snapshot = await ref.child('users/$userId').get();
if (snapshot.exists) {
    print(snapshot.value);
} else {
    print('No data available.');
}
```

Unnecessary use of `get()` can increase use of bandwidth and lead to loss
of performance, which can be prevented by using a realtime listener as shown
above.

#### Read data once with once()

In some cases you may want the value from the local cache to be returned
immediately, instead of checking for an updated value on the server. In those
cases you can use `once()` to get the data from the local disk cache
immediately.

This is useful for data that only needs to be loaded once and isn't expected to
change frequently or require active listening. For instance, the blogging app
in the previous examples uses this method to load a user's profile when they
begin authoring a new post:

```dart
final event = await ref.once(DatabaseEventType.value);
final username = event.snapshot.value?.username ?? 'Anonymous';
```

## Updating or deleting data

### Update specific fields

To simultaneously write to specific children of a node without overwriting other
child nodes, use the `update()` method.

<a href="" id="fan-out"></a>
When calling `update()`, you can update lower-level child values by
specifying a path for the key. If data is stored in multiple locations to scale
better, you can update all instances of that data using
[data fan-out](structure-data#fanout). For example, a
social blogging app might want to create a post and simultaneously update it to
the recent activity feed and the posting user's activity feed. To do this, the
blogging application uses code like this:

```dart
void writeNewPost(String uid, String username, String picture, String title,
        String body) async {
    // A post entry.
    final postData = {
        'author': username,
        'uid': uid,
        'body': body,
        'title': title,
        'starCount': 0,
        'authorPic': picture,
    };

    // Get a key for a new Post.
    final newPostKey =
        FirebaseDatabase.instance.ref().child('posts').push().key;

    // Write the new post's data simultaneously in the posts list and the
    // user's post list.
    final Map<String, Map> updates = {};
    updates['/posts/$newPostKey'] = postData;
    updates['/user-posts/$uid/$newPostKey'] = postData;

    return FirebaseDatabase.instance.ref().update(updates);
}
```

This example uses `push()` to create a post in the node containing posts for
all users at `/posts/$postid` and simultaneously retrieve the key with
`key`. The key can then be used to create a second entry in the user's
posts at `/user-posts/$userid/$postid`.

Using these paths, you can perform simultaneous updates to multiple locations in
the JSON tree with a single call to `update()`, such as how this example
creates the new post in both locations. Simultaneous updates made this way
are atomic: either all updates succeed or all updates fail.

### Add a completion callback

If you want to know when your data has been committed, you can register
completion callbacks. Both `set()` and `update()` return `Future`s, to which
you can attach success and error callbacks that are called when the write has
been committed to the database and when the call was unsuccessful.

```dart
FirebaseDatabase.instance
    .ref('users/$userId/email')
    .set(emailAddress)
    .then((_) {
        // Data saved successfully!
    })
    .catchError((error) {
        // The write failed...
    });
```

### Delete data

The simplest way to delete data is to call `remove()` on a reference to the
location of that data.

You can also delete by specifying null as the value for another write operation
such as `set()` or `update()`. You can use this technique with `update()` to
delete multiple children in a single API call.

## Save data as transactions

When working with data that could be corrupted by concurrent modifications,
such as incremental counters, you can use a transaction by passing a 
transaction handler to `runTransaction()`. A transaction handler takes the
current state of the data as an argument and
returns the new desired state you would like to write. If another client
writes to the location before your new value is successfully written, your
update function is called again with the new current value, and the write is
retried.

For instance, in the example social blogging app, you could allow users to star
and unstar posts and keep track of how many stars a post has received as follows:

```dart
void toggleStar(String uid) async {
  DatabaseReference postRef =
      FirebaseDatabase.instance.ref("posts/foo-bar-123");

  TransactionResult result = await postRef.runTransaction((Object? post) {
    // Ensure a post at the ref exists.
    if (post == null) {
      return Transaction.abort();
    }

    Map<String, dynamic> _post = Map<String, dynamic>.from(post as Map);
    if (_post["stars"] is Map && _post["stars"][uid] != null) {
      _post["starCount"] = (_post["starCount"] ?? 1) - 1;
      _post["stars"][uid] = null;
    } else {
      _post["starCount"] = (_post["starCount"] ?? 0) + 1;
      if (!_post.containsKey("stars")) {
        _post["stars"] = {};
      }
      _post["stars"][uid] = true;
    }

    // Return the new data.
    return Transaction.success(_post);
  });
}
```

By default, events are raised each time the transaction update function runs,
so you run the function run multiple times, you may see intermediate states.
You can set `applyLocally` to `false` to suppress these intermediate states and
instead wait until the transaction has completed before events are raised:

```dart
await ref.runTransaction((Object? post) {
  // ...
}, applyLocally: false);
```

The result of a transaction is a `TransactionResult`, which contains information
such as whether the transaction was committed, and the new snapshot:

```dart
DatabaseReference ref = FirebaseDatabase.instance.ref("posts/123");

TransactionResult result = await ref.runTransaction((Object? post) {
  // ...
});

print('Committed? ${result.committed}'); // true / false
print('Snapshot? ${result.snapshot}'); // DataSnapshot
```

### Cancelling a transaction

If you want to safely cancel a transaction, call `Transaction.abort()` to 
throw an `AbortTransactionException`:

```dart
TransactionResult result = await ref.runTransaction((Object? user) {
  if (user !== null) {
    return Transaction.abort();
  }

  // ...
});

print(result.committed); // false
```

### Atomic server-side increments

In the above use case we're writing two values to the database: the ID of
the user who stars/unstars the post, and the incremented star count. If we
already know that user is starring the post, we can use an atomic increment
operation instead of a transaction.

```dart
void addStar(uid, key) async {
  Map<String, Object?> updates = {};
  updates["posts/$key/stars/$uid"] = true;
  updates["posts/$key/starCount"] = ServerValue.increment(1);
  updates["user-posts/$key/stars/$uid"] = true;
  updates["user-posts/$key/starCount"] = ServerValue.increment(1);
  return FirebaseDatabase.instance.ref().update(updates);
}
```

This code does not use a transaction operation, so it does not automatically get
re-run if there is a conflicting update. However, since the increment operation
happens directly on the database server, there is no chance of a conflict.

If you want to detect and reject application-specific conflicts, such as a user
starring a post that they already starred before, you should write custom
security rules for that use case.

## Work with data offline

If a client loses its network connection, your app will continue functioning
correctly.

Every client connected to a Firebase database maintains its own internal version
of any active data. When data is written, it's written to this local version
first. The Firebase client then synchronizes that data with the remote database
servers and with other clients on a "best-effort" basis.

As a result, all writes to the database trigger local events immediately, before
any data is written to the server. This means your app remains
responsive regardless of network latency or connectivity.

Once connectivity is reestablished, your app receives the appropriate set of
events so that the client syncs with the current server state, without having to
write any custom code.

Note: The Firebase Realtime Database web APIs do not persist data offline outside
of the session. In order for writes to be persisted to the server, the web
page must not be closed before the data is written to the server

We'll talk more about offline behavior in
[Learn more about online and offline capabilities](offline-capabilities).

## Next steps

* [Working with lists of data](lists-of-data)
* [Learn how to structure data](structure-data)
* [Learn more about online and offline capabilities](offline-capabilities)



================================================
File: docs/flutter/database/start.md
================================================
Project: /docs/database/_project.yaml
Book: /docs/_book.yaml
page_type: guide

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# Get Started with Realtime Database

## Prerequisites

1. [Install `firebase_core`](/docs/flutter/setup) and add the initialization code
   to your app if you haven't already.
1. Add your app to your Firebase project in the <a href="https://console.firebase.google.com/">Firebase console</a>.

## Create a Database

{# TODO(markarndt): Decide whether to include common files instead. #}

1.  Navigate to the **Realtime Database** section of the <a href="https://console.firebase.google.com/project/_/database">Firebase console</a>.
    You'll be prompted to select an existing Firebase project.
    Follow the database creation workflow.

1.  Select a starting mode for your security rules:

    **Test mode**

      Good for getting started with the mobile and web client libraries,
      but allows anyone to read and overwrite your data. After testing, **make
      sure to review the [Understand Firebase Realtime Database Rules](/docs/database/security/)
      section.**

    Note: If you create a database in Test mode and make no changes to the
      default world-readable and world-writeable security rules within a trial
      period, you will be alerted by email, then your database rules will
      deny all requests. Note the expiration date during the Firebase console
      setup flow.


    To get started, select testmode.

    **Locked mode**

    Denies all reads and writes from mobile and web clients.
      Your authenticated application servers can still access your database.

1.  Choose a region for the database. Depending on your choice of region,
    the database namespace will be of the form `<databaseName>.firebaseio.com` or
    `<databaseName>.<region>.firebasedatabase.app`. For more information, see
    [select locations for your project](/docs/projects/locations.md##rtdb-locations).

1.  Click **Done**.

When you enable Realtime Database, it also enables the API in the
[Cloud API Manager](https://console.cloud.google.com/projectselector/apis/api/firebasedatabase.googleapis.com/overview).

## Add Firebase Realtime Database to your app

1.  From the root of your Flutter project, run the following command to install the plugin:

    ```bash
    flutter pub add firebase_database
    ```
1.  Once complete, rebuild your Flutter application:

    ```bash
    flutter run
    ```

## Configure database rules

The Realtime Database provides a declarative rules language that allows you to
define how your data should be structured, how it should be indexed, and when
your data can be read from and written to.

<<_usecase_security_preamble.md>>

## Initialize the Firebase Realtime Database package

To start using the Realtime Database package within your project, import it at
the top of your project files:

```dart
import 'package:firebase_database/firebase_database.dart';
```

To use the default Database instance, call the `instance`
getter on `FirebaseDatabase`:

```dart
FirebaseDatabase database = FirebaseDatabase.instance;
```

If you'd like to use it with a secondary Firebase App, use the static `instanceFor` method:

```dart
FirebaseApp secondaryApp = Firebase.app('SecondaryApp');
FirebaseDatabase database = FirebaseDatabase.instanceFor(app: secondaryApp);
```

If you'd like to use a different RTDB instance on the same project, you can pass in a `databaseUrl` using
the static `instanceFor` method:

```dart
final firebaseApp = Firebase.app();
final rtdb = FirebaseDatabase.instanceFor(app: firebaseApp, databaseURL: 'https://your-realtime-database-url.firebaseio.com/');
```

## Next Steps

* Learn how to [structure data](structure-data) for Realtime Database.

* [Scale your data across multiple database instances.](/docs/database/usage/sharding)

* [Read and write data.](read-and-write)

* [View your database in the
  Firebase console.](//console.firebase.google.com/project/_/database/data)



================================================
File: docs/flutter/database/structure-data.md
================================================
Project: /docs/database/_project.yaml
Book: /docs/_book.yaml
page_type: guide

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# Structure Your Database

This guide covers some of the key concepts in data architecture and best
practices for structuring the JSON data in your Firebase Realtime Database.

Building a properly structured database requires quite a bit of forethought.
Most importantly, you need to plan for how data is going to be saved and
later retrieved to make that process as easy as possible.

## How data is structured: it's a JSON tree

All Firebase Realtime Database data is stored as JSON objects. You can think of
the database as a cloud-hosted JSON tree. Unlike a SQL database, there are no
tables or records. When you add data to the JSON tree, it becomes a node in the
existing JSON structure with an associated key. You can provide your own keys,
such as user IDs or semantic names, or they can be provided for you using
`push()`.

If you create your own keys, they must be UTF-8 encoded, can be a maximum
of 768 bytes, and cannot contain `.`, `$`, `#`, `[`, `]`, `/`, or ASCII control
characters 0-31 or 127. You cannot use ASCII control characters in the values
themselves, either.
{: .note }

For example, consider a chat application that allows users to store a basic
profile and contact list. A typical user profile is located at a path, such as
`/users/$uid`. The user `alovelace` might have a database entry that
looks something like this:

```
{
  "users": {
    "alovelace": {
      "name": "Ada Lovelace",
      "contacts": { "ghopper": true },
    },
    "ghopper": { ... },
    "eclarke": { ... }
  }
}
```

Although the database uses a JSON tree, data stored in the database can be
represented as certain native types that correspond to available JSON types
to help you write more maintainable code.

## Best practices for data structure

### Avoid nesting data

Because the Firebase Realtime Database allows nesting data up to 32 levels deep,
you might be tempted to think that this should be the default structure.
However, when you fetch data at a location in your database, you also retrieve
all of its child nodes. In addition, when you grant someone read or write access
at a node in your database, you also grant them access to all data under that
node. Therefore, in practice, it's best to keep your data structure as flat
as possible.

For an example of why nested data is bad, consider the following
multiply-nested structure:

```
{
  // This is a poorly nested data architecture, because iterating the children
  // of the "chats" node to get a list of conversation titles requires
  // potentially downloading hundreds of megabytes of messages
  "chats": {
    "one": {
      "title": "Historical Tech Pioneers",
      "messages": {
        "m1": { "sender": "ghopper", "message": "Relay malfunction found. Cause: moth." },
        "m2": { ... },
        // a very long list of messages
      }
    },
    "two": { ... }
  }
}
```

With this nested design, iterating through the data becomes problematic. For
example, listing the titles of chat conversations requires the entire `chats`
tree, including all members and messages, to be downloaded to the client.


### Flatten data structures

If the data is instead split into separate paths, also called denormalization,
it can be efficiently downloaded in separate calls, as it is needed. Consider
this flattened structure:

```
{
  // Chats contains only meta info about each conversation
  // stored under the chats's unique ID
  "chats": {
    "one": {
      "title": "Historical Tech Pioneers",
      "lastMessage": "ghopper: Relay malfunction found. Cause: moth.",
      "timestamp": 1459361875666
    },
    "two": { ... },
    "three": { ... }
  },

  // Conversation members are easily accessible
  // and stored by chat conversation ID
  "members": {
    // we'll talk about indices like this below
    "one": {
      "ghopper": true,
      "alovelace": true,
      "eclarke": true
    },
    "two": { ... },
    "three": { ... }
  },

  // Messages are separate from data we may want to iterate quickly
  // but still easily paginated and queried, and organized by chat
  // conversation ID
  "messages": {
    "one": {
      "m1": {
        "name": "eclarke",
        "message": "The relay seems to be malfunctioning.",
        "timestamp": 1459361875337
      },
      "m2": { ... },
      "m3": { ... }
    },
    "two": { ... },
    "three": { ... }
  }
}
```

It's now possible to iterate through the list of rooms by downloading only a
few bytes per conversation, quickly fetching metadata for listing or displaying
rooms in a UI. Messages can be fetched separately and displayed as they arrive,
allowing the UI to stay responsive and fast.


### Create data that scales {:#fanout}


When building apps, it's often better to download a subset of a list.
This is particularly common if the list contains thousands of records.
When this relationship is static and one-directional, you can simply nest the
child objects under the parent.

Sometimes, this relationship is more dynamic, or it may be necessary to
denormalize this data. Many times you can denormalize the data by using a query
to retrieve a subset of the data, as discussed in
[Sorting and filtering data](lists-of-data#sorting_and_filtering_data).

But even this may be insufficient. Consider, for example, a two-way relationship
between users and groups. Users can belong to a group, and groups comprise a
list of users. When it comes time to decide which groups a user belongs to,
things get complicated.

What's needed is an elegant way to list the groups a user belongs to and
fetch only data for those groups. An *index* of groups can help a
great deal here:

```
// An index to track Ada's memberships
{
  "users": {
    "alovelace": {
      "name": "Ada Lovelace",
      // Index Ada's groups in her profile
      "groups": {
         // the value here doesn't matter, just that the key exists
         "techpioneers": true,
         "womentechmakers": true
      }
    },
    ...
  },
  "groups": {
    "techpioneers": {
      "name": "Historical Tech Pioneers",
      "members": {
        "alovelace": true,
        "ghopper": true,
        "eclarke": true
      }
    },
    ...
  }
}
```

You might notice that this duplicates some data by storing the relationship
under both Ada's record and under the group. Now `alovelace` is indexed under a
group, and `techpioneers` is listed in Ada's profile. So to delete Ada
from the group, it has to be updated in two places.

This is a necessary redundancy for two-way relationships. It allows you to
quickly and efficiently fetch Ada's memberships, even when the list of users or
groups scales into the millions or when Realtime Database security rules
prevent access to some of the records.

This approach, inverting the data by listing the IDs as keys and setting the
value to true, makes checking for a key as simple as reading
`/users/$uid/groups/$group_id` and checking if it is `null`. The index is faster
and a good deal more efficient than querying or scanning the data.

## Next Steps

* [Read and Write Data to Realtime Database](read-and-write)



================================================
File: docs/flutter/dynamic-links/create.md
================================================
Project: /docs/dynamic-links/_project.yaml
Book: /docs/_book.yaml
page_type: guide

{% include "_local_variables.html" %}
{% include "docs/cpp/_local_variables.html" %}
{% include "docs/dynamic-links/_local_variables.html" %}

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# Create Dynamic Links in a Flutter app

{% include "docs/dynamic-links/_deprecation_banner.html" %}

You can create short or long Dynamic Links with the Firebase Dynamic Links Builder API.
This API accepts either a long Dynamic Link or an object containing Dynamic Link
parameters, and returns URLs like the following examples:

```
https://example.com/link/WXYZ
https://example.page.link/WXYZ
```

## Set up Firebase and the Dynamic Links SDK

Before you can create Dynamic Links in your Android app, you must include the
Firebase SDK. If your app is set up to receive Dynamic Links, you have already
completed these steps and you can skip this section.

1.  [Install and initialize the Firebase SDKs for Flutter](/docs/flutter/setup) if you
    haven't already done so.

1.  From the root direcctory of your Flutter project, run the following
    command to install the Dynamic Links plugin:

    ```
    flutter pub add firebase_dynamic_links
    ```

1.  If you're building an Android app, open the [Project settings](https://console.firebase.google.com/project/_/settings/general/)
    page of the Firebase console and make sure you've specified your SHA-1
    signing key. If you use App Links, also specify your SHA-256 key.

1.  In the Firebase console, open the [Dynamic Links](https://console.firebase.google.com/project/_/durablelinks)
    section.

    1.  If you have not already set up a domain for your Dynamic Links, click the
        **Get Started** button and follow the prompts.

        If you already have a Dynamic Links domain, take note of it. You need to
        provide a Dynamic Links domain when you programmatically create Dynamic Links.
        <img src="/docs/dynamic-links/images/dynamic-links-domain.png"></img>

    1.  **Recommended**: From the "More" (&vellip;) menu, specify the URL
        patterns allowed in your deep links and fallback links. By doing so,
        you prevent unauthorized parties from creating Dynamic Links that redirect
        from your domain to sites you don't control.

        See <a href="https://support.google.com/firebase/answer/9021429">Allow specific URL patterns</a>.

## Create a Dynamic Link from parameters

To create a Dynamic Link, create a new `DynamicLinkParameters` object and pass it to
`buildLink()` or `buildShortLink()`.

The following minimal example creates a long Dynamic Link to
`https://www.example.com/` that opens with `com.example.app.android` on Android
and the app `com.example.app.ios` on iOS:

```dart
final dynamicLinkParams = DynamicLinkParameters(
  link: Uri.parse("https://www.example.com/"),
  uriPrefix: "https://example.page.link",
  androidParameters: const AndroidParameters(packageName: "com.example.app.android"),
  iosParameters: const IOSParameters(bundleId: "com.example.app.ios"),
);
final dynamicLink =
    await FirebaseDynamicLinks.instance.buildLink(dynamicLinkParams);
```

To create a short Dynamic Link, pass the `DynamicLinkParameters` object to
`buildShortLink()`. Building the short link requires a network call.
For example:

```dart
final dynamicLinkParams = DynamicLinkParameters(
  link: Uri.parse("https://www.example.com/"),
  uriPrefix: "https://example.page.link",
  androidParameters: const AndroidParameters(packageName: "com.example.app.android"),
  iosParameters: const IOSParameters(bundleId: "com.example.app.ios"),
);
final dynamicLink =
    await FirebaseDynamicLinks.instance.buildShortLink(dynamicLinkParams);
```

By default, short Dynamic Links are generated with suffixes that are only a few
characters long. Although this makes links more compact, it also introduces
the possibility that someone could guess a valid short link. Often, there's no
harm if someone does so, because the link leads to public information.

However, if your short links lead to user-specific information, you should
create longer links with 17-character suffixes that make it very unlikely that
someone can guess a valid Dynamic Link. To do so, pass `ShortDynamicLinkType.unguessable`
to the `buildShortLink()` method:

```dart
final unguessableDynamicLink = await FirebaseDynamicLinks.instance.buildShortLink(
    dynamicLinkParams,
    shortLinkType: ShortDynamicLinkType.unguessable,
);
```

<h3>Dynamic Link parameters</h3>

You can use the Dynamic Link Builder API to create Dynamic Links with any of the
supported parameters. See the [API reference](https://pub.dev/documentation/firebase_dynamic_links_platform_interface/latest/firebase_dynamic_links_platform_interface/DynamicLinkParameters-class.html).

The following example creates a Dynamic Link with several common parameters
set:

```dart
final dynamicLinkParams = DynamicLinkParameters(
  link: Uri.parse("https://www.example.com/"),
  uriPrefix: "https://example.page.link",
  androidParameters: const AndroidParameters(
    packageName: "com.example.app.android",
    minimumVersion: 30,
  ),
  iosParameters: const IOSParameters(
    bundleId: "com.example.app.ios",
    appStoreId: "123456789",
    minimumVersion: "1.0.1",
  ),
  googleAnalyticsParameters: const GoogleAnalyticsParameters(
    source: "twitter",
    medium: "social",
    campaign: "example-promo",
  ),
  socialMetaTagParameters: SocialMetaTagParameters(
    title: "Example of a Dynamic Link",
    imageUrl: Uri.parse("https://example.com/image.png"),
  ),
);
final dynamicLink =
    await FirebaseDynamicLinks.instance.buildShortLink(dynamicLinkParams);
```

You can set Dynamic Link parameters with the following methods:

<table>
  <tr><th colspan="2" id="general-params">DynamicLink parameters</th></tr>
  <tr>
    <td>setLink</td>
    <td>The link your app will open. Specify a URL that your app can handle,
        typically the app's content or payload, which initiates app-specific
        logic (such as crediting the user with a coupon or displaying a
        welcome screen). This link must be a well-formatted URL, be properly
        URL-encoded, use either HTTP or HTTPS, and cannot be another Dynamic
        Link.
        <aside>When users open a Dynamic Link on a desktop web browser, they
            will load this URL (unless the ofl parameter is specified). If you
            don't have a web equivalent to the linked content, the URL doesn't
            need to point to a valid web resource. In this situation, you
            should set up a redirect from this URL to, for example, your home
            page.
        </aside>
    </td>
  </tr>
  <tr>
    <td>setDomainUriPrefix</td>
    <td>Your Dynamic Link URL prefix, which you can find in the Firebase console. A
      Dynamic Link domain looks like the following examples:
      <pre>
https://example.com/link
https://example.page.link
</pre>
    </td>
  </tr>
</table>

<table id="android-params">
  <tr><th colspan="2">AndroidParameters</th></tr>
  <tr>
    <td>setFallbackUrl</td>
    <td>The link to open when the app isn't installed. Specify this to do
        something other than install your app from the Play Store when the app
        isn't installed, such as open the mobile web version of the content, or
        display a promotional page for your app.</td>
  </tr>
  <tr>
    <td>setMinimumVersion</td>
    <td>The versionCode of the minimum version of your app that can open the
        link. If the installed app is an older version, the user is taken to
        the Play Store to upgrade the app.</td>
  </tr>
</table>

<table id="ios-params">
  <tr><th colspan="2">IosParameters</th></tr>
  <tr>
    <td>setAppStoreId</td>
    <td>Your app's App Store ID, used to send users to the App Store when the
        app isn't installed</td>
  </tr>
  <tr>
    <td>setFallbackUrl</td>
    <td>The link to open when the app isn't installed. Specify this to do
        something other than install your app from the App Store when the app
        isn't installed, such as open the mobile web version of the content, or
        display a promotional page for your app.</td>
  </tr>
  <tr>
    <td>setCustomScheme</td>
    <td>Your app's custom URL scheme, if defined to be something other than
        your app's bundle ID</td>
  </tr>
  <tr>
    <td>setIpadFallbackUrl</td>
    <td>The link to open on iPads when the app isn't installed. Specify this to
        do something other than install your app from the App Store when the
        app isn't installed, such as open the web version of the content, or
        display a promotional page for your app.</td>
  </tr>
  <tr>
    <td>setIpadBundleId</td>
    <td>The bundle ID of the iOS app to use on iPads to open the link. The app
        must be connected to your project from the Overview page of the
        Firebase console.</td>
  </tr>
  <tr>
    <td>setMinimumVersion</td>
    <td>The version number of the minimum version of your app that can open the
        link. This flag is passed to your app when it is opened, and your app
        must decide what to do with it.</td>
  </tr>
</table>

<table>
  <tr><th colspan="2">NavigationInfoParameters</th></tr>
  <tr>
    <td>setForcedRedirectEnabled</td>
    <td>If set to '1', skip the app preview page when the Dynamic Link is
        opened, and instead redirect to the app or store. The app preview page
        (enabled by default) can more reliably send users to the most
        appropriate destination when they open Dynamic Links in apps; however,
        if you expect a Dynamic Link to be opened only in apps that can open
        Dynamic Links reliably without this page, you can disable it with this
        parameter. This parameter will affect the behavior of the Dynamic Link
        only on iOS.</td>
  </tr>
</table>

<table id="social-params">
  <tr><th colspan="2">SocialMetaTagParameters</th></tr>
  <tr>
    <td>setTitle</td>
    <td>The title to use when the Dynamic Link is shared in a social post.</td>
  </tr>
  <tr>
    <td>setDescription</td>
    <td>The description to use when the Dynamic Link is shared in a social post.</td>
  </tr>
  <tr>
    <td>setImageUrl</td>
    <td>The URL to an image related to this link. The image should be at least
        300x200 px, and less than 300 KB.</td>
  </tr>
</table>

<table id="google-analytics-params">
  <tr><th colspan="2">GoogleAnalyticsParameters</th></tr>
  <tr>
    <td>setSource<br/>setMedium<br/>setCampaign<br/>setTerm<br/>setContent</td>
    <td>Google Play analytics parameters. These parameters
     (`utm_source`, `utm_medium`,
     `utm_campaign`, `utm_term`, `utm_content`)
     are passed on to the Play Store as well as appended to the link payload.
    </td>
  </tr>
</table>

<table id="itunes-analytics-params">
  <tr><th colspan="2">ItunesConnectAnalyticsParameters</th></tr>
  <tr>
    <td>setProviderToken<br/>setAffiliateToken<br/>setCampaignToken</td>
    <td>iTunes Connect analytics parameters. These parameters (`pt`,
      `at`, `ct`) are passed to the App Store.</td>
  </tr>
</table>



================================================
File: docs/flutter/dynamic-links/receive.md
================================================
Project: /docs/_project.yaml
Book: /docs/_book.yaml

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# Receive Firebase Dynamic Links in a Flutter app

{% include "docs/dynamic-links/_deprecation_banner.html" %}

To receive the Firebase Dynamic Links that <a href="/docs/dynamic-links/create-links">you created</a>,
you must include the Dynamic Links SDK in your app and call the
`FirebaseDynamicLinks.getDynamicLink()` method when your app loads to
get the data passed in the Dynamic Link.

## Set up Firebase and the Dynamic Links SDK

1.  [Install and initialize the Firebase SDKs for Flutter](/docs/flutter/setup) if you
    haven't already done so.

1.  From the root directory of your Flutter project, run the following
    command to install the Dynamic Links plugin:

    ```
    flutter pub add firebase_dynamic_links
    ```

1.  If you're building an Android app, open the [Project settings](https://console.firebase.google.com/project/_/settings/general/)
    page of the Firebase console and make sure you've specified your SHA-1
    signing key. If you use App Links, also specify your SHA-256 key.

## Platform integration

Complete the following platform integration steps for the platforms you're
building your app for.

### Android

On Android, you must add a new intent filter catch deep links of your domain, since the
Dynamic Link will redirect to your domain if your app is installed. This is required for your app to
receive the Dynamic Link data after it is installed/updated from the Play Store and one taps on
Continue button. In `AndroidManifest.xml`:

```xml
<intent-filter>
    <action android:name="android.intent.action.VIEW"/>
    <category android:name="android.intent.category.DEFAULT"/>
    <category android:name="android.intent.category.BROWSABLE"/>
    <data
        android:host="example.com"
        android:scheme="https"/>
</intent-filter>
```

When users open a Dynamic Link with a deep link to the scheme and host you specify, your app will
start the activity with this intent filter to handle the link.

The next step is to ensure the SHA-256 fingerprint of the signing certificate is registered in the Firebase console
for the app. You can find more details on how to retrieve your SHA-256 fingerprint on the
[Authenticating Your Client](https://developers.google.com/android/guides/client-auth) page.

### Apple platforms

1.  [Create an Apple developer account](https://developer.apple.com/programs/enroll/)
    if you don't already have one.

1.  On the [Project settings](https://console.firebase.google.com/project/_/settings/general/)
    page of the Firebase console, ensure that your iOS app is correctly
    configured with your App Store ID and Team ID.

1.  On the Apple Developer site, create a provisioning profile for your app
    with the Associated Domain capability enabled.

1.  In Xcode, do the following:

    1.  Open your app under the **TARGETS** header.

    1.  On the Signing & Capabilities page, ensure your Team is registered, and
        your Provisioning Profile is set.

    1.  On the Signing & Capabilities page, enable **Associated Domains** and
        add the following to the Associated Domains list (replace example with your domain):

        ```
        applinks:example.page.link
        ```

    1.  On the Info page, add a URL Type to your project. Set the URL Schemes
        field to your app's bundle ID. (The Identifier can be `Bundle ID` or
        whatever you wish.)

    1.  If you have set up a custom domain for your Firebase project, add the
        Dynamic Link URL prefix into your iOS project's `Info.plist` file
        using the `FirebaseDynamicLinksCustomDomains` key.

        ```xml
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
        <key>FirebaseDynamicLinksCustomDomains</key>
        <array>
            <string>https://custom.domain.io/path1</string>
            <string>https://custom.domain.io/path2</string>
        </array>

        ...other settings

        </dict>
        </plist>
        ```

    1.  **Optional:** Disable the Dynamic Links SDK's use of the iOS pasteboard.

        By default, the Dynamic Links SDK uses the pasteboard to improve the
        reliability of post-install deep links. By using the pasteboard, Dynamic
        Links can make sure that when a user opens a Dynamic Link but needs to
        install your app first, the user can go immediately to the original
        linked content when opening the app for the first time after
        installation.

        The downside of this is that use of the pasteboard triggers a
        notification on iOS 14 and later. So, the first time users open your
        app, if the pasteboard contains a Dynamic Link URL, they will see a
        notification that your app accessed the pasteboard, which can cause
        confusion.

        To disable this behavior, edit your Xcode project's `Info.plist` file
        and set the `FirebaseDeepLinkPasteboardRetrievalEnabled` key to `NO`.

        Note: When you disable this feature, the Dynamic Links you receive will have
        a `matchType` of `weak` at best. Adjust your app's logic accordingly.


## Handle deep links {:#handle_deep_links}

To handle a Dynamic Link in your application, two scenarios require implementing.

Warning: You may have unexpected results if you have enabled Flutter deep linking in your app.
See [Migrating from plugin-based deep linking](https://docs.flutter.dev/development/ui/navigation/deep-linking#migrating-from-plugin-based-deep-linking).
This [GitHub issue](https://github.com/firebase/flutterfire/issues/9469) illustrates what you ought to be aware of.

### Terminated State

Set up the following methods:

 1. `FirebaseDynamicLinks.getInitialLink` - returns a `Future<PendingDynamicLinkData?>`
 2. `FirebaseDynamicLinks.onLink` - event handler that returns a `Stream` containing a `PendingDynamicLinkData?`

Android will always receive the link via `FirebaseDynamicLinks.getInitialLink` from a terminated state,
but on iOS, it is not guaranteed. Therefore, it is worth setting them both up in the following order
to ensure your application receives the link:

```dart
Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(options: DefaultFirebaseConfig.platformOptions);

  // Check if you received the link via `getInitialLink` first
  final PendingDynamicLinkData? initialLink = await FirebaseDynamicLinks.instance.getInitialLink();

  if (initialLink != null) {
    final Uri deepLink = initialLink.link;
    // Example of using the dynamic link to push the user to a different screen
    Navigator.pushNamed(context, deepLink.path);
  }

  FirebaseDynamicLinks.instance.onLink.listen(
        (pendingDynamicLinkData) {
          // Set up the `onLink` event listener next as it may be received here
          if (pendingDynamicLinkData != null) {
            final Uri deepLink = pendingDynamicLinkData.link;
            // Example of using the dynamic link to push the user to a different screen
            Navigator.pushNamed(context, deepLink.path);
          }
        },
      );

  runApp(MyApp(initialLink));
}
```

Within your application logic, you can then check whether a link was handled and perform an action, for example:

```dart
if (initialLink != null) {
  final Uri deepLink = initialLink.link;
  // Example of using the dynamic link to push the user to a different screen
  Navigator.pushNamed(context, deepLink.path);
}
```

### Background / Foreground State

Whilst the application is open, or in the background, use the `FirebaseDynamicLinks.onLink`
getter:

```dart
FirebaseDynamicLinks.instance.onLink.listen((dynamicLinkData) {
  Navigator.pushNamed(context, dynamicLinkData.link.path);
}).onError((error) {
  // Handle errors
});
```

Alternatively, if you wish to identify if an exact Dynamic Link was used to open the application, pass it to
the `getDynamicLink` method instead:

```dart
String link = 'https://{{'<var>'}}dynamic-link-domain{{'</var>'}}/ke2Qa';

final PendingDynamicLinkData? initialLink = await FirebaseDynamicLinks.instance.getDynamicLink(Uri.parse(link));
```

### Testing A Dynamic Link On iOS Platform

To test a dynamic link on iOS, it is required that you use an actual device. You will also need to run the app in release mode (i.e. `flutter run --release`.),
if testing a dynamic link from a terminated (i.e. app has been swiped closed.) app state.



================================================
File: docs/flutter/in-app-messaging/_customize-messages.md
================================================
{# This content gets published to the following location:                                   #}
{#   https://firebase.google.com/docs/in-app-messaging/customize-messaging?platform=flutter #}

Firebase In-App Messaging provides a useful set of preconfigured behaviors and
message types with a default look and feel, but in some cases you may want to
extend behaviors and message content. In-App Messaging allows you to add actions
to messages and customize message look and feel.

## Add an action to your message

With actions you can use your in-app messages to direct users to a
website or a specific screen in your app.

### Implement a deep link handler

Firebase In-App Messaging uses link handlers to process actions. The SDK is
able to use a number of handlers, so if your app already has one, Firebase
In-App Messaging can use that without any further setup. If you don't yet have
a handler, you can use [Firebase Dynamic Links](/docs/dynamic-links).

### Add the action to your message using the Firebase console

Once your app has a link handler, you're ready to compose a campaign with
an action. Open the Firebase console to
[In-App Messaging](https://console.firebase.google.com/project/_/inappmessaging),
and start a new campaign or edit an existing campaign. In that campaign, provide
a **Card**, **Button text** and **Button action**, an **Image action**, or a **Banner
action**, where the action is a relevant deep link.

The action's format depends on which message layout you choose. Modals get
action buttons with customizable button text content, text color, and background
color. Images and top banners, on the other hand, become interactive and invoke
the specified action when tapped.



================================================
File: docs/flutter/in-app-messaging/_get-started.md
================================================
{# This content gets published to the following location:                           #}
{#   https://firebase.google.com/docs/in-app-messaging/get-started?platform=flutter #}

## Before you begin

[Install and initialize the Firebase SDKs for Flutter](/docs/flutter/setup) if you
haven't already done so.

## Add the Firebase In-App Messaging SDK to your project

1.  From the root directory of your Flutter project, run the following
    command to install the Firebase In-App Messaging plugin:

    ```bash
    flutter pub add firebase_in_app_messaging
    ```

1.  Rebuild your project:

    ```bash
    flutter run
    ```

1.  Import the Firebase In-App Messaging plugin:

    ```dart
    import 'package:firebase_in_app_messaging/firebase_in_app_messaging.dart';
    ```

## Send a test message

### Get your app's installation ID

To conserve power, Firebase In-App Messaging only retrieves messages from the
server once per day. That can make testing difficult, so the
Firebase console allows you to specify a test device that displays messages
on demand.

That testing device is determined by a FID.
Find your testing app's FID by checking the console
output when you run your app.

On Android, the message looks like the following:

```
I/FIAM.Headless: Starting InAppMessaging runtime with Installation ID YOUR_INSTALLATION_ID
```

On iOS, run the app with the runtime command argument `-FIRDebugEnabled`:

1.  With your Xcode project open, select **Product > Scheme > Edit scheme...** from
    the top menu bar.
1.  Open the **Arguments** tab of the dialog that pops up.
1.  Click **+ Add items** under **Arguments Passed On Launch**.
1.  Enter "-FIRDebugEnabled" in the newly-created field.
1.  Click **Close**, then run your app.

Once your app starts running, look for the following line in the Xcode console's logs:

```
[Firebase/InAppMessaging][I-IAM180017] Starting InAppMessaging runtime with Firebase Installation ID YOUR_INSTALLATION_ID
```


### Send a message to your testing device

Once you've launched your app on the testing device and you have its
Firebase installation ID (FID), you can try out your Firebase In-App Messaging
setup by sending a test message:

1.  In the {{name_appmanager}}, open [Messaging](https://console.firebase.google.com/project/_/messaging/).
1.  If this is your first campaign, click **Create your first campaign**.
    1. Select **Firebase In-App messages** and click **Create**.
1.  Otherwise, on the **Campaigns** tab, click **New campaign**.
    1. Select **In-App Messaging**.
1.  Enter a **Title** for your first message.
1.  Click **Test on your Device**
1.  Enter your app's Firebase installation ID in the
    **Add an installation ID** field.
1.  Click **Test** to send the message.

Firebase In-App Messaging sends your test message as soon as you click **Test**. To see the
message, you need to close, then reopen the app on your testing device.

To confirm whether your device is a test device, look for one of the following
log messages.

**Android**

```
I/FIAM.Headless: Setting this device as a test device
```

**iOS**

```
[Firebase/InAppMessaging][I-IAM180017] Seeing test message in fetch response. Turn the current instance into a testing instance.
```



================================================
File: docs/flutter/in-app-messaging/_modify-message-behavior.md
================================================
{# This content gets published to the following location:                                       #}
{#   https://firebase.google.com/docs/in-app-messaging/modify-message-behavior?platform=flutter #}

With little to no coding effort, Firebase In-App Messaging allows you to create,
configure and target rich user interactions, leveraging
the capabilities of Google Analytics out of the box
to tie messaging events to actual user characteristics, activities, and choices.
With some additional Firebase In-App Messaging SDK integration, you can tailor
the behavior of in-app messages even further, responding when users interact
with messages, triggering message events outside the Analytics
framework, and allowing users to control sharing of their personal data related
to messaging interactions.

## Respond when users interact with in-app messages

With actions you can use your in-app messages to direct users to a
website or a specific screen in your app.

Your code can respond to basic interactions (clicks and dismissals), to
impressions (verified views of your messages), and to display errors logged and
confirmed by the SDK. For example, when your message is composed as a Card
modal, you might want to track and follow-up on which of two URLs the user
clicked on the Card.

To do so, you will have to use the platform-native APIs.
See the documentation for [iOS](/docs/in-app-messaging/modify-message-behavior?platform=ios#respond_when_users_interact_with_in-app_messages)
and [Android](/docs/in-app-messaging/modify-message-behavior?platform=android#respond_when_users_interact_with_in-app_messages).

## Trigger in-app messages programmatically

Firebase In-App Messaging by default allows you to trigger in-app messages with
Google Analytics for Firebase events, with no additional integration. You can
also manually trigger events programmatically with the Firebase In-App Messaging SDK's
programmatic triggers.

In the In-App Messaging campaign composer, create a new campaign or select an
existing campaign, and in the Scheduling step of the composer workflow, note the
event ID of a newly-created or existing messaging event. Once noted, instrument
your app to trigger the event by its ID.

```dart
FirebaseInAppMessaging.instance.triggerEvent("eventName");
```

## Use campaign custom metadata

In your campaigns, you can specify custom data in a series of key/value pairs.
When users interact with messages, this data is available for you to, for example,
display a promo code.

To do so, you will have to use the platform-native APIs.
See the documentation for [iOS](/docs/in-app-messaging/modify-message-behavior?platform=ios#use_campaign_custom_metadata)
and [Android](/docs/in-app-messaging/modify-message-behavior?platform=android#use_campaign_custom_metadata).


## Temporarily disable in-app messages

By default, Firebase In-App Messaging renders messages whenever a triggering
condition is satisfied, regardless of an app's current state. If you'd like to
suppress message displays for any reason, for example to avoid interrupting a
sequence of payment processing screens, you can do that with the SDK's
`setMessagesSuppressed()` method:

```dart
FirebaseInAppMessaging.instance.setMessagesSuppressed(true);
```

Passing `true` to the method prevents Firebase In-App Messaging from displaying
messages, while `false` reenables message display. The SDK turns off message
suppression on app restart. Suppressed messages are ignored by the SDK. Their
trigger conditions must be met again while suppression is off before Firebase
In-App Messaging can display them.

## Enable opt-out message delivery

By default, Firebase In-App Messaging automatically delivers messages to all app users you target
in messaging campaigns. To deliver those messages, the Firebase In-App Messaging SDK uses
installation IDs to identify each user's app. This means
that In-App Messaging has to send client data, linked to the
installation ID, to Firebase servers. If you'd like to give users
more control over the data they send, disable automatic data collection and give
them a chance to approve data sharing.

To do that, you have to disable automatic initialization for Firebase In-App Messaging, and
initialize the service manually for opt-in users:

1.  Turn off automatic initialization.

    **Apple platforms**: Add a new key to your `Info.plist` file:

    - Key: `FirebaseInAppMessagingAutomaticDataCollectionEnabled`
    - Value: `NO`

    **Android**: Add a `meta-data` tag to your `AndroidManifest.xml` file:

    ```xml
    <meta-data
        android:name="firebase_inapp_messaging_auto_data_collection_enabled"
        android:value="false" />
    ```

1.  Initialize Firebase In-App Messaging for selected users manually:

    ```dart
    FirebaseInAppMessaging.instance.setAutomaticDataCollectionEnabled(true);
    ```

    Once you set a data collection preference manually, the value persists
    through app restarts, overriding the value in your `Info.plist` or
    `AndroidManifest.xml`. If you'd like to disable initialization again, for
    example if a user opts out of collection later, pass `false` to the
    `setAutomaticDataCollectionEnabled()` method.



================================================
File: docs/flutter/ml/use-custom-models.md
================================================
Project: /docs/_project.yaml
Book: /docs/_book.yaml

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# Use a custom TensorFlow Lite model with Flutter

If your app uses custom
[TensorFlow Lite](https://www.tensorflow.org/lite/){:.external} models, you can
use Firebase ML to deploy your models. By deploying models with Firebase, you
can reduce the initial download size of your app and update your app's ML models
without releasing a new version of your app. And, with Remote Config and A/B
Testing, you can dynamically serve different models to different sets of users.

## TensorFlow Lite models

TensorFlow Lite models are ML models that are optimized to run on mobile
devices. To get a TensorFlow Lite model:

- Use a pre-built model, such as one of the [official TensorFlow Lite models](https://www.tensorflow.org/lite/models){:.external}
- [Convert a TensorFlow model, Keras model, or concrete function to TensorFlow Lite.](https://www.tensorflow.org/lite/convert){:.external}

Note that in the absence of a maintained TensorFlow Lite library for Dart, you
will need to integrate with the native TensorFlow Lite library for your
platforms. This integration is not documented here.

## Before you begin

1.  [Install and initialize the Firebase SDKs for Flutter](/docs/flutter/setup)
    if you haven't already done so.

1.  From the root directory of your Flutter project, run the following
    command to install the ML model downloader plugin:

    ```bash
    flutter pub add firebase_ml_model_downloader
    ```

1.  Rebuild your project:

    ```bash
    flutter run
    ```

## 1. Deploy your model {:#deploy}

Deploy your custom TensorFlow models using either the Firebase console or
the Firebase Admin Python and Node.js SDKs. See
[Deploy and manage custom models](/docs/ml/manage-hosted-models).

After you add a custom model to your Firebase project, you can reference the
model in your apps using the name you specified. At any time, you can deploy a
new TensorFlow Lite model and download the new model onto users' devices by
calling `getModel()` (see below).

## 2. Download the model to the device and initialize a TensorFlow Lite interpreter

To use your TensorFlow Lite model in your app, first use the model downloader
to download the latest version of the model to the device. Then, instantiate a
TensorFlow Lite interpreter with the model.

To start the model download, call the model downloader's `getModel()` method,
specifying the name you assigned the model when you uploaded it, whether you
want to always download the latest model, and the conditions under which you
want to allow downloading.

You can choose from three download behaviors:

| Download type                    | Description
|----------------------------------|--------------------------------------------
| `localModel`                     | Get the local model from the device.
:                                  : If there is no local model available, this
:                                  : behaves like `latestModel`. Use this
:                                  : download type if you are not interested in
:                                  : checking for model updates. For example,
:                                  : you're using Remote Config to retrieve
:                                  : model names and you always upload models
:                                  : under new names (recommended).
| `localModelUpdateInBackground`   | Get the local model from the device and
:                                  : start updating the model in the background.
:                                  : If there is no local model available, this
:                                  : behaves like `latestModel`.
| `latestModel`                    | Get the latest model. If the local model is
:                                  : the latest version, returns the local
:                                  : model. Otherwise, download the latest
:                                  : model. This behavior will block until the
:                                  : latest version is downloaded (not
:                                  : recommended). Use this behavior only in
:                                  : cases where you explicitly need the latest
:                                  : version.

You should disable model-related functionality&mdash;for example, grey-out or
hide part of your UI&mdash;until you confirm the model has been downloaded.

```dart
FirebaseModelDownloader.instance
    .getModel(
        "yourModelName",
        FirebaseModelDownloadType.localModel,
        FirebaseModelDownloadConditions(
          iosAllowsCellularAccess: true,
          iosAllowsBackgroundDownloading: false,
          androidChargingRequired: false,
          androidWifiRequired: false,
          androidDeviceIdleRequired: false,
        )
    )
    .then((customModel) {
      // Download complete. Depending on your app, you could enable the ML
      // feature, or switch from the local model to the remote model, etc.

      // The CustomModel object contains the local path of the model file,
      // which you can use to instantiate a TensorFlow Lite interpreter.
      final localModelPath = customModel.file;

      // ...
    });
```

Many apps start the download task in their initialization code, but you can do
so at any point before you need to use the model.


## 3. Perform inference on input data

Now that you have your model file on the device you can use it with the
TensorFlow Lite interpreter to perform inference. In the absence of a maintained
TensorFlow Lite library for Dart, you will need to integrate with the
[native TensorFlow Lite libraries](https://www.tensorflow.org/lite){:.external}
for iOS and Android.


## Appendix: Model security {:#model_security}

Regardless of how you make your TensorFlow Lite models available to
Firebase ML, Firebase ML stores them in the standard serialized protobuf format in
local storage.

In theory, this means that anybody can copy your model. However,
in practice, most models are so application-specific and obfuscated by
optimizations that the risk is similar to that of competitors disassembling and
reusing your code. Nevertheless, you should be aware of this risk before you use
a custom model in your app.



================================================
File: docs/flutter/perf-mon/_custom-code-traces.md
================================================
{# This content gets published to the following location:                          #}
{#   https://firebase.google.com/docs/perf-mon/custom-code-traces?platform=flutter #}

Performance Monitoring collects _traces_ to help you monitor the performance of your app. A
trace is a report of performance data captured between two points in time in
your app.

You can create your own traces to monitor performance data associated with
specific code in your app. With a **_custom code trace_**, you can measure how
long it takes your app to complete a specific task or a set of tasks, for
example loading a set of images or querying your database.

The default metric for a custom code trace is its "duration" (the time between
the starting and stopping points of the trace), but you can add
**_custom metrics_**, as well.

In your code, you define the beginning and the end of a custom code trace using
the APIs provided by the Performance Monitoring SDK.

Custom code traces can be started anytime after they've been created, and they
are thread safe.

Since the default metric collected for these traces is "duration", they are
sometimes called "Duration traces".

You can view data from these traces in the _Custom traces_ subtab of the traces
table, which is at the bottom of the _Performance_ dashboard (learn more about
[using the console](#monitor-in-console) later on this page).

Note: Starting and stopping traces too rapidly can be resource intensive, so
you should avoid creating custom code traces at high frequencies (for example,
once per frame in games).

## Default attributes, custom attributes, and custom metrics {:#attributes-and-metrics}

For custom code traces, Performance Monitoring automatically logs
[**_default attributes_**](/docs/perf-mon/attributes)
(common metadata like app version, country, device, etc.)
so that you can filter the data for the trace in the Firebase console. You
can also add and monitor [**_custom attributes_**](#create-custom-attributes)
(such as, game level or user properties).

You can further configure a custom code trace to record
[**_custom metrics_**](#add-custom-metrics) for performance-related events that
occur within the trace's scope. For example, you can create a custom metric for
the number of cache hits and misses or the number of times that the UI becomes
unresponsive for a noticeable period of time.

Custom attributes and custom metrics display in the Firebase console
alongside the default attributes and default metric for the trace.

<aside class="objective">An <em>attribute</em> is a string value that helps
  you filter and segment data in the console. A <em>metric</em> is a numeric
  value that can be charted and measured over time.</aside>


##  Add custom code traces {:#add-custom-code-traces}

Use the Performance Monitoring Trace API 
to add custom code traces to monitor specific application code.

Note the following:

* An app can have multiple custom code traces.
* More than one custom code trace can run at the same time.
* Names for custom code traces must meet the following requirements:
  no leading or trailing whitespace, no leading underscore (`_`) character,
  and max length is 100 characters.
* Custom code traces support adding [custom metrics](#add-custom-metrics) and
  [custom attributes](#create-custom-attributes).

To start and stop a custom code trace, wrap the code that you want to trace with
code similar to the following:

```dart
Trace customTrace = FirebasePerformance.instance.newTrace('custom-trace');
await customTrace.start();

// Code you want to trace

await customTrace.stop();
```

## Add custom metrics to custom code traces {:#add-custom-metrics}

Use the Performance Monitoring Trace API
to add custom metrics to custom code traces.

Note the following:

* Names for custom metrics must meet the following requirements:
  no leading or trailing whitespace, no leading underscore (`_`) character,
  and max length is 100 characters.
* Each custom code trace can record up to 32 metrics (including the default
  _Duration_ metric).

To add a custom metric, add a line of code similar to the following each time
that the event occurs. For example, this custom metric counts
performance- related events that occur in your app, such as cache hits or
retries.

```dart
Trace customTrace = FirebasePerformance.instance.newTrace("custom-trace");
await customTrace.start();

// Code you want to trace

customTrace.incrementMetric("metric-name", 1);

// More code

await customTrace.stop();
```


## Create custom attributes for custom code traces {:#create-custom-attributes}

To use custom attributes, add code to your app that defines the attribute and
associates it with a specific custom code trace. You can set the custom
attribute anytime between when the trace starts and when the trace stops.

Note the following:

* Names for custom attributes must meet the following requirements:
  no leading or trailing whitespace, no leading underscore (`_`) character,
  and max length is 32 characters.

* Each custom code trace can record up to 5 custom attributes.

* You shouldn't use custom attributes that contain information that personally
  identifies an individual to Google.

  {{'<aside>'}}
  **Collecting user data**

  Performance Monitoring does not itself collect any
  personally identifiable information (PII), such as names, email addresses, or
  phone numbers. Developers can collect additional data using Performance
  Monitoring by creating custom attributes on custom code traces. Such data
  collected through Performance Monitoring should not contain information that
  personally identifies an individual to Google.

  Here's an example of a log message that does not contain personally
  identifiable information:

  ```dart
  customTrace.putAttribute("experiment", "A");  // OK
  ```

  Here's an example that does contain personally identifiable information (do
  not use this type of custom attribute in your app):

  ```dart
  customTrace.putAttribute(("email", user.getEmailAddress());  // Don't do this!
  ```

  Data that exposes any personally identifiable information is subject to
  deletion without notice.

  {{'</aside>'}}

```dart
Trace trace = FirebasePerformance.instance.newTrace("test_trace");

// Update scenario.
trace.putAttribute("experiment", "A");

// Reading scenario.
String? experimentValue = trace.getAttribute("experiment");

// Delete scenario.
trace.removeAttribute("experiment");

// Read attributes.
Map<String, String> traceAttributes = trace.getAttributes();
```

## Track, view, and filter performance data {:#monitor-in-console}

### Track specific metrics in your dashboard {:#track-in-dashboard}

To learn how your key metrics are trending, add them to your metrics board at
the top of the _Performance_ dashboard. You can quickly identify regressions by
seeing week-over-week changes or verify that recent changes in your code are
improving performance.

To add a metric to your metrics board, go to the [_Performance_ dashboard](https://console.firebase.google.com/project/_/performance)
in the Firebase console, then click the _Dashboard_ tab. Click an empty metric
card, then select an existing metric to add to your board. Click the vertical
ellipsis (**&#8942;**) on a populated metric card for more options, like to
replace or remove a metric.

The metrics board shows collected metric data over time, both in graphical form
and as a numerical percentage change.

Learn more about [using the dashboard](/docs/perf-mon/console).


### View traces and their data {:#view-traces-and-data}

To view your traces, go to the [_Performance_ dashboard](https://console.firebase.google.com/project/_/performance)
in the Firebase console, scroll down to the traces table, then click the
appropriate subtab. The table displays some top metrics for each trace, and you
can even sort the list by the percentage change for a specific metric.

If you click a trace name in the traces table, you can then click throug
various screens to explore the trace and drill down into metrics of interest.
On most pages, you can use the **Filter** button (top-left of the screen) to
filter the data by attribute, for example:

- Filter by _App version_ to view data about a past release or your latest
  release
- Filter by _Device_ to learn how older devices handle your app
- Filter by _Country_ to make sure your database location isn't affecting a
  specific region

Learn more about [viewing data for your traces](/docs/perf-mon/console#view-traces-and-data).


## Next Steps

* Learn more about
  [using attributes](/docs/perf-mon/attributes) to examine performance data.

* Learn more about how to
  [track performance issues](/docs/perf-mon/issue-management) in the
  Firebase console.

* [Set up alerts](/docs/perf-mon/alerts) for code changes that are degrading
  the performance of your app. For example, you can configure an email alert for
  your team if the _duration_ of a specific custom code trace exceeds a
  threshold that you set.



================================================
File: docs/flutter/perf-mon/_custom-network-traces.md
================================================
{# This content gets published to the following location:                             #}
{#   https://firebase.google.com/docs/perf-mon/custom-network-traces?platform=flutter #}

Performance Monitoring collects _traces_ to help you monitor the performance of your app. A
trace is a report of performance data captured between two points in time in
your app.

The
[network request traces automatically collected by Performance Monitoring](/docs/perf-mon/network-traces)
include most network requests for your app. However, some requests might not be
reported or you might use a different library to make network requests. In these
cases, you can use the Performance Monitoring API to manually instrument
**_custom network request traces_**. Custom network request traces are only
supported for Apple and Android apps.

The default metrics for a custom network request trace are the same as those for
the network request traces automatically collected by Performance Monitoring, specifically
response time, response and request payload size, and success rate. Custom
network request traces do not support adding custom metrics.

In your code, you define the beginning and the end of a custom network request
trace using the APIs provided by the Performance Monitoring SDK.

Custom network request traces appear in the Firebase console alongside the
network requests that Performance Monitoring captures automatically
(in the _Network requests_ subtab of the traces table).


## Add custom network request traces {:#add-custom-network-traces}

Use the Performance Monitoring HttpMetric API
to add custom network request traces to monitor specific network requests.

To manually instrument custom network requests in Performance Monitoring, add code similar
to the following:

```dart
final metric = FirebasePerformance.instance
    .newHttpMetric("https://www.google.com", HttpMethod.Get);

await metric.start();
final response = await http.get(Uri.parse("https://www.google.com/"));
await metric.stop();
```

Custom network request traces also support adding custom attributes
but not custom metrics.


## Next steps

* [Set up alerts](/docs/perf-mon/alerts) for network requests that are degrading
  the performance of your app. For example, you can configure an email alert for
  your team if the _response time_ for a specific URL pattern exceeds a
  threshold that you set.



================================================
File: docs/flutter/perf-mon/_disable-sdk.md
================================================
{# This content gets published to the following location:                   #}
{#   https://firebase.google.com/docs/perf-mon/disable-sdk?platform=flutter #}

During app development and testing, you might find it useful to disable
Performance Monitoring.

For example, by
[disabling Performance Monitoring during your app build process](#disable-during-build),
you can:

* Disable certain functionalities of Performance Monitoring in your debug
  builds, but re-enable the functionalities for your release build.

* Disable Performance Monitoring when building your app, but allow your app to
  re-enable it at runtime.

* Disable Performance Monitoring when building your app, and do not allow your
  app to re-enable it at runtime.

You can also build your app with Performance Monitoring _enabled_, but
[use Firebase Remote Config](#disable-with-remote-config) to give you
flexibility to disable (and re-enable) Performance Monitoring in your production
app. With this option, you can even configure your app to let users opt-in or
opt-out of using Performance Monitoring.

## Disable Performance Monitoring during your app build process {: #disable-during-build}

One situation where disabling Performance Monitoring during your app build
process could be useful is to avoid reporting performance data from a
pre-release version of your app during app development and testing.

To do so, see the platform-specific [iOS+](?platform=ios) and
[Android](?platform=android) docs.


## Disable your app at runtime using Remote Config {: #disable-with-remote-config}

[Firebase Remote Config](/docs/remote-config/get-started?platform=flutter) lets
you make changes to the behavior and appearance of your app, so it provides an
ideal way to let you disable Performance Monitoring in deployed instances of
your app.

For example, suppose you want to use a parameter called `perf_disable` to
remotely control Performance Monitoring. Add the following to your startup code
to enable or disable Performance Monitoring:

```dart
// Activate previously-fetched values, falling back on the defaults if
// nothing is available yet.
await FirebaseRemoteConfig.instance
    .setDefaults(YOUR_REMOTE_CONFIG_DEFAULTS);
await FirebaseRemoteConfig.instance.activate();

// Enable or disable Performance Monitoring based on the value of
// "perf_disable".
final perfMonDisabled =
    FirebaseRemoteConfig.instance.getBool("perf_disable");
FirebasePerformance.instance
    .setPerformanceCollectionEnabled(!perfMonDisabled);

// Fetch values for next time. (Don't await the result!)
FirebaseRemoteConfig.instance.fetch();
```

Note: This snippet requires an app restart to activate configuration changes.
See [Loading strategies](/docs/remote-config/loading) for alternatives.





================================================
File: docs/flutter/perf-mon/get-started.md
================================================
Project: /docs/perf-mon/_project.yaml
Book: /docs/_book.yaml
page_type: guide

{% include "_shared/apis/console/_local_variables.html" %}
{% include "_local_variables.html" %}
{% include "docs/perf-mon/_local_variables.html" %}
{% include "_shared/firebase/_snippet_include_comment.html" %}

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# Get started with Performance Monitoring for Flutter

This quickstart describes how to set up Firebase Performance Monitoring to help
you to gain insight into the performance characteristics of your Flutter apps.


## Before you begin

If you haven't already,
[configure and initialize Firebase](/docs/flutter/setup) in your Flutter
project.

## **Step 1**: Add Performance Monitoring to your app {:#add-perfmon}

1.  From the root directory of your Flutter project, run the following
    command to install the Performance Monitoring Flutter plugin:

    ```sh {: .devsite-terminal .devsite-click-to-copy data-terminal-prefix="your-flutter-proj$ " }
    flutter pub add firebase_performance
    ```

1.  From the root directory of your Flutter project, run the following command:

    ```sh {: .devsite-terminal .devsite-click-to-copy data-terminal-prefix="your-flutter-proj$ " }
    flutterfire configure
    ```

    Running this command ensures that your Flutter app's Firebase configuration
    is up-to-date and, for Android, adds the required Performance Monitoring
    Gradle plugin to your app.

1.  Once complete, rebuild your Flutter project:

    ```sh {: .devsite-terminal .devsite-click-to-copy data-terminal-prefix="your-flutter-proj$ " }
    flutter run
    ```

After you've added the Performance Monitoring SDK, Firebase automatically starts collecting
data related to your app's lifecycle (like
[app start time](/docs/perf-mon/app-start-foreground-background-traces)), and
data for [HTTP/S network requests](/docs/perf-mon/network-traces).

On Flutter, automatic screen rendering performance monitoring is not possible
for individual Flutter screens. A single view controller encapsulates your
entire Flutter application natively so the underlying native Firebase SDK is
not aware of screen transitions.

Note: When you add Performance Monitoring to your app, the Remote Config SDK is
included as a dependency. If you already use Remote Config, you won't see
any difference. However, if you're new to Remote Config, explore the
[Remote Config documentation](/docs/remote-config) to learn more
about the various features you'll be able to access in your app.


## **Step 2**: Generate performance events for initial data display {:#data-in-console}

Firebase starts processing the events when you successfully add the SDK to your
app. If you're still developing locally, interact with your app to generate
events for initial data collection and processing.

Note: The Performance Monitoring SDK batches events locally then sends them to Firebase
periodically (every 30 seconds) or when the app comes back to foreground. So,
there's a delay between an app interaction and when Firebase receives the event
information from your app.

1.  Continue to develop your app using a simulator or test device.

1.  Generate events by switching your app between background and foreground
    several times, interacting with your app by navigating across screens,
    and/or triggering network requests.

1.  Go to the [_Performance_ dashboard](//console.firebase.google.com/project/_/performance)
    of the Firebase console. You should see your initial data display within
    a few minutes.

    If you don't see a display of your initial data, review the [troubleshooting
    tips](/docs/perf-mon/troubleshooting?platform=ios#sdk-detected-no-data).


## **Step 3**: _(Optional)_ View log messages for performance events {:#view-log-messages}

1.  Check your log messages for any error messages.

    Performance Monitoring tags its log messages with the following tags so that
    you can filter your log messages:

    * iOS+: `Firebase/Performance`
    * Android: `FirebasePerformance`

1.  Check for the following types of logs which indicate that Performance Monitoring is
    logging performance events:

      * <code>Logging trace metric: <var>TRACE_NAME</var>, <var>FIREBASE_PERFORMANCE_CONSOLE_URL</var></code>
      * <code>Logging network request trace: <var>URL</var></code>

1. Click on the URL to view your data in the Firebase console. It may take a few
   moments for the data to update in the dashboard.

## **Step 4**: _(Optional)_ Add custom monitoring for specific code {:#add-custom-trace}

To monitor performance data associated with specific code in your app, you can
instrument [**custom code traces**](/docs/perf-mon/custom-code-traces?platform=flutter).

With a custom code trace, you can measure how long it takes your app to complete
a specific task or set of tasks, such as loading a set of images or querying
your database. The default metric for a custom code trace is its duration, but
you can also add custom metrics, such as cache hits and memory warnings.

In your code, you define the beginning and the end of a custom code trace (and
add any desired custom metrics) using the API provided by the Performance Monitoring SDK.

Visit [Add monitoring for specific code](/docs/perf-mon/custom-code-traces?platform=flutter)
to learn more about these features and how to add them to your app.

## **Step 5**: Deploy your app then review results {:#deploy-then-review-results}

After you've validated Performance Monitoring using the an emulator and one or more
test devices, you can deploy the updated version of your app to your users.

You can monitor performance data in the
[_Performance_ dashboard](//console.firebase.google.com/project/_/performance)
of the Firebase console.


## Next steps

* Learn more about data automatically collected by Performance Monitoring:

  * Data related to your app's lifecycle, like
    [app start time](/docs/perf-mon/app-start-foreground-background-traces)
  * Data for [HTTP/S network requests](/docs/perf-mon/network-traces) issued
    by your app

* [View, track, and filter](/docs/perf-mon/console) your
  performance data in the Firebase console.

* Add monitoring for specific tasks or workflows in your app by
  [instrumenting custom code traces](/docs/perf-mon/custom-code-traces?platform=flutter).

* [Use attributes to filter performance data](/docs/perf-mon/attributes).



================================================
File: docs/flutter/reference/_toc.yaml
================================================
toc:
- title: cloud_firestore
  path: https://pub.dev/documentation/cloud_firestore/latest/
  status: external
- title: cloud_firestore_web
  path: https://pub.dev/documentation/cloud_firestore_web/latest/
  status: external
- title: cloud_functions
  path: https://pub.dev/documentation/cloud_functions/latest/
  status: external
- title: cloud_functions_web
  path: https://pub.dev/documentation/cloud_functions_web/latest/
  status: external
- title: firebase_analytics
  path: https://pub.dev/documentation/firebase_analytics/latest/
  status: external
- title: firebase_analytics_web
  path: https://pub.dev/documentation/firebase_analytics_web/latest/
  status: external
- title: firebase_app_check
  path: https://pub.dev/documentation/firebase_app_check/latest/
  status: external
- title: firebase_app_installations
  path: https://pub.dev/documentation/firebase_app_installations/latest/
  status: external
- title: firebase_auth
  path: https://pub.dev/documentation/firebase_auth/latest/
  status: external
- title: firebase_auth_web
  path: https://pub.dev/documentation/firebase_auth_web/latest/
  status: external
- title: firebase_core
  path: https://pub.dev/documentation/firebase_core/latest/
  status: external
- title: firebase_core_web
  path: https://pub.dev/documentation/firebase_core_web/latest/
  status: external
- title: firebase_crashlytics
  path: https://pub.dev/documentation/firebase_crashlytics/latest/
  status: external
- title: firebase_database
  path: https://pub.dev/documentation/firebase_database/latest/
  status: external
- title: firebase_dynamic_links
  path: https://pub.dev/documentation/firebase_dynamic_links/latest/
  status: external
- title: firebase_in_app_messaging
  path: https://pub.dev/documentation/firebase_in_app_messaging/latest/
  status: external
- title: firebase_messaging
  path: https://pub.dev/documentation/firebase_messaging/latest/
  status: external
- title: firebase_messaging_web
  path: https://pub.dev/documentation/firebase_messaging_web/latest/
  status: external
- title: firebase_ml_model_downloader
  path: https://pub.dev/documentation/firebase_ml_model_downloader/latest/
  status: external
- title: firebase_performance
  path: https://pub.dev/documentation/firebase_performance/latest/
  status: external
# - title: firebase_performance_platform_interface
#   path: https://pub.dev/documentation/firebase_performance_platform_interface/latest/
#   status: external
- title: firebase_performance_web
  path: https://pub.dev/documentation/firebase_performance_web/latest/
  status: external
- title: firebase_remote_config
  path: https://pub.dev/documentation/firebase_remote_config/latest/
  status: external
- title: firebase_storage
  path: https://pub.dev/documentation/firebase_storage/latest/
  status: external
- title: firebase_storage_web
  path: https://pub.dev/documentation/firebase_storage_web/latest/
  status: external
- title: flutterfire_ui
  path: https://pub.dev/documentation/flutterfire_ui/latest/
  status: external



================================================
File: docs/flutter/remote-config/_get-started.md
================================================
{# This content gets published to the following location:                        #}
{#   https://firebase.google.com/docs/remote-config/get-started?platform=flutter #}

You can use Firebase Remote Config to define parameters in your app and update
their values in the cloud, allowing you to modify the appearance and behavior of
your app without distributing an app update.
This guide walks you through the steps to get started and provides some
sample code.

## Step 1: Add Firebase and the Remote Config SDK to your app {: #add-firebase }

1.  [Install and initialize the Firebase SDKs for Flutter](/docs/flutter/setup) if you
    haven't already done so.

1.  For Remote Config, Google Analytics is required for the
    [conditional targeting of app instances](/docs/remote-config/parameters#conditions_rules_and_conditional_values)
    to user properties and audiences. Make sure that
    you <a href="https://support.google.com/firebase/answer/9289399#linkga"
           class="external">enable Google Analytics</a> in your project.

1.  From the root directory of your Flutter project, run the following
    command to install the Remote Config plugin:

    ```bash
    flutter pub add firebase_remote_config
    ```

    Also, as part of setting up Remote Config, you need to add the Firebase SDK
    for Google Analytics to your app:

    ```bash
    flutter pub add firebase_analytics
    ```

1.  Rebuild your project:

    ```bash
    flutter run
    ```

1.  If you're using Remote Config on macOS, enable
    [Keychain Sharing](https://developer.apple.com/documentation/xcode/configuring-keychain-sharing)
    in Xcode.

Note: Because the Remote Config SDK has a dependency on the Remote Config REST
API, make sure that you do **not** disable that API, which is enabled by default
in a typical project.

## Step 2: Get the Remote Config singleton object {: #get-remote-config }

Get a Remote Config object instance and set the
minimum fetch interval to allow for frequent refreshes:

```dart
final remoteConfig = FirebaseRemoteConfig.instance;
await remoteConfig.setConfigSettings(RemoteConfigSettings(
    fetchTimeout: const Duration(minutes: 1),
    minimumFetchInterval: const Duration(hours: 1),
));
```

The singleton object is used to store in-app default parameter values, fetch
updated parameter values from the backend, and control when fetched values are
made available to your app.

During development, it's recommended to set a relatively low minimum fetch
interval. See [Throttling](#throttling) for more information.

## Step 3: Set in-app default parameter values {: #default-parameter }

You can set in-app default parameter values in the Remote Config
object, so that your app behaves as intended before it connects to the
Remote Config backend, and so that default values are available if none are
set in the backend.

Important: Don't store confidential data in Remote Config parameter keys or
values. Remote Config data is encrypted in transit, but end users can access
any default or fetched Remote Config parameter that is available to their
client app instance.

```dart
await remoteConfig.setDefaults(const {
    "example_param_1": 42,
    "example_param_2": 3.14159,
    "example_param_3": true,
    "example_param_4": "Hello, world!",
});
```

## Step 4: Get parameter values to use in your app {: #get-parameter }

Now you can get parameter values from the Remote Config object. If you set
values in the backend, fetch them, and then activate them,
those values are available to your app. Otherwise, you get the in-app
parameter values configured using `setDefaults()`.

To get these values, call the method listed below that maps to the data type
expected by your app, providing the parameter key as an argument:

* `getBool()`
* `getDouble()`
* `getInt()`
* `getString()`

## Step 5: Set parameter values in the Remote Config backend {: #set-parameter }

Using the Firebase console or the
[Remote Config backend APIs](/docs/remote-config/automate-rc),
you can create new server-side default values that override the in-app values
according to your desired conditional logic or user targeting. This section
describes the Firebase console steps to create these values.

1. In the [Firebase console](https://console.firebase.google.com/), open your project.
1. Select **Remote Config** from the menu to view the Remote Config
   dashboard.
1. Define parameters with the same names as the parameters that you defined in
   your app. For each parameter, you can set a default value (which will
   eventually override the corresponding in-app default value), and you can also
   set conditional values. To learn more, see [Remote Config Parameters and
   Conditions](/docs/remote-config/parameters).

## Step 6: Fetch and activate values {: #fetch-values }

1. To fetch parameter values from the Remote Config backend, call the
   `fetch()` method. Any values that you set in the backend are fetched
   and stored in the Remote Config object.

1. To make fetched parameter values available to your app, call the
   `activate()` method.

   For cases where you want to fetch and activate values in one call, you
   can use a `fetchAndActivate()` request to fetch values from the
   Remote Config backend and make them available to the app:

   ```dart
   await remoteConfig.fetchAndActivate();
   ```

Because these updated parameter values affect the behavior and appearance
of your app, you should activate the fetched values at a time that ensures a
smooth experience for your user, such as the next time that the user opens your
app. See [Remote Config loading strategies](/docs/remote-config/loading)
for more information and examples.

## Step 7: Listen for updates in real time {: #add-real-time-listener }

After you fetch parameter values, you can use real-time Remote Config to listen
for updates from the Remote Config backend.  Real-time Remote Config signals to
connected devices when updates are available and automatically fetches the
changes after you publish a new Remote Config version.

Note that real-time Remote Config is not available for Web.

1. In your app, use `onConfigUpdated` to start listening for updates and
   automatically fetch any new parameter values.

   ```dart
    remoteConfig.onConfigUpdated.listen((event) async {
      await remoteConfig.activate();

      // Use the new config values here.
    });
   ```

2. The next time you publish a new version of your Remote Config, devices that
   are running your app and listening for changes will activate the new config.

Tip: Check out the
[Flutterfire Remote Config
example](https://github.com/firebase/flutterfire/tree/main/packages/firebase_remote_config/firebase_remote_config/example)
for an example implementation.

## Throttling {: #throttling }

If an app fetches too many times in a short time period, fetch calls will be
throttled and the value of `FirebaseRemoteConfig`'s `lastFetchStatus`
property will be `RemoteConfigFetchStatus.throttle`.

The default minimum fetch interval for Remote Config is 12 hours, which
means that configs won't be fetched from the backend more than once in a 12 hour
window, regardless of how many fetch calls are actually made.

<aside class="tip">
  <b>Tip:</b> Starting with the Firebase SDK for Flutter v4.0.0,
  you can use real-time {{remote_config}} to automatically fetch updated
  parameter values from the {{remote_config}} backend as soon as they're
  published, bypassing any minimum fetch interval setting. For more
  information, see
  <a href="/docs/remote-config/get-started?platform=android#add-real-time-listener">Listen for updates in real time</a>.
</aside>

During app development, if you're not using real-time Remote Config (which we
recommend), you might want to fetch and activate configs very frequently
(many times per hour) to let you rapidly iterate as you develop and test your
app. To accommodate rapid iteration on a project with up to 10 developers, you
can temporarily set a low minimum fetch interval with `setConfigSettings()`.

```dart
final remoteConfig = FirebaseRemoteConfig.instance;
await remoteConfig.setConfigSettings(RemoteConfigSettings(
    fetchTimeout: const Duration(minutes: 1),
    minimumFetchInterval: const Duration(minutes: 5),
));
```

Caution: Keep in mind that this setting should be used for development only, not for an
app running in production. If you're just testing your app with a small
10-person development team, you are unlikely to hit the hourly service-side
quota limits. But if you pushed your app out to thousands of test users with a
very low minimum fetch interval, your app would probably hit this quota.



================================================
File: docs/flutter/setup/_setup_main.md
================================================
{# This content gets published to the following location: #}
{#   https://firebase.google.com/docs/flutter/setup       #}

## **Step 1**: Install the required command line tools {: #install-cli-tools}

1.  If you haven't already,
    [install the {{firebase_cli}}](/docs/cli#setup_update_cli).

1.  Log into Firebase using your Google account by running the following
    command:

    ```sh {: .devsite-terminal .devsite-click-to-copy}
    firebase login
    ```

1.  Install the FlutterFire CLI by running the following command from any
    directory:

    ```sh {: .devsite-terminal .devsite-click-to-copy}
    dart pub global activate flutterfire_cli
    ```


## **Step 2**: Configure your apps to use Firebase {: #configure-firebase}

Use the FlutterFire CLI to configure your Flutter apps to connect to Firebase.

From your Flutter project directory, run the following command to start the
app configuration workflow:

```sh {: .devsite-terminal .devsite-click-to-copy data-terminal-prefix="your-flutter-proj$ " }
flutterfire configure
```

{{ '<section class="expandable">' }}
<p class="showalways">What does this <code>flutterfire configure</code>
  workflow do?
</p>

> The `flutterfire configure` workflow does the following:
>
> * Asks you to select the platforms (iOS, Android, Web) supported in your
>   Flutter app. For each selected platform, the FlutterFire CLI creates a new
>   Firebase app in your Firebase project.
>
>   You can select either to use an existing Firebase project or to create a
>   new Firebase project. If you already have apps registered in an existing
>   Firebase project, the FlutterFire CLI will attempt to match them based on
>   your current Flutter project configuration.
>
>   <aside class="note"><b>Note:</b> Here are some tips about setting up and
>     managing your Firebase project:
>
>     <ul>
>       <li>Check out our
>         <a href="/docs/projects/dev-workflows/general-best-practices">best practices</a>
>         for adding apps to a Firebase project, including how to handle
>         multiple variants.
>       </li>
>       <li><a href="https://support.google.com/firebase/answer/9289399#linkga" class="external">
>         Enable {{firebase_analytics}}</a>
>         in your project, which enables you to have an optimal experience using
>         many Firebase products, like {{crashlytics}} and {{remote_config}}.
>       </li>
>     </ul>
>   </aside>
>
> * Creates a Firebase configuration file (`firebase_options.dart`) and adds it
>   to your `lib/` directory.
>
>   Note: This Firebase config file contains unique, but non-secret
>   identifiers for each platform you selected. <br>Visit [Understand
>   Firebase Projects](/docs/projects/learn-more#config-files-objects) to
>   learn more about this config file.
>
> * _(for {{crashlytics}} or {{perfmon}} on Android)_ Adds the required
>   product-specific Gradle plugins to your Flutter app.
>
>   Note: For the FlutterFire CLI to add the appropriate Gradle plugin, the
>   product's Flutter plugin must already be imported into your Flutter app.

{{ '</section>' }}

<br>

<aside class="caution">After this initial running of
  <code>flutterfire configure</code>, you need to re-run the command any time
  that you:

  <ul>
    <li>Start supporting a new platform in your Flutter app.
    </li>
    <li>Start using a new Firebase service or product in your Flutter app,
      especially if you start using sign-in with Google, {{crashlytics}},
      {{perfmon}}, or {{database}}.
    </li>
  </ul>

  <p>Re-running the command ensures that your Flutter app's Firebase
    configuration is up-to-date and (for Android) automatically adds any
    required Gradle plugins to your app.
</aside>


## **Step 3**: Initialize Firebase in your app {: #initialize-firebase}

1.  From your Flutter project directory, run the following command to install
    the core plugin:

    ```sh {: .devsite-terminal .devsite-click-to-copy data-terminal-prefix="your-flutter-proj$ " }
    flutter pub add firebase_core
    ```

1.  From your Flutter project directory, run the following command to ensure
    that your Flutter app's Firebase configuration is up-to-date:

    ```sh {: .devsite-terminal .devsite-click-to-copy data-terminal-prefix="your-flutter-proj$ " }
    flutterfire configure
    ```

1.  In your `lib/main.dart` file, import the Firebase core plugin and the
    configuration file you generated earlier:

    ```dart
    import 'package:firebase_core/firebase_core.dart';
    import 'firebase_options.dart';
    ```

1.  Also in your `lib/main.dart` file, initialize Firebase using the
    `DefaultFirebaseOptions` object exported by the configuration file:

    ```dart
    await Firebase.initializeApp(
      options: DefaultFirebaseOptions.currentPlatform,
    );
    ```

1.  Rebuild your Flutter application:

    ```sh {: .devsite-terminal .devsite-click-to-copy data-terminal-prefix="your-flutter-proj$ " }
    flutter run
    ```

If you would rather use a demo project, you can start the [Firebase Emulator](https://firebase.google.com/docs/emulator-suite) and
in your `lib/main.dart` file initialize Firebase using `demoProjectId` (it should start with `demo-`):

  ```dart
  await Firebase.initializeApp(
    demoProjectId: "demo-project-id",
  );
  ```



## **Step 4**: Add Firebase plugins {: #add-plugins}

You access Firebase in your Flutter app through the various
[Firebase Flutter plugins](#available-plugins), one for each Firebase product
(for example: {{firestore}}, {{auth}}, {{analytics}}, etc.).

Since Flutter is a multi-platform framework, each Firebase plugin is applicable
for Apple, Android, and web platforms. So, if you add any Firebase plugin to
your Flutter app, it will be used by the Apple, Android, and web versions of
your app.

Here's how to add a Firebase Flutter plugin:

1.  From your Flutter project directory, run the following command:

    <pre class="devsite-terminal devsite-click-to-copy" data-terminal-prefix="your-flutter-proj$ ">flutter pub add <var>PLUGIN_NAME</var></pre>

1.  From your Flutter project directory, run the following command:

    ```sh {: .devsite-terminal .devsite-click-to-copy data-terminal-prefix="your-flutter-proj$ " }
    flutterfire configure
    ```

    Running this command ensures that your Flutter app's Firebase configuration
    is up-to-date and, for {{crashlytics}} and {{perfmon}} on Android, adds the
    required Gradle plugins to your app.

1.  Once complete, rebuild your Flutter project:

    ```sh {: .devsite-terminal .devsite-click-to-copy data-terminal-prefix="your-flutter-proj$ " }
    flutter run
    ```

You're all set! Your Flutter apps are registered and configured to use Firebase.


### Available plugins {: #available-plugins}

{% setvar YES %}<div class="center compare-yes"></div>{% endsetvar %}

Product                                          | Plugin name                    | iOS     | Android | Web     | Other Apple<br>(macOS, etc.) | Windows
-------------------------------------------------|--------------------------------|---------|---------|---------|--------------------------|--------
[{{analytics}}][analytics docs]                  | `firebase_analytics`           | {{YES}} | {{YES}} | {{YES}} | beta |
[{{app_check}}][app check docs]                  | `firebase_app_check`           | {{YES}} | {{YES}} | {{YES}} | beta |
[{{auth}}][auth docs]                            | `firebase_auth`                | {{YES}} | {{YES}} | {{YES}} | beta | beta
[{{firestore}}][firestore docs]                  | `cloud_firestore`              | {{YES}} | {{YES}} | {{YES}} | beta | beta
[{{cloud_functions}}][functions docs]            | `cloud_functions`              | {{YES}} | {{YES}} | {{YES}} | beta |
[{{messaging_longer}}][fcm docs]                 | `firebase_messaging`           | {{YES}} | {{YES}} | {{YES}} | beta |
[{{storage}}][storage docs]                      | `firebase_storage`             | {{YES}} | {{YES}} | {{YES}} | beta | beta
[{{crashlytics}}][crashlytics docs]              | `firebase_crashlytics`         | {{YES}} | {{YES}} |         | beta |
[{{ddls}}][ddls docs]                            | `firebase_dynamic_links`       | {{YES}} | {{YES}} |         | |
[{{inappmessaging}}][fiam docs]                  | `firebase_in_app_messaging`    | {{YES}} | {{YES}} |         | |
[{{firebase_installations}}][installations docs] | `firebase_app_installations`   | {{YES}} | {{YES}} | {{YES}} | beta |
[ML Model Downloader][ml docs]                   | `firebase_ml_model_downloader` | {{YES}} | {{YES}} |         | beta |
[{{perfmon}}][perfmon docs]                      | `firebase_performance`         | {{YES}} | {{YES}} | {{YES}} | |
[{{database}}][rtdb docs]                        | `firebase_database`            | {{YES}} | {{YES}} | {{YES}} | beta |
[{{remote_config}}][remote config docs]          | `firebase_remote_config`       | {{YES}} | {{YES}} | {{YES}} | beta |

Caution: Firebase on Windows is not intended for production use cases, only local development workflows.

## Try out an example app with {{analytics}} {: #try-analytics-example-app}

Like all packages, the `firebase_analytics` plugin comes with an
[example program](//github.com/firebase/flutterfire/tree/main/packages/firebase_analytics/firebase_analytics/example){: .external}.

1.  Open a Flutter app that you've already configured to use Firebase (see
    instructions on this page).

1.  Access the `lib` directory of the app, then delete the existing `main.dart`
    file.

1.  From the {{firebase_analytics}}
    [example program repository](//github.com/firebase/flutterfire/tree/main/packages/firebase_analytics/firebase_analytics/example/lib){: .external},
    copy-paste the following two files into your app's `lib` directory:

      * `main.dart`
      * `tabs_page.dart`

1.  Run your Flutter app.

1.  Go to your app's Firebase project in the {{appmanager_link}}, then click
    **Analytics** in the left-nav.

    1.  Click
        [**Dashboard**](//support.google.com/firebase/answer/6317517).
        If {{analytics}} is working properly, the dashboard shows an active user
        in the "Users active in the last 30&nbsp;minutes" panel (this might take
        time to populate this panel).

    1.  Click [**DebugView**](/docs/analytics/debugview). Enable the feature to
        see all the events generated by the example program.

For more information about setting up {{analytics}}, visit the getting started
guides for [iOS+](/docs/analytics/get-started?platform=ios),
[Android](/docs/analytics/get-started?platform=android), and
[web](/docs/analytics/get-started?platform=web).


{% dynamic if request.query_string.platform == "web" %}
## Notes on building web apps {:#web-notes}

### Trusted Types support {:#trusted-types}

The Firebase SDK for Flutter supports using Trusted Types to help prevent
DOM-based (client-side) XSS attacks. When you
[enable Trusted Type enforcement](https://web.dev/trusted-types/#switch-to-enforcing-content-security-policy){:.external}
for your app, the Firebase SDK injects its scripts into the DOM using custom
Trusted Type policies, named `flutterfire-firebase_core`,
`flutterfire-firebase_auth`, and so on.

### Disable Firebase JavaScript SDK auto-injection {:#disable-auto}

By default, the Firebase Flutter SDK auto-injects the Firebase JavaScript SDK when building for the web. If you don't want the Firebase JavaScript SDK to be auto-injected, you can do the following:

1.  Ignore the auto-injection script by adding the following property inside a
    `<script>` tag within the `web/index.html` file in your Flutter project:

    ```html
    <!-- Add this property inside a <script> tag within your "web/index.html" file in your Flutter project -->
    <!-- Put in the names of all the plugins you wish to ignore: -->
    window.flutterfire_ignore_scripts = ['analytics', 'firestore'];
    ```

2.  Load the script manually using one of the following alternatives:

    - Add the SDK explicitly to your `web/index.html` file, inside the `window.addEventListener` callback:

      ```js
        window.addEventListener('load', async function (ev) {
          window.firebase_firestore = await import("https://www.gstatic.com/firebasejs/{{web_sdk_version}}/firebase-firestore.js");
          window.firebase_analytics = await import("https://www.gstatic.com/firebasejs/{{web_sdk_version}}/firebase-analytics.js");
          
          _flutter.loader.loadEntrypoint().then(function (engineInitializer) {
            // rest of the code
      ```

    - Or, download the plugin's Firebase JavaScript SDK code from the "gstatic" domain,
      and save them to a JavaScript file to be kept within your project and loaded in manually:

      ```js
        // "web/my-analytics.js" & "web/my-firestore.js" file loaded as a script into your "web/index.html" file: 
        window.addEventListener('load', async function (ev) {
          window.firebase_analytics = await import("./my-analytics.js");
          window.firebase_firestore = await import("./my-firestore.js");
          
          _flutter.loader.loadEntrypoint().then(function (engineInitializer) {
            // rest of the code
      ```

{% dynamic endif %}


## Next steps

* Get hands-on experience with the
  [Firebase Flutter Codelab](/codelabs/firebase-get-to-know-flutter).

* Prepare to launch your app:
<<../../../_internal/includes/docs/guides/_prepare-to-launch-app.md>>

{# The above line includes a Google-internal file, which isn't on GitHub. #}

[analytics docs]: /docs/analytics/get-started?platform=flutter
[app check docs]: /docs/app-check/flutter/default-providers
[auth docs]: /docs/auth/flutter/start
[firestore docs]: /docs/firestore/quickstart
[functions docs]: /docs/functions/get-started
[fcm docs]: /docs/cloud-messaging/flutter/client
[storage docs]: /docs/storage/flutter/start
[crashlytics docs]: /docs/crashlytics/get-started?platform=flutter
[ddls docs]: /docs/dynamic-links/flutter/create
[fiam docs]: /docs/in-app-messaging/get-started?platform=flutter
[installations docs]: /docs/projects/manage-installations
[ml docs]: /docs/ml/flutter/use-custom-models
[perfmon docs]: /docs/perf-mon/flutter/get-started
[rtdb docs]: /docs/database/flutter/start
[remote config docs]: /docs/remote-config/get-started?platform=flutter



================================================
File: docs/flutter/setup/_setup_prereq_android.md
================================================
{# This content gets published to the following location: #}
{#   https://firebase.google.com/docs/flutter/setup       #}

* Install your preferred [editor or IDE](//docs.flutter.dev/get-started/editor/).

* Set up a device or emulator for running your app.
  [Emulators](https://developer.android.com/studio/run/managing-avds){: .external}
  must use an emulator image with Google Play.

* Make sure that your app meets the following requirements:

    * Targets API level {{android_min_api_level}} ({{android_min_api_codename}})
      or higher
    * Uses Android {{android_min_version}} or higher

* [Install Flutter](//docs.flutter.dev/get-started/install/) for your specific
  operating system, including the following:

    * Flutter SDK
    * Supporting libraries
    * Platform-specific software and SDKs

* [Sign into Firebase]({{name_appmanagerURL}}){: .external} using your Google
  account.

If you don't already have a Flutter app, you can complete the [Get
Started: Test Drive](//docs.flutter.dev/get-started/test-drive#androidstudio) to
create a new Flutter app using your preferred editor or IDE.



================================================
File: docs/flutter/setup/_setup_prereq_ios.md
================================================
{# This content gets published to the following location: #}
{#   https://firebase.google.com/docs/flutter/setup       #}

* Install your preferred [editor or IDE](//docs.flutter.dev/get-started/editor/).

* Set up a physical Apple device or use a simulator to run your app.

{# Google-internal file; not on GitHub. #}
<<../../../_internal/includes/docs/guides/_setup-ios_prereq_want-to-use-fcm.md>>

* Make sure that your Flutter app targets the following platform versions or
  later:
  * iOS {{min_ios_os_version}}
  * macOS {{min_mac_os_version}}

* [Install Flutter](//docs.flutter.dev/get-started/install/) for your specific
  operating system, including the following:

    * Flutter SDK
    * Supporting libraries
    * Platform-specific software and SDKs

* [Sign into Firebase]({{name_appmanagerURL}}){: .external} using your Google
  account.

If you don't already have a Flutter app, you can complete the [Get
Started: Test Drive](//docs.flutter.dev/get-started/test-drive/#androidstudio) to
create a new Flutter app using your preferred editor or IDE.

Note: If you're targeting macOS or macOS Catalyst, you must add the [Keychain Sharing capability](https://firebase.google.com/docs/ios/troubleshooting-faq#macos-keychain-sharing) to your target. In Xcode, navigate to your target's *Signing & Capabilities* tab, and then click **+ Capabilities** to add a new capability.



================================================
File: docs/flutter/setup/_setup_prereq_web.md
================================================
{# This content gets published to the following location: #}
{#   https://firebase.google.com/docs/flutter/setup       #}

* Install your preferred [editor or IDE](//docs.flutter.dev/get-started/editor/).

* [Install Flutter](//docs.flutter.dev/get-started/install/) for your specific
  operating system, including the following:

    * Flutter SDK
    * Supporting libraries
    * Platform-specific software and SDKs

* [Sign into Firebase]({{name_appmanagerURL}}){: .external} using your Google
  account.

If you don't already have a Flutter app, you can complete the [Get
Started: Test Drive](//docs.flutter.dev/get-started/test-drive?tab=vscode) to
create a new Flutter app using your preferred editor or IDE.



================================================
File: docs/flutter/storage/create-reference.md
================================================
Project: /docs/storage/_project.yaml
Book: /docs/_book.yaml
page_type: guide

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# Create a Cloud Storage reference on Flutter

Your files are stored in a
[Cloud Storage](//cloud.google.com/storage) bucket. The
files in this bucket are presented in a hierarchical structure, just like the
file system on your local hard disk, or the data in the Firebase Realtime Database.
By creating a reference to a file, your app gains access to it. These references
can then be used to upload or download data, get or update metadata or delete
the file. A reference can either point to a specific file or to a higher level
node in the hierarchy.

If you've used the [Firebase Realtime Database](/docs/database), these paths should
seem very familiar to you. However, your file data is stored in
Cloud Storage, **not** in the Realtime Database.


## Create a Reference

Create a reference to upload, download, or delete a file,
or to get or update its metadata. A reference
can be thought of as a pointer to a file in the cloud. References are
lightweight, so you can create as many as you need. They are also reusable for
multiple operations.

Create a reference using the `FirebaseStorage` singleton instance and
calling its `ref()` method.

```dart
final storageRef = FirebaseStorage.instance.ref();
```

Next, you can create a reference to a location lower in the tree,
say `"images/space.jpg"` by using the `child()` method on an existing reference.

```dart
// Create a child reference
// imagesRef now points to "images"
final imagesRef = storageRef.child("images");

// Child references can also take paths
// spaceRef now points to "images/space.jpg
// imagesRef still points to "images"
final spaceRef = storageRef.child("images/space.jpg");
```

## Navigate with References

You can also use the `parent` and `root` properties to navigate up in our
file hierarchy. `parent` navigates up one level,
while `root` navigates all the way to the top.

```dart
// parent allows us to move our reference to a parent node
// imagesRef2 now points to 'images'
final imagesRef2 = spaceRef.parent;

// root allows us to move all the way back to the top of our bucket
// rootRef now points to the root
final rootRef = spaceRef.root;
```

`child()`, `parent`, and `root` can be chained together multiple
times, as each is a reference. But accessing `root.parent` results in `null`.

```dart
// References can be chained together multiple times
// earthRef points to 'images/earth.jpg'
final earthRef = spaceRef.parent?.child("earth.jpg");

// nullRef is null, since the parent of root is null
final nullRef = spaceRef.root.parent;
```


## Reference Properties

You can inspect references to better understand the files they point to
using the `fullPath`, `name`, and `bucket` properties. These properties
get the file's full path, name and bucket.

```dart
// Reference's path is: "images/space.jpg"
// This is analogous to a file path on disk
spaceRef.fullPath;

// Reference's name is the last segment of the full path: "space.jpg"
// This is analogous to the file name
spaceRef.name;

// Reference's bucket is the name of the storage bucket that the files are stored in
spaceRef.bucket;
```

## Limitations on References

Reference paths and names can contain any sequence of valid Unicode characters,
but certain restrictions are imposed including:

1. Total length of reference.fullPath must be between 1 and 1024 bytes when UTF-8 encoded.
1. No Carriage Return or Line Feed characters.
1. Avoid using `#`, `[`, `]`, `*`, or `?`, as these do not work well with
   other tools such as the [Firebase Realtime Database](/docs/database/overview)
   or [gsutil](https://cloud.google.com/storage/docs/gsutil).

## Full Example

```dart
// Points to the root reference
final storageRef = FirebaseStorage.instance.ref();

// Points to "images"
Reference? imagesRef = storageRef.child("images");

// Points to "images/space.jpg"
// Note that you can use variables to create child values
final fileName = "space.jpg";
final spaceRef = imagesRef.child(fileName);

// File path is "images/space.jpg"
final path = spaceRef.fullPath;

// File name is "space.jpg"
final name = spaceRef.name;

// Points to "images"
imagesRef = spaceRef.parent;
```

Next, let's learn how to [upload files](upload-files) to Cloud Storage.



================================================
File: docs/flutter/storage/delete-files.md
================================================
Project: /docs/storage/_project.yaml
Book: /docs/_book.yaml
page_type: guide

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# Delete files with Cloud Storage on Flutter

After uploading files to Cloud Storage, you can also delete them.

Note: By default, a Cloud Storage bucket requires Firebase Authentication to
perform any action on the bucket's data or files. You can
[change your Firebase Security Rules for Cloud Storage](/docs/storage/security/rules-conditions#public)
to allow unauthenticated access. Since Firebase and your project's default
App Engine app share this bucket, configuring public access may make newly
uploaded App Engine files publicly accessible, as well. Be sure to restrict
access to your Cloud Storage bucket again when you set up Authentication.


## Delete a File

To delete a file, first [create a reference](create-reference)
to that file. Then call the `delete()` method on that reference.

```dart
// Create a reference to the file to delete
final desertRef = storageRef.child("images/desert.jpg");

// Delete the file
await desertRef.delete();
```

Warning: Deleting a file is a permanent action! If you care about restoring
deleted files, make sure to back up your files, or
[enable Object Versioning](https://cloud.google.com/storage/docs/using-object-versioning#set)
on your Cloud Storage bucket.


## Handle Errors

There are a number of reasons why errors may occur on file deletes,
including the file not existing, or the user not having permission
to delete the desired file. More information on errors can be found in the
[Handle Errors](handle-errors) section of the docs.



================================================
File: docs/flutter/storage/download-files.md
================================================
Project: /docs/storage/_project.yaml
Book: /docs/_book.yaml
page_type: guide

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# Download files with Cloud Storage on Flutter

Cloud Storage for Firebase allows you to quickly and easily download
files from a [Cloud Storage](//cloud.google.com/storage)
bucket provided and managed by Firebase.

Note: By default, a Cloud Storage bucket requires Firebase Authentication to
perform any action on the bucket's data or files. You can
[change your Firebase Security Rules for Cloud Storage](/docs/storage/security/rules-conditions#public)
to allow unauthenticated access. Since Firebase and your project's default
App Engine app share this bucket, configuring public access may make newly
uploaded App Engine files publicly accessible, as well. Be sure to restrict
access to your Cloud Storage bucket again when you set up Authentication.



## Create a Reference

To download a file, first [create a Cloud Storage reference](create-reference)
to the file you want to download.

You can create a reference by appending child paths to the root of your
Cloud Storage bucket, or you can create a reference from an existing
`gs://` or `https://` URL referencing an object in Cloud Storage.

```dart
// Create a storage reference from our app
final storageRef = FirebaseStorage.instance.ref();

// Create a reference with an initial file path and name
final pathReference = storageRef.child("images/stars.jpg");

// Create a reference to a file from a Google Cloud Storage URI
final gsReference =
    FirebaseStorage.instance.refFromURL("gs://YOUR_BUCKET/images/stars.jpg");

// Create a reference from an HTTPS URL
// Note that in the URL, characters are URL escaped!
final httpsReference = FirebaseStorage.instance.refFromURL(
    "https://firebasestorage.googleapis.com/b/YOUR_BUCKET/o/images%20stars.jpg");
```


## Download Files

Once you have a reference, you can download files from Cloud Storage
by calling the `getData()` or `getStream()`. If you prefer to download the file
with another library, you can get a download URL with `getDownloadUrl()`.

### Download in memory

Download the file to a `UInt8List` with the `getData()` method. This is the
easiest way to download a file, but it must load the entire contents of
your file into memory. If you request a file larger than your app's available
memory, your app will crash. To protect against memory issues, `getData()`
takes a maximum amount of bytes to download. Set the maximum size to something
you know your app can handle, or use another download method.

```dart
final islandRef = storageRef.child("images/island.jpg");

try {
  const oneMegabyte = 1024 * 1024;
  final Uint8List? data = await islandRef.getData(oneMegabyte);
  // Data for "images/island.jpg" is returned, use this as needed.
} on FirebaseException catch (e) {
  // Handle any errors.
}
```

### Download to a local file

The `writeToFile()` method downloads a file directly to a local device. Use this if
your users want to have access to the file while offline or to share the file in a
different app. `writeToFile()` returns a `DownloadTask` which you can use to manage
your download and monitor the status of the download.

```dart
final islandRef = storageRef.child("images/island.jpg");

final appDocDir = await getApplicationDocumentsDirectory();
final filePath = "${appDocDir.absolute}/images/island.jpg";
final file = File(filePath);

final downloadTask = islandRef.writeToFile(file);
downloadTask.snapshotEvents.listen((taskSnapshot) {
  switch (taskSnapshot.state) {
    case TaskState.running:
      // TODO: Handle this case.
      break;
    case TaskState.paused:
      // TODO: Handle this case.
      break;
    case TaskState.success:
      // TODO: Handle this case.
      break;
    case TaskState.canceled:
      // TODO: Handle this case.
      break;
    case TaskState.error:
      // TODO: Handle this case.
      break;
  }
});
```

## Download Data via URL

If you already have download infrastructure based around URLs, or just want
a URL to share, you can get the download URL for a file by calling the
`getDownloadURL()` method on a Cloud Storage reference.

```dart
final imageUrl =
    await storageRef.child("users/me/profile.png").getDownloadURL();
```

## Handle Errors

There are a number of reasons why errors may occur on download, including the
file not existing, or the user not having permission to access the desired file.
More information on errors can be found in the [Handle Errors](handle-errors)
section of the docs.

## Full Example

A full example of a download with error handling is shown below:

```dart
final islandRef = storageRef.child("images/island.jpg");

final appDocDir = await getApplicationDocumentsDirectory();
final filePath = "${appDocDir.absolute}/images/island.jpg";
final file = File(filePath);

final downloadTask = islandRef.writeToFile(file);
downloadTask.snapshotEvents.listen((taskSnapshot) {
  switch (taskSnapshot.state) {
    case TaskState.running:
      // TODO: Handle this case.
      break;
    case TaskState.paused:
      // TODO: Handle this case.
      break;
    case TaskState.success:
      // TODO: Handle this case.
      break;
    case TaskState.canceled:
      // TODO: Handle this case.
      break;
    case TaskState.error:
      // TODO: Handle this case.
      break;
  }
});
```

You can also [get and update metadata](file-metadata) for files that are stored
in Cloud Storage.



================================================
File: docs/flutter/storage/file-metadata.md
================================================
Project: /docs/storage/_project.yaml
Book: /docs/_book.yaml
page_type: guide

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# Use file metadata with Cloud Storage on Flutter

After uploading a file to Cloud Storage reference, you can also get
and update the file metadata, for example to view or update the content type.
Files can also store custom key/value pairs with additional file metadata.

Note: By default, a Cloud Storage bucket requires Firebase Authentication to
perform any action on the bucket's data or files. You can
[change your Firebase Security Rules for Cloud Storage](/docs/storage/security/rules-conditions#public)
to allow unauthenticated access. Since Firebase and your project's default
App Engine app share this bucket, configuring public access may make newly
uploaded App Engine files publicly accessible, as well. Be sure to restrict
access to your Cloud Storage bucket again when you set up Authentication.



## Get File Metadata

File metadata contains common properties such as `name`, `size`, and
`contentType` (often referred to as MIME type) in addition to some less
common ones like `contentDisposition` and `timeCreated`. This metadata can be
retrieved from a Cloud Storage reference using
the `getMetadata()` method.

```dart
// Create reference to the file whose metadata we want to retrieve
final forestRef = storageRef.child("images/forest.jpg");

// Get metadata properties
final metadata = await forestRef.getMetadata();

// Metadata now contains the metadata for 'images/forest.jpg'
```


## Update File Metadata

You can update file metadata at any time after the file upload completes by
using the `updateMetadata()` method. Refer to the
[full list](#file-metadata-properties) for more information on what properties
can be updated. Only the properties specified in the metadata are updated,
all others are left unmodified.

```dart
// Create reference to the file whose metadata we want to change
final forestRef = storageRef.child("images/forest.jpg");

// Create file metadata to update
final newMetadata = SettableMetadata(
  cacheControl: "public,max-age=300",
  contentType: "image/jpeg",
);

// Update metadata properties
final metadata = await forestRef.updateMetadata(newMetadata);

// Updated metadata for 'images/forest.jpg' is returned
```

You can delete writable metadata properties by passing `null`:

```dart
// Delete the cacheControl property
final newMetadata = SettableMetadata(cacheControl: null);
final metadata = await forestRef.updateMetadata(newMetadata);
```


## Handle Errors

There are a number of reasons why errors may occur on getting or updating
metadata, including the file not existing, or the user not having permission
to access the desired file. More information on errors can be found in the
[Handle Errors](handle-errors) section of the docs.

## Custom Metadata

You can specify custom metadata using the `customMetadata` parameter of the
`SettableMetadata` constructor:

```dart
// Create reference to the file whose metadata we want to change
final forestRef = storageRef.child("images/forest.jpg");

// Create file metadata to update
final newCustomMetadata = SettableMetadata(
  customMetadata: {
    "location": "Yosemite, CA, USA",
    "activity": "Hiking",
  },
);

// Update metadata properties
final metadata = await forestRef.updateMetadata(newCustomMetadata);

// Updated metadata for 'images/forest.jpg' is returned
```

You can store app-specific data for each file in custom metadata, but we highly
recommend using a database (such as the
[Firebase Realtime Database](/docs/database/overview)) to store and synchronize this type of
data.


## File Metadata Properties {:#file-metadata-properties}

A full list of metadata properties on a file is available below:

Property             | Type                  | Settable?
---------------------|-----------------------|----------
`bucket`             | `String`              | No
`generation`         | `String`              | No
`metageneration`     | `String`              | No
`metadataGeneration` | `String`              | No
`fullPath`           | `String`              | No
`name`               | `String`              | No
`size`               | `int`                 | No
`timeCreated`        | `DateTime`            | No
`updated`            | `DateTime`            | No
`md5Hash`            | `String`              | No
`cacheControl`       | `String`              | Yes
`contentDisposition` | `String`              | Yes
`contentEncoding`    | `String`              | Yes
`contentLanguage`    | `String`              | Yes
`contentType`        | `String`              | Yes
`customMetadata`     | `Map<String, String>` | Yes

Uploading, downloading, and updating files is important, but so is being able
to remove them. Let's learn how to [delete files](delete-files)
from Cloud Storage.



================================================
File: docs/flutter/storage/handle-errors.md
================================================
Project: /docs/storage/_project.yaml
Book: /docs/_book.yaml
page_type: guide

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# Handle errors for Cloud Storage on Flutter

Sometimes when you're building an app, things don't go as planned and an
error occurs!

When in doubt, catch the exception thrown by the function
and see what the error message has to say.

```dart
final storageRef = FirebaseStorage.instance.ref().child("files/uid");
try {
  final listResult = await storageRef.listAll();
} on FirebaseException catch (e) {
  // Caught an exception from Firebase.
  print("Failed with error '${e.code}': ${e.message}");
}
```

Note: By default, a Cloud Storage bucket requires Firebase Authentication to
perform any action on the bucket's data or files. You can
[change your Firebase Security Rules for Cloud Storage](/docs/storage/security/rules-conditions#public)
to allow unauthenticated access. Since Firebase and your project's default
App Engine app share this bucket, configuring public access may make newly
uploaded App Engine files publicly accessible, as well. Be sure to restrict
access to your Cloud Storage bucket again when you set up Authentication.


## Handle Error Messages

There are a number of reasons why errors may occur, including the file
not existing, the user not having permission to access the desired file, or the
user cancelling the file upload.

To properly diagnose the issue and handle the error, here is a full list of
all the errors our client will raise, and how they occurred.

Code                             | Description
---------------------------------|--------------------------------------------
`storage/unknown`                | An unknown error occurred.
`storage/object-not-found`       | No object exists at the desired reference.
`storage/bucket-not-found`       | No bucket is configured for Cloud Storage
`storage/project-not-found`      | No project is configured for Cloud Storage
`storage/quota-exceeded`         | Quota on your Cloud Storage bucket has been exceeded. If you're on the no-cost tier, upgrade to a paid plan. If you're on a paid plan, reach out to Firebase support.
`storage/unauthenticated`        | User is unauthenticated, please authenticate and try again.
`storage/unauthorized`           | User is not authorized to perform the desired action, check your security rules to ensure they are correct.
`storage/retry-limit-exceeded`   | The maximum time limit on an operation (upload, download, delete, etc.) has been excceded. Try uploading again.
`storage/invalid-checksum`       | File on the client does not match the checksum of the file received by the server. Try uploading again.
`storage/canceled`               | User canceled the operation.
`storage/invalid-event-name`     | Invalid event name provided. Must be one of [`running`, `progress`, `pause`]
`storage/invalid-url`            | Invalid URL provided to `refFromURL()`. Must be of the form: `gs://bucket/object` or `https://firebasestorage.googleapis.com/v0/b/bucket/o/object?token=<TOKEN>`
`storage/invalid-argument`       | The argument passed to `put()` must be `File`, `Blob`, or `UInt8` Array. The argument passed to `putString()` must be a raw, `Base64`, or `Base64URL` string.
`storage/no-default-bucket`      | No bucket has been set in your config's `storageBucket` property.
`storage/cannot-slice-blob`      | Commonly occurs when the local file has changed (deleted, saved again, etc.). Try uploading again after verifying that the file hasn't changed.
`storage/server-file-wrong-size` | File on the client does not match the size of the file received by the server. Try uploading again.



================================================
File: docs/flutter/storage/list-files.md
================================================
Project: /docs/storage/_project.yaml
Book: /docs/_book.yaml
page_type: guide

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# List files with Cloud Storage on Flutter

Cloud Storage for Firebase allows you to list the contents of your
Cloud Storage bucket. The SDKs return both the items and the prefixes of
objects under the current Cloud Storage reference.

Projects that use the List API require Cloud Storage for Firebase
Rules version 2. If you have an existing Firebase project, follow the steps in
the [Security Rules Guide](/docs/storage/security/core-syntax).

Note: The List API is only allowed for Rules version 2.
In Rules version 2, `allow read` is the shorthand for `allow get, list`.


`list()` uses the
[Google Cloud Storage List API](//cloud.google.com/storage/docs/json_api/v1/objects/list).
In Cloud Storage for Firebase, we use `/` as a delimiter, which allows us to
emulate file system semantics. To allow for efficient traversal of large,
hierarchical Cloud Storage buckets, the List API returns prefixes and
items separately. For example, if you upload one file `/images/uid/file1`,

* `root.child('images').listAll()` will return `/images/uid` as a prefix.
* `root.child('images/uid').listAll()` will return the file as an item.

The Cloud Storage for Firebase SDK does not return object paths that contain two
consecutive `/`s or end with a `/`. For example, consider a bucket that has the
following objects:

* `correctPrefix/happyItem`
* `wrongPrefix//sadItem`
* `lonelyItem/`

The list operations on items in this bucket will give the following results:

* The list operation at the root returns the references to `correctPrefix`,
  `wrongPrefix` and `lonelyItem` as `prefixes`.
* The list operation at the `correctPrefix/` returns the references to
  `correctPrefix/happyItem` as `items`.
* The list operation at the `wrongPrefix/` doesn't return any references
  because `wrongPrefix//sadItem` contains two consecutive `/`s.
* The list operation at the `lonelyItem/` doesn't return any references
  because the object `lonelyItem/` ends with `/`.

## List all files

You can use `listAll` to fetch all results for a directory.
This is best used for small directories as all results are buffered in memory.
The operation also may not return a consistent snapshot if objects are added or
removed during the process.

For a large list, use the paginated `list()` method as `listAll()` buffers all
results in memory.

The following example demonstrates `listAll`.

```dart
final storageRef = FirebaseStorage.instance.ref().child("files/uid");
final listResult = await storageRef.listAll();
for (var prefix in listResult.prefixes) {
  // The prefixes under storageRef.
  // You can call listAll() recursively on them.
}
for (var item in listResult.items) {
  // The items under storageRef.
}
```

## Paginate list results

The `list()` API places a limit on the number of results it returns. `list()`
provides a consistent pageview and exposes a pageToken that allows control over
when to fetch additional results.

The pageToken encodes the path and version of the last item returned in the
previous result. In a subsequent request using the pageToken, items that come
after the pageToken are shown.

The following example demonstrates paginating a result:

```dart
Stream<ListResult> listAllPaginated(Reference storageRef) async* {
  String? pageToken;
  do {
    final listResult = await storageRef.list(ListOptions(
      maxResults: 100,
      pageToken: pageToken,
    ));
    yield listResult;
    pageToken = listResult.nextPageToken;
  } while (pageToken != null);
}
```

## Handle errors

`list()` and `listAll()` fail if you haven't upgraded
the Security Rules to version 2. Upgrade your Security Rules if you see this
error:

```
Listing objects in a bucket is disallowed for rules_version = "1".
Please update storage security rules to rules_version = "2" to use list.
```

Other possible errors may indicate the user does not have the right permission.
More information on errors can be found in the [Handle Errors](handle-errors)
page.



================================================
File: docs/flutter/storage/start.md
================================================
Project: /docs/storage/_project.yaml
Book: /docs/_book.yaml
page_type: guide

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# Get started with Cloud Storage on Flutter

Cloud Storage for Firebase lets you upload and share user generated content, such
as images and video, which allows you to build rich media content into your
apps. Your data is stored in a
[Google Cloud Storage](//cloud.google.com/storage) bucket — an
exabyte scale object storage solution with high availability and global
redundancy. Cloud Storage for Firebase lets you securely upload these files
directly from mobile devices and web browsers, handling spotty networks with
ease.


## Prerequisites

[Install and initialize the Firebase SDKs for Flutter](/docs/flutter/setup) if you
haven't already done so.


## Create a default Cloud Storage bucket {:#create-default-bucket}

1.  From the navigation pane of the [Firebase console](https://console.firebase.google.com/), select **Storage**,
    then click **Get started**.

1.  Review the messaging about securing your Cloud Storage data using security
    rules. During development, consider
    [setting up your rules for public access](#set_up_public_access).

1.  Select a [location](/docs/projects/locations#types) for your default
    Cloud Storage bucket.

      * This location setting is your project's
        [_default Google Cloud Platform (GCP) resource location_](/docs/firestore/locations#default-cloud-location).
        Note that this location will be used for GCP services in your project
        that require a location setting, specifically, your
        [Cloud Firestore](/docs/firestore) database and your
        [App Engine](//cloud.google.com/appengine/docs/) app
        (which is required if you use Cloud Scheduler).

      * If you aren't able to select a location, then your project already
        has a default GCP resource location. It was set either during project
        creation or when setting up another service that requires a location
        setting.

    If you're on the Blaze plan, you can
    [create multiple buckets](#use_multiple_storage_buckets), each with its own
    [location](//cloud.google.com/storage/docs/bucket-locations).

    Note: After you set your project's default GCP resource location, you
    cannot change it.

1.  Click **Done**.


## Set up public access {:#set_up_public_access}

Cloud Storage for Firebase provides a declarative rules language that allows you
to define how your data should be structured, how it should be indexed, and when
your data can be read from and written to. By default, read and write access to
Cloud Storage is restricted so only authenticated users can read or write
data. To get started without setting up [Firebase Authentication](/docs/auth), you can
[configure your rules for public access](/docs/storage/security/rules-conditions#public).

This does make Cloud Storage open to anyone, even people not using your
app, so be sure to restrict your Cloud Storage again when you set up
authentication.


## Add the Cloud Storage SDK to your app {:#add-sdk}

1.  From the root of your Flutter project, run the following command to install
    the plugin:

    ```bash
    flutter pub add firebase_storage
    ```

1.  Once complete, rebuild your Flutter application:

    ```bash
    flutter run
    ```

1.  Import the plugin in your Dart code:

    ```dart
    import 'package:firebase_storage/firebase_storage.dart';
    ```


## Set up Cloud Storage {:#set-up-cloud-storage}

The first step in accessing your Cloud Storage bucket is to create an
instance of `FirebaseStorage`:

```dart
final storage = FirebaseStorage.instance;
```

You're ready to start using Cloud Storage!

First, let's learn how to [create a Cloud Storage reference](create-reference).

## Advanced setup

There are a few use cases that require additional setup:

  - Using Cloud Storage buckets in
    [multiple geographic regions](//cloud.google.com/storage/docs/bucket-locations)
  - Using Cloud Storage buckets in
    [different storage classes](//cloud.google.com/storage/docs/storage-classes)
  - Using Cloud Storage buckets with multiple authenticated users in the same app

The first use case is perfect if you have users across the world, and want to
store their data near them. For instance, you can create buckets in the US,
Europe, and Asia to store data for users in those regions to reduce latency.

The second use case is helpful if you have data with different access patterns.
For instance: you can set up a multi-regional or regional bucket that stores
pictures or other frequently accessed content, and a nearline or coldline bucket
that stores user backups or other infrequently accessed content.

In either of these use cases, you'll want to
[use multiple Cloud Storage buckets](#use_multiple_storage_buckets).

The third use case is useful if you're building an app, like Google Drive, which
lets users have multiple logged in accounts (for instance, a personal account
and a work account). You can
[use a custom Firebase App](#use_a_custom_firebaseapp)
instance to authenticate each additional account.

### Use multiple Cloud Storage buckets {:#use_multiple_storage_buckets}

If you want to use a Cloud Storage bucket other than the default provided above,
or use multiple Cloud Storage buckets in a single app, you can create an instance
of `FirebaseStorage` that references your custom bucket:

```dart
// Get a non-default Storage bucket
final storage = FirebaseStorage.instanceFor(bucket: "gs://my-custom-bucket");
```

### Working with imported buckets

When importing an existing Cloud Storage bucket into Firebase, you'll
have to grant Firebase the ability to access these files using the
`gsutil` tool, included in the
[Google Cloud SDK](//cloud.google.com/sdk/docs/):

```bash
gsutil -m acl ch -r -u service-PROJECT_NUMBER@gcp-sa-firebasestorage.iam.gserviceaccount.com gs://YOUR-CLOUD-STORAGE-BUCKET
```

You can find your project number as described in the [introduction to
Firebase projects](/docs/projects/learn-more#project-number).

This does not affect newly created buckets, as those have the default access
control set to allow Firebase. This is a temporary measure, and will be
performed automatically in the future.

### Use a custom Firebase App {:#use_a_custom_firebaseapp}

If you're building a more complicated app using a custom `FirebaseApp`, you can
create an instance of `FirebaseStorage` initialized with that app:

```dart
// Use a non-default App
final storage = FirebaseStorage.instanceFor(app: customApp);
```


## Next steps

* Prepare to launch your app:
  * Enable [App Check](/docs/app-check/overview) to help ensure that only
    your apps can access your storage buckets.
  * Set up [budget alerts](/docs/projects/billing/avoid-surprise-bills#set-up-budget-alert-emails)
    for your project in the Google Cloud Console.
  * Monitor the [_Usage and billing_ dashboard](//console.firebase.google.com/project/_/usage)
    in the Firebase console to get an overall picture of your project's
    usage across multiple Firebase services. You can also visit the
    [Cloud Storage _Usage_ dashboard](//console.firebase.google.com/project/_/storage/usage) for more
    detailed usage information.
  * Review the [Firebase launch checklist](/support/guides/launch-checklist).



================================================
File: docs/flutter/storage/upload-files.md
================================================
Project: /docs/storage/_project.yaml
Book: /docs/_book.yaml
page_type: guide

{% include "_shared/apis/console/_local_variables.html" %}

<!-- The following is at site root, /third_party/devsite/firebase/en/ -->
{% include "_local_variables.html" %}

{% include "docs/flutter/_local_variables.html" %}

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />

# Upload files with Cloud Storage on Flutter

Cloud Storage for Firebase allows you to quickly and easily upload files to a
[Cloud Storage](//cloud.google.com/storage) bucket provided
and managed by Firebase.

<<../_includes/_restrict_access_to_bucket_note.md>>

<<../../../_internal/includes/docs/guides/_hosting_storage_exe_ban.md>>
For more information, see
[this FAQ](/support/faq#storage-exe-restrictions).

## Upload Files

To upload a file to Cloud Storage, you first create a reference to the
full path of the file, including the file name.

```dart
// Create a storage reference from our app
final storageRef = FirebaseStorage.instance.ref();

// Create a reference to "mountains.jpg"
final mountainsRef = storageRef.child("mountains.jpg");

// Create a reference to 'images/mountains.jpg'
final mountainImagesRef = storageRef.child("images/mountains.jpg");

// While the file names are the same, the references point to different files
assert(mountainsRef.name == mountainImagesRef.name);
assert(mountainsRef.fullPath != mountainImagesRef.fullPath);
```

Once you've created an appropriate reference, you then call the
`putFile()`, `putString()`, or `putData()` method to upload the file
to Cloud Storage.

You cannot upload data with a reference to the root of your
Cloud Storage bucket. Your reference must point to a child URL.

### Upload from a file

To upload a file, you must first get the absolute path to its on-device
location. For example, if a file exists within the application's documents
directory, use the official [`path_provider`](https://pub.dev/packages/path_provider)
package to generate a file path and pass it to `putFile()`:

```dart
Directory appDocDir = await getApplicationDocumentsDirectory();
String filePath = '${appDocDir.absolute}/file-to-upload.png';
File file = File(filePath);

try {
  await mountainsRef.putFile(file);
} on firebase_core.FirebaseException catch (e) {
  // ...
}
```

### Upload from a String

You can upload data as a raw, `base64`, `base64url`, or `data_url` encoded
string using the `putString()` method. For example, to upload a text string
encoded as a Data URL:

```dart
String dataUrl = 'data:text/plain;base64,SGVsbG8sIFdvcmxkIQ==';

try {
  await mountainsRef.putString(dataUrl, format: PutStringFormat.dataUrl);
} on FirebaseException catch (e) {
  // ...
}
```

### Uploading raw data

You can upload lower-level typed data in the form of a [`Uint8List`](https://api.dart.dev/stable/2.9.2/dart-typed_data/Uint8List-class.html)
for those cases where uploading a string or `File` is not practical. In this
case, call the `putData()` method with your data:

```dart
try {
  // Upload raw data.
  await mountainsRef.putData(data);
} on firebase_core.FirebaseException catch (e) {
  // ...
}
```

## Get a download URL

After uploading a file, you can get a URL to download the file by calling
the `getDownloadUrl()` method on the `Reference`:

```dart
await mountainsRef.getDownloadURL();
```


## Add File Metadata

You can also include metadata when you upload files.
This metadata contains typical file metadata properties such as `contentType`
(commonly referred to as MIME type). The `putFile()` method
automatically infers the MIME type from the `File` extension, but you can
override the auto-detected type by specifying `contentType` in the metadata. If
you do not provide a `contentType` and Cloud Storage cannot infer a
default from the file extension, Cloud Storage uses
`application/octet-stream`. See [Use File Metadata](file-metadata).

```dart
try {
  await mountainsRef.putFile(file, SettableMetadata(
    contentType: "image/jpeg",
  ));
} on firebase_core.FirebaseException catch (e) {
  // ...
}
```


## Manage Uploads

In addition to starting uploads, you can pause, resume, and cancel uploads using
the `pause()`, `resume()`, and `cancel()` methods. Pause and resume events
raise `pause` and `progress` state changes respectively. Canceling an
upload causes the upload to fail with an error indicating that the
upload was canceled.

```dart
final task = mountainsRef.putFile(largeFile);

// Pause the upload.
bool paused = await task.pause();
print('paused, $paused');

// Resume the upload.
bool resumed = await task.resume();
print('resumed, $resumed');

// Cancel the upload.
bool canceled = await task.cancel();
print('canceled, $canceled');
```


## Monitor Upload Progress

You can listen to a task's event stream to handle success, failure, progress, or pauses in your
upload task:

Event Type           | Typical Usage
---------------------|---------------
`TaskState.running`  | Emitted periodically as data is transferred and can be used to populate an upload/download indicator.
`TaskState.paused`   | Emitted any time the task is paused.
`TaskState.success`  | Emitted when the task has successfully completed.
`TaskState.canceled` | Emitted any time the task is canceled.
`TaskState.error`    | Emitted when the upload has failed. This can happen due to network timeouts, authorization failures, or if you cancel the task.

```dart
mountainsRef.putFile(file).snapshotEvents.listen((taskSnapshot) {
  switch (taskSnapshot.state) {
    case TaskState.running:
      // ...
      break;
    case TaskState.paused:
      // ...
      break;
    case TaskState.success:
      // ...
      break;
    case TaskState.canceled:
      // ...
      break;
    case TaskState.error:
      // ...
      break;
  }
});
```

## Error Handling

There are a number of reasons why errors may occur on upload, including
the local file not existing, or the user not having permission to upload
the desired file. You can find more information about errors in the
[Handle Errors](handle-errors) section of the docs.

## Full Example

A full example of an upload with progress monitoring and error handling
is shown below:

```dart
final appDocDir = await getApplicationDocumentsDirectory();
final filePath = "${appDocDir.absolute}/path/to/mountains.jpg";
final file = File(filePath);

// Create the file metadata
final metadata = SettableMetadata(contentType: "image/jpeg");

// Create a reference to the Firebase Storage bucket
final storageRef = FirebaseStorage.instance.ref();

// Upload file and metadata to the path 'images/mountains.jpg'
final uploadTask = storageRef
    .child("images/path/to/mountains.jpg")
    .putFile(file, metadata);

// Listen for state changes, errors, and completion of the upload.
uploadTask.snapshotEvents.listen((TaskSnapshot taskSnapshot) {
  switch (taskSnapshot.state) {
    case TaskState.running:
      final progress =
          100.0 * (taskSnapshot.bytesTransferred / taskSnapshot.totalBytes);
      print("Upload is $progress% complete.");
      break;
    case TaskState.paused:
      print("Upload is paused.");
      break;
    case TaskState.canceled:
      print("Upload was canceled");
      break;
    case TaskState.error:
      // Handle unsuccessful uploads
      break;
    case TaskState.success:
      // Handle successful uploads on complete
      // ...
      break;
  }
});
```

Now that you've uploaded files, let's learn how to [download them](download-files)
from Cloud Storage.



================================================
File: docs/flutter/test-lab/integration-testing-with-flutter.md
================================================
Project: /docs/test-lab/_project.yaml
Book: /docs/_book.yaml
page_type: guide

{% include "_shared/apis/console/_local_variables.html" %}
{% include "_local_variables.html" %}
{% include "docs/test-lab/_local_variables.html" %}
{% include "docs/ios/_local_variables.html" %}
{% include "_shared/firebase/_snippet_include_comment.html" %}

<link rel="stylesheet" type="text/css" href="/styles/docs.css" />


# Integration Testing with Flutter

To test Flutter apps with {{firebase_testlab}}, you can write Flutter
integration tests, build Android APKs or iOS test zip files, and run as
regular Android instrumentation tests or iOS XCTests.


# Flutter integration test types {: #test-types}

Flutter supports three types of tests: unit tests, widget tests, and
integration tests. A *unit test* verifies the behavior of a method or class.
A *widget test* verifies the behavior of Flutter widgets without running the
app itself. An *integration test*, also called end-to-end testing or GUI
testing, runs the full app.

To learn more about integration tests, see [Flutter integration testing](https://docs.flutter.dev/testing/integration-tests){:.external}.


# Write Flutter integration tests {: #write-flutter-integration-tests}

To learn how to write integration tests, see the [project setup](https://docs.flutter.dev/testing/integration-tests#project-setup){:.external}
section of the Flutter integration tests documentation. Optionally, you can
follow [running using Flutter command](https://docs.flutter.dev/testing/integration-tests#running-using-the-flutter-command){:.external}
to run and verify the tests locally.


# Test on {{testlab}} {: #test-on-test-lab}

You can use {{testlab}} with both Android and iOS targets.


## Android setup {: #android-setup}

Follow the instructions in the
[Android Device Testing](https://github.com/flutter/flutter/tree/main/packages/integration_test#android-device-testing){:.external}
section of the README.


## iOS setup {: #ios-setup}

Follow the instructions in the
[iOS Device Testing](https://github.com/flutter/flutter/tree/main/packages/integration_test#ios-device-testing){:.external}
section of the README.

## Robo test support {: #robo-test-support}

[Robo tests](/docs/test-lab/android/robo-ux-test) do not natively support
Flutter. To improve crawling of your app, use [Robo scripts](/docs/test-lab/android/run-robo-scripts),
which are tests that automate manual QA tasks for mobile apps, and enable
continuous integration (CI) and pre-launch testing strategies.
For example, to control Robo behavior in a more precise and robust way, you can
use clicks with [visionText](/docs/test-lab/android/robo-scripts-reference#click).


# Analyze test results {: #analyze-test-results}

You can run Flutter integration tests as an Android instrumentation test or an
iOS XCTest. To analyze the result of an integration test, see the
documentation for [Android](https://firebase.google.com/docs/test-lab/android/analyzing-results){:.external}
and [iOS](https://firebase.google.com/docs/test-lab/ios/analyzing-results){:.external},
depending on your platform.


## Limitations {: #limitations}

Test timing information for individual test cases is not available, which means
that features like test case duration and videos for individual test cases
don't work as expected.

## Troubleshooting {: #troubleshooting}

If you encounter issues, check the [public issue tracker for integration tests](https://github.com/flutter/flutter/issues?q=is%3Aopen+is%3Aissue+label%3Aintegration_test){:.external}.

If you encounter a new issue caused by the integration test framework,
file a new issue in the public issue tracker following the guidance in
[Creating useful bug reports](https://docs.flutter.dev/resources/bug-reports){:.external}.



================================================
File: .github/workflows/pull-and-push-all.yml
================================================
name: pull-and-push-all
run-name: ${{ github.actor }} is trying pull and push all
on:
  schedule:
    - cron:  '0 8 * * *' # every day at 8 AM UTC (midnight or 1:00 depending on DST)
  workflow_dispatch:


jobs:
  pull-flutter:
    uses: firebase/firebase-docs/.github/workflows/pull-map-and-push-repo.yml@main
    permissions:
      contents: write
    with:
      target_source_repo: https://github.com/firebase/flutterfire.git
      git_commit_user_email: firebase-oss-bot@ossbot.computer
      git_commit_user_name: Firebase OSS Robot
      git_commit_message_text: Pull and push of flutterfire/docs by ${{github.workflow}} run ${{github.run_number}}
      copy_mapping_sources: flutterfire/docs
      copy_mapping_destinations: docs/flutter
      seconds_between_push_tries: 2
  # Web
  pull-codelab-web-friendlychat:
    uses: firebase/firebase-docs/.github/workflows/pull-map-and-push-repo.yml@main
    permissions:
      contents: write
    with:
      target_source_repo: https://github.com/firebase/codelab-friendlychat-web.git
      git_commit_user_email: firebase-oss-bot@ossbot.computer
      git_commit_user_name: Firebase OSS Robot
      git_commit_message_text: Pull and push of codelab-friendlychat-web/angularfire-start by ${{github.workflow}} run ${{github.run_number}}
      copy_mapping_sources: codelab-friendlychat-web/angularfire-start
      copy_mapping_destinations: codelabs/codelab-friendlychat-web/steps
      seconds_between_push_tries: 3
  pull-codelab-web-friendlyeats:
    uses: firebase/firebase-docs/.github/workflows/pull-map-and-push-repo.yml@main
    permissions:
      contents: write
    with:
      target_source_repo: https://github.com/firebase/friendlyeats-web.git
      git_commit_user_email: firebase-oss-bot@ossbot.computer
      git_commit_user_name: Firebase OSS Robot
      git_commit_message_text: Pull and push of friendlyeats-web/vanilla-js/steps by ${{github.workflow}} run ${{github.run_number}}
      copy_mapping_sources: friendlyeats-web/vanilla-js/steps
      copy_mapping_destinations: codelabs/codelab-friendlyeats-web/vanilla-js/steps
      seconds_between_push_tries: 4
# Android
  pull-codelab-android-friendlychat:
    uses: firebase/firebase-docs/.github/workflows/pull-map-and-push-repo.yml@main
    permissions:
      contents: write
    with:
      target_source_repo: https://github.com/firebase/codelab-friendlychat-android.git
      git_commit_user_email: firebase-oss-bot@ossbot.computer
      git_commit_user_name: Firebase OSS Robot
      git_commit_message_text: Pull and push of codelab-friendlychat-android/steps by ${{github.workflow}} run ${{github.run_number}}
      copy_mapping_sources: codelab-friendlychat-android/steps
      copy_mapping_destinations: codelabs/codelab-friendlychat-android/steps
      seconds_between_push_tries: 5
  pull-codelab-android-friendlyeats:
    uses: firebase/firebase-docs/.github/workflows/pull-map-and-push-repo.yml@main
    permissions:
      contents: write
    with:
      target_source_repo: https://github.com/firebase/friendlyeats-android.git
      git_commit_user_email: firebase-oss-bot@ossbot.computer
      git_commit_user_name: Firebase OSS Robot
      git_commit_message_text: Pull and push of friendlyeats-android/steps by ${{github.workflow}} run ${{github.run_number}}
      copy_mapping_sources: friendlyeats-android/steps
      copy_mapping_destinations: codelabs/codelab-friendlyeats-android/steps
      seconds_between_push_tries: 6
  # Finalize
  send-update-notification:
    name: send-update-notification
    runs-on: ubuntu-latest
    needs: [pull-flutter, pull-codelab-web-friendlychat, pull-codelab-web-friendlyeats, pull-codelab-android-friendlychat, pull-codelab-android-friendlyeats]
    permissions:
      contents: read
      issues: write
    steps:
      - name: Checkout Latest
        uses: actions/checkout@v3
        with:
          ref: ${{ github.ref }} # Forces getting the latest instead of the default behaviour of the triggering SHA.
      - name: Print Diff
        shell: bash
        run: |
          if [ "${{ github.sha }}" = "$(git rev-parse HEAD)" ]; then
              echo "No changes."
          else
              echo "SHAs are not equal. Docs updated."
              gh issue create --title "Docs Updated" --body "New changes pulled into monorepo." --assignee "joefspiro" --label "type: process" --label "priority: p3"
          fi
          echo ${{ github.sha }} $(git rev-parse HEAD) $GITHUB_SHA 
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}


================================================
File: .github/workflows/pull-map-and-push-repo.yml
================================================
name: pull-map-and-push-repo
run-name: ${{ github.actor }} is trying to pull, map and push ${{ inputs.target_source_repo }}
on:
  workflow_dispatch:
    inputs:
      target_source_repo:
        type: string
        description: 'Repo to copy in.'
        default: 'https://github.com/firebase/flutterfire.git'
        required: true
      git_commit_user_email:
        type: string
        description: 'Commit user email.'
        default: 'firebase-oss-bot@ossbot.computer'
        required: true
      git_commit_user_name:
        type: string
        description: 'Commit user name.'
        default: 'Firebase OSS Robot'
        required: true
      git_commit_message_text:
        type: string
        description: 'Commit Message Text'
        default: 'Pull and push of flutterfire/docs'
        required: true
      copy_mapping_sources:
        type: string
        description: 'Source Directories/Files'
        default: 'flutterfire/docs'
        required: true
      copy_mapping_destinations:
        type: string
        description: 'Destination Directories'
        default: 'docs/flutter'
        required: true
      seconds_between_push_tries:
        type: string
        description: 'How many seconds to sleep between push attempts.'
        default: '2'
        required: true
  workflow_call:
    inputs:
      target_source_repo:
        type: string
        description: 'Repo to copy in.'
        default: 'https://github.com/firebase/flutterfire.git'
        required: true
      git_commit_user_email:
        type: string
        description: 'Commit user email.'
        default: 'firebase-oss-bot@ossbot.computer'
        required: true
      git_commit_user_name:
        type: string
        description: 'Commit user name.'
        default: 'Firebase OSS Robot'
        required: true
      git_commit_message_text:
        type: string
        description: 'Commit Message Text'
        default: 'Pull and push of flutterfire/docs'
        required: true
      copy_mapping_sources:
        type: string
        description: 'Source Directories/Files'
        default: 'flutterfire/docs'
        required: true
      copy_mapping_destinations:
        type: string
        description: 'Destination Directories'
        default: 'docs/flutter'
        required: true
      seconds_between_push_tries:
        type: string
        description: 'How many seconds to sleep between push attempts.'
        default: '2'
        required: true

jobs:
  checkout-pull-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v3
      - name: pull-external
        run: |
          mkdir temp-pull && cd temp-pull &&
          git clone ${{inputs.target_source_repo}} && ls -r
      - name: copy-target-to-new-location
        run: |
          sources_array=(${{inputs.copy_mapping_sources}})
          destinations_array=(${{inputs.copy_mapping_destinations}})
          echo ${#sources_array[@]} ${#destinations_array[@]}
          if [ ${#sources_array[@]} != ${#destinations_array[@]} ]; then
            echo 'sources_array and destinations_array must be the same length. Please fix.'
            exit 1
          fi
          for (( i=0; i<${#sources_array[@]}; i++ ))
          do
            echo A:B ${sources_array[$i]}:${destinations_array[$i]}
            mkdir -p ${destinations_array[$i]}
            # check if its a directoy, if so, do whats listed already, if not then
            if [[ -d "temp-pull/${sources_array[$i]}" ]]
            then
                echo "temp-pull/${sources_array[$i]} is a DIRECTORY."
                cp -rf temp-pull/${sources_array[$i]}/. ${destinations_array[$i]}
            else
                echo "temp-pull/${sources_array[$i]} is a FILE."
                cp -rf temp-pull/${sources_array[$i]} ${destinations_array[$i]}
            fi
          done
      - name: remove-temp-pull
        run: rm -r temp-pull && git status --untracked-files
      - name: git-commit-and-push
        run: |
          if [ -z "$(git status --porcelain)" ]; then 
            echo 'No changes detected. Exiting.'
            exit 0
          fi
          echo 'Changes detected. Attempting to add, commit, pull --rebase and push.'
          git add .
          git config user.email "${{inputs.git_commit_user_email}}"
          git config user.name "${{inputs.git_commit_user_name}}"
          git commit -m '${{inputs.git_commit_message_text}}'
          let retries_remaining=5
          let seconds_between_push_tries=${{inputs.seconds_between_push_tries}}
          while [ $retries_remaining -gt 0 ]
          do
            git pull --rebase
            git status
            set +e # Turns off automatic fail on errored step behaviour.
            git push
            if [ $? -eq 0 ]; then
                echo "Command succeeded"
                retries_remaining=0
            else
              ((retries_remaining=retries_remaining-1))
              echo "Retrying in $seconds_between_push_tries seconds."
              sleep $seconds_between_push_tries
            fi
            set -e
          done


